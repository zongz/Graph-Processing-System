<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::dc_dist_object&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1dc__dist__object.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgraphlab_1_1dc__dist__object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::dc_dist_object&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__rpc.html">GraphLab RPC</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a class with its own distributed communication context, allowing instances of the class to communicate with other remote instances.  
 <a href="classgraphlab_1_1dc__dist__object.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dc__dist__object_8hpp_source.html">graphlab/rpc/dc_dist_object.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a07bd2a64317893f95dcc161a93f6746c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a07bd2a64317893f95dcc161a93f6746c">dc_dist_object</a> (<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;dc_, T *owner)</td></tr>
<tr class="memdesc:a07bd2a64317893f95dcc161a93f6746c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a distributed object context.  <a href="#a07bd2a64317893f95dcc161a93f6746c">More...</a><br /></td></tr>
<tr class="separator:a07bd2a64317893f95dcc161a93f6746c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb00bba307ed312b69477fb0274fc65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eb00bba307ed312b69477fb0274fc65"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a1eb00bba307ed312b69477fb0274fc65">calls_received</a> () const </td></tr>
<tr class="memdesc:a1eb00bba307ed312b69477fb0274fc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of function calls received by this object. <br /></td></tr>
<tr class="separator:a1eb00bba307ed312b69477fb0274fc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6b365a01c705c25cb5d07f6288a48c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade6b365a01c705c25cb5d07f6288a48c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#ade6b365a01c705c25cb5d07f6288a48c">calls_sent</a> () const </td></tr>
<tr class="memdesc:ade6b365a01c705c25cb5d07f6288a48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of function calls sent from this object. <br /></td></tr>
<tr class="separator:ade6b365a01c705c25cb5d07f6288a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ae9f396bc228f0822a36c59b061ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af46ae9f396bc228f0822a36c59b061ff"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff">bytes_sent</a> () const </td></tr>
<tr class="memdesc:af46ae9f396bc228f0822a36c59b061ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes sent from this object, excluding headers and other control overhead. <br /></td></tr>
<tr class="separator:af46ae9f396bc228f0822a36c59b061ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f98d089ad572f59c05186925f3a01fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f98d089ad572f59c05186925f3a01fb"></a>
<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a2f98d089ad572f59c05186925f3a01fb">dc</a> ()</td></tr>
<tr class="memdesc:a2f98d089ad572f59c05186925f3a01fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to the underlying <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> object. <br /></td></tr>
<tr class="separator:a2f98d089ad572f59c05186925f3a01fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcebf8940d4a48aa44dfb39c8a3ffbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbcebf8940d4a48aa44dfb39c8a3ffbb"></a>
const <a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#adbcebf8940d4a48aa44dfb39c8a3ffbb">dc</a> () const </td></tr>
<tr class="memdesc:adbcebf8940d4a48aa44dfb39c8a3ffbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reference to the underlying <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> object. <br /></td></tr>
<tr class="separator:adbcebf8940d4a48aa44dfb39c8a3ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35c107876915b9eef1266610b76f398"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab35c107876915b9eef1266610b76f398"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#ab35c107876915b9eef1266610b76f398">procid</a> () const </td></tr>
<tr class="memdesc:ab35c107876915b9eef1266610b76f398"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current process ID. <br /></td></tr>
<tr class="separator:ab35c107876915b9eef1266610b76f398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f265ff4a28c800c43eb293bce0acad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f265ff4a28c800c43eb293bce0acad"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a49f265ff4a28c800c43eb293bce0acad">numprocs</a> () const </td></tr>
<tr class="memdesc:a49f265ff4a28c800c43eb293bce0acad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of processes in the distributed program. <br /></td></tr>
<tr class="separator:a49f265ff4a28c800c43eb293bce0acad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bccff1105c4a64d06f8bd2e09cb667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91bccff1105c4a64d06f8bd2e09cb667"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a91bccff1105c4a64d06f8bd2e09cb667">cout</a> () const </td></tr>
<tr class="memdesc:a91bccff1105c4a64d06f8bd2e09cb667"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper on cout, that outputs only on machine 0. <br /></td></tr>
<tr class="separator:a91bccff1105c4a64d06f8bd2e09cb667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a367e79214ad2873c5a73fdaaa71eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78a367e79214ad2873c5a73fdaaa71eb"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a78a367e79214ad2873c5a73fdaaa71eb">cerr</a> () const </td></tr>
<tr class="memdesc:a78a367e79214ad2873c5a73fdaaa71eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper on cerr, that outputs only on machine 0. <br /></td></tr>
<tr class="separator:a78a367e79214ad2873c5a73fdaaa71eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c423bdc58f79caf04da261b97454d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01">remote_call</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:a0c423bdc58f79caf04da261b97454d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking RPC call to the target machine to run the provided function pointer.  <a href="#a0c423bdc58f79caf04da261b97454d01">More...</a><br /></td></tr>
<tr class="separator:a0c423bdc58f79caf04da261b97454d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab685e7eaddcadcd50f4d2c93c3ab6660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#ab685e7eaddcadcd50f4d2c93c3ab6660">remote_call</a> (Iterator machine_begin, Iterator machine_end, Fn fn,...)</td></tr>
<tr class="memdesc:ab685e7eaddcadcd50f4d2c93c3ab6660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking RPC call to a collection of machines to run the provided function pointer.  <a href="#ab685e7eaddcadcd50f4d2c93c3ab6660">More...</a><br /></td></tr>
<tr class="separator:ab685e7eaddcadcd50f4d2c93c3ab6660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23845fd5c66033a13a5c689a65583f1b"><td class="memItemLeft" align="right" valign="top">RetVal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b">remote_request</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:a23845fd5c66033a13a5c689a65583f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking RPC call to the target machine to run the provided function pointer.  <a href="#a23845fd5c66033a13a5c689a65583f1b">More...</a><br /></td></tr>
<tr class="separator:a23845fd5c66033a13a5c689a65583f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058fafc0d3650176df4457eb6f93968f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt; RetVal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a058fafc0d3650176df4457eb6f93968f">future_remote_request</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:a058fafc0d3650176df4457eb6f93968f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a nonblocking RPC call to the target machine to run the provided function pointer which has an expected return value.  <a href="#a058fafc0d3650176df4457eb6f93968f">More...</a><br /></td></tr>
<tr class="separator:a058fafc0d3650176df4457eb6f93968f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e791b279885109567e759c06182e80"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ac7e791b279885109567e759c06182e80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#ac7e791b279885109567e759c06182e80">send_to</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> target, U &amp;t, bool control=false)</td></tr>
<tr class="memdesc:ac7e791b279885109567e759c06182e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an object to a target machine and blocks until the target machine calls <a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> to receive the object.  <a href="#ac7e791b279885109567e759c06182e80">More...</a><br /></td></tr>
<tr class="separator:ac7e791b279885109567e759c06182e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160e63e42fb6980db24b77dea84d0c34"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a160e63e42fb6980db24b77dea84d0c34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34">recv_from</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> source, U &amp;t, bool control=false)</td></tr>
<tr class="memdesc:a160e63e42fb6980db24b77dea84d0c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits to receives an object a source machine sent via <a class="el" href="classgraphlab_1_1dc__dist__object.html#ac7e791b279885109567e759c06182e80" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a>  <a href="#a160e63e42fb6980db24b77dea84d0c34">More...</a><br /></td></tr>
<tr class="separator:a160e63e42fb6980db24b77dea84d0c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a79863a2e99e5873d914db2068254d7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0a79863a2e99e5873d914db2068254d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a0a79863a2e99e5873d914db2068254d7">broadcast</a> (U &amp;data, bool originator, bool control=false)</td></tr>
<tr class="memdesc:a0a79863a2e99e5873d914db2068254d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows one machine to broadcasts an object to all machines.  <a href="#a0a79863a2e99e5873d914db2068254d7">More...</a><br /></td></tr>
<tr class="separator:a0a79863a2e99e5873d914db2068254d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74164a51de9167f76fe25d354cb31310"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a74164a51de9167f76fe25d354cb31310"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a74164a51de9167f76fe25d354cb31310">gather</a> (std::vector&lt; U &gt; &amp;data, <a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> sendto, bool control=false)</td></tr>
<tr class="memdesc:a74164a51de9167f76fe25d354cb31310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects information contributed by each machine onto one machine.  <a href="#a74164a51de9167f76fe25d354cb31310">More...</a><br /></td></tr>
<tr class="separator:a74164a51de9167f76fe25d354cb31310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676879bb9698a4263ac63de6c6bbafc0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a676879bb9698a4263ac63de6c6bbafc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a676879bb9698a4263ac63de6c6bbafc0">all_gather</a> (std::vector&lt; U &gt; &amp;data, bool control=false)</td></tr>
<tr class="memdesc:a676879bb9698a4263ac63de6c6bbafc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends some information contributed by each machine to all machines.  <a href="#a676879bb9698a4263ac63de6c6bbafc0">More...</a><br /></td></tr>
<tr class="separator:a676879bb9698a4263ac63de6c6bbafc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f2101211b904a4ae5952b06bec6d98"><td class="memTemplParams" colspan="2">template&lt;typename U , typename PlusEqual &gt; </td></tr>
<tr class="memitem:ab1f2101211b904a4ae5952b06bec6d98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#ab1f2101211b904a4ae5952b06bec6d98">all_reduce2</a> (U &amp;data, PlusEqual plusequal, bool control=false)</td></tr>
<tr class="memdesc:ab1f2101211b904a4ae5952b06bec6d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a value contributed by each machine, making the result available to all machines.  <a href="#ab1f2101211b904a4ae5952b06bec6d98">More...</a><br /></td></tr>
<tr class="separator:ab1f2101211b904a4ae5952b06bec6d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaed65c82cec16efdde34947f35c447"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5aaed65c82cec16efdde34947f35c447"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a5aaed65c82cec16efdde34947f35c447">all_reduce</a> (U &amp;data, bool control=false)</td></tr>
<tr class="memdesc:a5aaed65c82cec16efdde34947f35c447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a value contributed by each machine, making the result available to all machines.  <a href="#a5aaed65c82cec16efdde34947f35c447">More...</a><br /></td></tr>
<tr class="separator:a5aaed65c82cec16efdde34947f35c447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5210d7f0f2cd26fb1be00e3c3343a46b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5210d7f0f2cd26fb1be00e3c3343a46b"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5210d7f0f2cd26fb1be00e3c3343a46b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_to_all</b> (std::vector&lt; U &gt; &amp;data, bool control=false)</td></tr>
<tr class="separator:a5210d7f0f2cd26fb1be00e3c3343a46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8dee7f045c5186a0015aba5ca44e8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#aec8dee7f045c5186a0015aba5ca44e8f">barrier</a> ()</td></tr>
<tr class="memdesc:aec8dee7f045c5186a0015aba5ca44e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1dc__dist__object.html#aec8dee7f045c5186a0015aba5ca44e8f" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a> function before proceeding.  <a href="#aec8dee7f045c5186a0015aba5ca44e8f">More...</a><br /></td></tr>
<tr class="separator:aec8dee7f045c5186a0015aba5ca44e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5478c426fd12ef635f67ec6b7faf2f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#a5478c426fd12ef635f67ec6b7faf2f21">full_barrier</a> ()</td></tr>
<tr class="memdesc:a5478c426fd12ef635f67ec6b7faf2f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5478c426fd12ef635f67ec6b7faf2f21" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> function before proceeding. Also waits for all previously issued remote calls to complete.  <a href="#a5478c426fd12ef635f67ec6b7faf2f21">More...</a><br /></td></tr>
<tr class="separator:a5478c426fd12ef635f67ec6b7faf2f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa513af6755a38c5a15e159d3621db365"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html#aa513af6755a38c5a15e159d3621db365">gather_statistics</a> ()</td></tr>
<tr class="separator:aa513af6755a38c5a15e159d3621db365"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class graphlab::dc_dist_object&lt; T &gt;</h3>

<p>Provides a class with its own distributed communication context, allowing instances of the class to communicate with other remote instances. </p>
<p>The philosophy behind the <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">dc_dist_object</a> is the concept of "distributed
objects". The idea is that the user should be able to write code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">  <span class="comment">// ... initialization of a distributed_control object dc ...</span></div>
<div class="line"></div>
<div class="line">  distributed_vector vec(dc), vec2(dc);</div>
<div class="line">  distributed_graph g(dc);</div>
<div class="line">}</div>
</div><!-- fragment --><p> where if run in a distributed setting, the "vec" variable, can behave as if it is a single distributed object, and automatically coordinate its operations across the network; communicating with the other instances of "vec" on the other machines. Essentially, each object (vec, vec2 and g) constructs its own private communication context, which allows every machine's "vec" variable to communicate only with other machine's "vec" variable. And similarly for "vec2" and "g". This private communication context is provided by this <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">dc_dist_object</a> class.</p>
<p>To construct a distributed object requires little work: </p><div class="fragment"><div class="line"><span class="keyword">class </span>distributed_int_vector {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// creates a local dc_dist_object context</span></div>
<div class="line">    <a class="code" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object&lt;distributed_int_vector&gt;</a> rmi;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// context must be initialized on construction with the</span></div>
<div class="line">    <span class="comment">// root distributed_control object</span></div>
<div class="line">    distributed_int_vector(distributed_control&amp; dc): rmi(dc, this) {</div>
<div class="line">      ... other initialization ...</div>
<div class="line">      <span class="comment">// make sure all machines finish constructing this object</span></div>
<div class="line">      <span class="comment">// before continuing</span></div>
<div class="line">      rmi.<a class="code" href="classgraphlab_1_1dc__dist__object.html#aec8dee7f045c5186a0015aba5ca44e8f">barrier</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>After which <a class="el" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">remote_call()</a>, and <a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a> can be used to communicate across the network with the same matching instance of the distributed_int_vector.</p>
<p>Each <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">dc_dist_object</a> maintains its own private communication context which is not influences by other communication contexts. In other words, the <code>rmi.barrier()</code>, and all other operations in each instance of the distributed_int_vector are independent of each other. In particular, the <code>rmi.full_barrier()</code> only waits for completion of all RPC calls from within the current communication context.</p>
<p>See the examples in <a class="el" href="RPC.html">GraphLab RPC</a> for more usage examples.</p>
<dl class="section note"><dt>Note</dt><dd>While there is no real limit to the number of distributed objects that can be created. However, each <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">dc_dist_object</a> does contain a reasonably large amount of state, so frequent construction and deletion of objects is not recommended. </dd></dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l00115">115</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a07bd2a64317893f95dcc161a93f6746c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::<a class="el" href="classgraphlab_1_1dc__dist__object.html">dc_dist_object</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td>
          <td class="paramname"><em>dc_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a distributed object context. </p>
<p>The constructor constructs a distributed object context which is associated with the "owner" object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc_</td><td>The root <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> which provides the communication control plane. </td></tr>
    <tr><td class="paramname">owner</td><td>The object to associate with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l00203">203</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a676879bb9698a4263ac63de6c6bbafc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::all_gather </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends some information contributed by each machine to all machines. </p>
<p>The goal is to have each machine broadcast a piece of information to all machines. This is like <a class="el" href="classgraphlab_1_1dc__dist__object.html#a74164a51de9167f76fe25d354cb31310" title="Collects information contributed by each machine onto one machine. ">gather()</a>, but all machines have the complete vector at the end. To accomplish this, each machine constructs a vector of length <a class="el" href="classgraphlab_1_1dc__dist__object.html#a49f265ff4a28c800c43eb293bce0acad" title="The number of processes in the distributed program. ">numprocs()</a>, and stores the data to communicate in the <a class="el" href="classgraphlab_1_1dc__dist__object.html#ab35c107876915b9eef1266610b76f398" title="The current process ID. ">procid()</a>'th entry in the vector. Then calling all_gather with the vector will result in all machines having a complete copy of the vector containing all contributions (entry 0 from machine 0, entry 1 from machine 1, etc).</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// construct the vector of values</span></div>
<div class="line">std::vector&lt;int&gt; <a class="code" href="namespacegraphlab.html#abb8f631ef7e698460f144b74ffd6d3ee">values</a>;</div>
<div class="line">values.resize(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1">numprocs</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// set my contributed value</span></div>
<div class="line">values[dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>()] = dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>();</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a53bf32af89963f79f197b40a4abc24ff">all_gather</a>(values);</div>
<div class="line"><span class="comment">// at this point all machine will have a vector with length equal to the</span></div>
<div class="line"><span class="comment">// number of processes, and containing values [0, 1, 2, ...]</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Behavior is undefined if multiple threads on the same machine call all_gather simultaneously</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A vector of length equal to the number of processes. The information to communicate is in the entry data[<a class="el" href="classgraphlab_1_1dc__dist__object.html#ab35c107876915b9eef1266610b76f398" title="The current process ID. ">procid()</a>] </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in bytes_received() or <a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff" title="The number of bytes sent from this object, excluding headers and other control overhead. ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l01052">1052</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aaed65c82cec16efdde34947f35c447"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::all_reduce </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines a value contributed by each machine, making the result available to all machines. </p>
<p>Each machine calls <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5aaed65c82cec16efdde34947f35c447" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a> with a object which is serializable and has operator+= implemented. When <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5aaed65c82cec16efdde34947f35c447" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a> returns, the "data" variable will contain a value corresponding to adding up the objects contributed by each machine.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 1;</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180">all_reduce</a>(i);</div>
<div class="line"><span class="comment">// since each machine contributed the value &quot;1&quot;,</span></div>
<div class="line"><span class="comment">// all machines will have i = numprocs() here.</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A piece of data to perform a reduction over. The type must implement operator+=. </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in bytes_received() or <a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff" title="The number of bytes sent from this object, excluding headers and other control overhead. ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l01295">1295</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1f2101211b904a4ae5952b06bec6d98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename PlusEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::all_reduce2 </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlusEqual&#160;</td>
          <td class="paramname"><em>plusequal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines a value contributed by each machine, making the result available to all machines. </p>
<p>This function is equivalent to <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5aaed65c82cec16efdde34947f35c447" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a>, but with an externally defined PlusEqual function.</p>
<p>Each machine calls <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5aaed65c82cec16efdde34947f35c447" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a> with a object which is serializable and a function "plusequal" which combines two instances of the object. When <a class="el" href="classgraphlab_1_1dc__dist__object.html#ab1f2101211b904a4ae5952b06bec6d98" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce2()</a> returns, the "data" variable will contain a value corresponding to adding up the objects contributed by each machine using the plusequal function.</p>
<p>Where U is the type of the object, the plusequal function must be of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> plusequal(U&amp; left, <span class="keyword">const</span> U&amp; right);</div>
</div><!-- fragment --><p> and must implement the equivalent of <code>left += right; </code></p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> int_plus_equal(<span class="keywordtype">int</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; b) {</div>
<div class="line"> a+=b;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> i = 1;</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a353f74d3aece1a8eafb1a436f3501fc7">all_reduce2</a>(i, int_plus_equal);</div>
<div class="line"><span class="comment">// since each machine contributed the value &quot;1&quot;,</span></div>
<div class="line"><span class="comment">// all machines will have i = numprocs() here.</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A piece of data to perform a reduction over. </td></tr>
    <tr><td class="paramname">plusequal</td><td>A plusequal function on the data. Must have the prototype void plusequal(U&amp;, const U&amp;) </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in bytes_received() or <a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff" title="The number of bytes sent from this object, excluding headers and other control overhead. ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l01184">1184</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec8dee7f045c5186a0015aba5ca44e8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::<a class="el" href="classgraphlab_1_1cancellable__barrier.html">barrier</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1dc__dist__object.html#aec8dee7f045c5186a0015aba5ca44e8f" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a> function before proceeding. </p>
<p>A machine calling the <a class="el" href="classgraphlab_1_1dc__dist__object.html#aec8dee7f045c5186a0015aba5ca44e8f" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a> will wait until every machine reaches this barrier before continuing. Only one thread from each machine should call the barrier.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgraphlab_1_1dc__dist__object.html#a5478c426fd12ef635f67ec6b7faf2f21" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier</a> </dd></dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l01410">1410</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a79863a2e99e5873d914db2068254d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::broadcast </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>originator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function allows one machine to broadcasts an object to all machines. </p>
<p>The originator calls broadcast with data provided in in 'data' and originator set to true. All other callers call with originator set to false.</p>
<p>The originator will then return 'data'. All other machines will receive the originator's transmission in the "data" parameter.</p>
<p>This call is guaranteed to have barrier-like behavior. That is to say, this call will block until all machines enter the broadcast function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="classgraphlab_1_1dc__dist__object.html#ab35c107876915b9eef1266610b76f398">procid</a>() == 0) {</div>
<div class="line">  <span class="comment">// if I am machine 0, I broadcast the value i = 10 to all machines</span></div>
<div class="line">  i = 10;</div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a9414f3bf9679b88b9e0074bdfc171653">broadcast</a>(i, <span class="keyword">true</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// all other machines receive the broadcast value</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a9414f3bf9679b88b9e0074bdfc171653">broadcast</a>(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// at this point, all machines have i = 10</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Behavior is undefined if more than one machine calls broadcast with originator set to true.</dd>
<dd>
Behavior is undefined if multiple threads on the same machine call broadcast simultaneously</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>If this is the originator, this will contain the object to broadcast. Otherwise, this will be a reference to the object receiving the broadcast. </td></tr>
    <tr><td class="paramname">originator</td><td>Set to true if this is the source of the broadcast. Set to false otherwise. </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in bytes_received() or <a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff" title="The number of bytes sent from this object, excluding headers and other control overhead. ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l00878">878</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5478c426fd12ef635f67ec6b7faf2f21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::full_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5478c426fd12ef635f67ec6b7faf2f21" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> function before proceeding. Also waits for all previously issued remote calls to complete. </p>
<p>Similar to the <a class="el" href="classgraphlab_1_1dc__dist__object.html#aec8dee7f045c5186a0015aba5ca44e8f" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a>, but provides additional guarantees that all calls issued prior to this barrier are completed before i returning.</p>
<dl class="section note"><dt>Note</dt><dd>This function could return prematurely if other threads are still issuing function calls since we cannot differentiate between calls issued before the barrier and calls issued while the barrier is being evaluated. Therefore, when used in a multithreaded scenario, the user must ensure that all other threads which may perform operations using this object are stopped before the full barrier is initated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbarrier.html">barrier</a></dd></dl>
<p>This barrier ensures globally across all machines that all calls issued prior to this barrier are completed before returning. This function could return prematurely if other threads are still issuing function calls since we cannot differentiate between calls issued before the barrier and calls issued while the barrier is being evaluated. </p>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l01480">1480</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a058fafc0d3650176df4457eb6f93968f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt;RetVal&gt; <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::future_remote_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a nonblocking RPC call to the target machine to run the provided function pointer which has an expected return value. </p>
<p><a class="el" href="classgraphlab_1_1dc__dist__object.html#a058fafc0d3650176df4457eb6f93968f" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">future_remote_request()</a> calls the function "fn" on a target remote machine. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, it is sent back to calling machine.</p>
<p><a class="el" href="classgraphlab_1_1dc__dist__object.html#a058fafc0d3650176df4457eb6f93968f" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">future_remote_request()</a> is like <a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a>, but is non-blocking. Instead, it returns immediately a <a class="el" href="structgraphlab_1_1request__future.html">graphlab::request_future</a> object which will allow you wait for the return value.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined in the distributed object</span></div>
<div class="line"><span class="keyword">class </span>distributed_obj_example {</div>
<div class="line"> <a class="code" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object&lt;distributed_obj_example&gt;</a> rmi;</div>
<div class="line">  ... initialization and constructor ...</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">   <span class="keywordtype">int</span> add_one(<span class="keywordtype">int</span> i) {</div>
<div class="line">     <span class="keywordflow">return</span> i + 1;</div>
<div class="line">   }</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">int</span> add_one_from_machine_1(<span class="keywordtype">int</span> i) {</div>
<div class="line">     <span class="comment">// calls the add_one function on machine 1 with the argument i</span></div>
<div class="line">     <span class="comment">// this call returns immediately</span></div>
<div class="line">     <a class="code" href="structgraphlab_1_1request__future.html">graphlab::request_future&lt;int&gt;</a> future =</div>
<div class="line">         rmi.<a class="code" href="classgraphlab_1_1dc__dist__object.html#a058fafc0d3650176df4457eb6f93968f">future_remote_request</a>(1, &amp;distributed_obj_example::add_one, i);</div>
<div class="line"></div>
<div class="line">     <span class="comment">// ... we can do other stuff here</span></div>
<div class="line">     <span class="comment">// then when we want the answer</span></div>
<div class="line">     <span class="keywordtype">int</span> result = future();</div>
<div class="line">     <span class="keywordflow">return</span> result;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::object_fiber_remote_request</a> <a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">graphlab::dc_dist_object::remote_request</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine. Must be a pointer to member function in the owning object. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a future templated around the same type as the return value of the called function </dd></dl>

</div>
</div>
<a class="anchor" id="a74164a51de9167f76fe25d354cb31310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::gather </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>sendto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects information contributed by each machine onto one machine. </p>
<p>The goal is to collect some information from each machine onto a single target machine (sendto). To accomplish this, each machine constructs a vector of length <a class="el" href="classgraphlab_1_1dc__dist__object.html#a49f265ff4a28c800c43eb293bce0acad" title="The number of processes in the distributed program. ">numprocs()</a>, and stores the data to communicate in the <a class="el" href="classgraphlab_1_1dc__dist__object.html#ab35c107876915b9eef1266610b76f398" title="The current process ID. ">procid()</a>'th entry in the vector. Then calling gather with the vector and the target machine will send the contributed value to the target. When the function returns, machine sendto will have the complete vector where data[i] is the data contributed by machine i.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// construct the vector of values</span></div>
<div class="line">std::vector&lt;int&gt; <a class="code" href="namespacegraphlab.html#abb8f631ef7e698460f144b74ffd6d3ee">values</a>;</div>
<div class="line">values.resize(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1">numprocs</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// set my contributed value</span></div>
<div class="line">values[dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>()] = dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>();</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a235a274b33bb64ec76eeefba70ea54d0">gather</a>(values, 0);</div>
<div class="line"><span class="comment">// at this point machine 0 will have a vector with length equal to the</span></div>
<div class="line"><span class="comment">// number of processes, and containing values [0, 1, 2, ...]</span></div>
<div class="line"><span class="comment">// All other machines value vector will be unchanged.</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Behavior is undefined machines call gather with different values for sendto</dd>
<dd>
Behavior is undefined if multiple threads on the same machine call gather simultaneously</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A vector of length equal to the number of processes. The information to communicate is in the entry data[<a class="el" href="classgraphlab_1_1dc__dist__object.html#ab35c107876915b9eef1266610b76f398" title="The current process ID. ">procid()</a>] </td></tr>
    <tr><td class="paramname">sendto</td><td>Machine which will hold the complete vector at the end of the operation. All machines must have the same value for this parameter. </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in bytes_received() or <a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff" title="The number of bytes sent from this object, excluding headers and other control overhead. ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l00937">937</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa513af6755a38c5a15e159d3621db365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, size_t&gt; <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::gather_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gather RPC statistics. All machines must call this function at the same time. However, only proc 0 will return values </p>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l01546">1546</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a160e63e42fb6980db24b77dea84d0c34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::recv_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits to receives an object a source machine sent via <a class="el" href="classgraphlab_1_1dc__dist__object.html#ac7e791b279885109567e759c06182e80" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a> </p>
<p>This function waits to receives a <a class="el" href="serialization.html#sec_serializable">Serializable</a> object "t" from a source machine. The source machine must send the object using <a class="el" href="classgraphlab_1_1dc__dist__object.html#ac7e791b279885109567e759c06182e80" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a>. The source machine will wait for the target machine's <a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> to complete before returning.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) {</div>
<div class="line">  i = 10;</div>
<div class="line">  <span class="comment">// if I am machine 0, I send the value i = 10 to machine 1</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518">send_to</a>(1, i);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 1) {</div>
<div class="line">  <span class="comment">// machine 1 receives the value of i from machine 0</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f">recv_from</a>(0, i);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// at this point machines 0 and 1 have the value i = 10</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object to receive. This should be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The target machine to receive from. This function will block until data is received. </td></tr>
    <tr><td class="paramname">t</td><td>The object to receive. It must be serializable and the type must match the source machine's call to <a class="el" href="classgraphlab_1_1dc__dist__object.html#ac7e791b279885109567e759c06182e80" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a> </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in bytes_received() or <a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff" title="The number of bytes sent from this object, excluding headers and other control overhead. ">bytes_sent()</a>. This must match the "control" parameter on the source machine's <a class="el" href="classgraphlab_1_1dc__dist__object.html#ac7e791b279885109567e759c06182e80" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Behavior is undefined if multiple threads on the same machine call recv_from simultaneously </dd></dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l00825">825</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c423bdc58f79caf04da261b97454d01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::remote_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking RPC call to the target machine to run the provided function pointer. </p>
<p><a class="el" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">remote_call()</a> calls the function "fn" on a target remote machine. "fn" may be public, private or protected within the owner class; there are no access restrictions. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, the return value is lost.</p>
<p><a class="el" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">remote_call()</a> is non-blocking and does not wait for the target machine to complete execution of the function. Different remote_calls may be handled by different threads on the target machine and thus the target function should be made thread-safe. Alternatively, see <a class="el" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d" title="Sets the sequentialization key to a new value, returning the previous value. ">distributed_control::set_sequentialization_key()</a> to force sequentialization of groups of remote calls.</p>
<p>If blocking operation is desired, <a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a> may be used. Alternatively, a <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5478c426fd12ef635f67ec6b7faf2f21" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> may also be used to wait for completion of all incomplete RPC calls.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined in the distributed object</span></div>
<div class="line"><span class="keyword">class </span>distributed_obj_example {</div>
<div class="line"> <a class="code" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object&lt;distributed_obj_example&gt;</a> rmi;</div>
<div class="line">  ... initialization and constructor ...</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">   <span class="keywordtype">void</span> print(std::string s) {</div>
<div class="line">      std::cout &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">   }</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">void</span> print_on_machine_one(std::string s) {</div>
<div class="line">     <span class="comment">// calls the print function on machine 1 with the argument &quot;s&quot;</span></div>
<div class="line">     rmi.<a class="code" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01">remote_call</a>(1, &amp;distributed_obj_example::print, s);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the syntax for obtaining a pointer to a member function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine. Must be a pointer to member function in the owning object. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab685e7eaddcadcd50f4d2c93c3ab6660"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::remote_call </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>machine_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>machine_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking RPC call to a collection of machines to run the provided function pointer. </p>
<p>This function calls the provided function pointer on a collection of machines contained in the iterator range [begin, end). Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, the return value is lost.</p>
<p>This function is functionally equivalent to:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span>(machine_begin != machine_end) {</div>
<div class="line"> <a class="code" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01">remote_call</a>(*machine_begin, fn, ...);</div>
<div class="line"> ++machine_begin;</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, this function makes some optimizations to ensure all arguments are only serialized once instead of #calls times.</p>
<p>This function is non-blocking and does not wait for the target machines to complete execution of the function. Different remote_calls may be handled by different threads on the target machines and thus the target function should be made thread-safe. Alternatively, see <a class="el" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d" title="Sets the sequentialization key to a new value, returning the previous value. ">distributed_control::set_sequentialization_key()</a> to force sequentialization of groups of remote_calls. A <a class="el" href="classgraphlab_1_1dc__dist__object.html#a5478c426fd12ef635f67ec6b7faf2f21" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> may also be issued to wait for completion of all RPC calls issued prior to the full barrier.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined in the distributed object</span></div>
<div class="line"><span class="keyword">class </span>distributed_obj_example {</div>
<div class="line"> <a class="code" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object&lt;distributed_obj_example&gt;</a> rmi;</div>
<div class="line">  ... initialization and constructor ...</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">   <span class="keywordtype">void</span> print(std::string s) {</div>
<div class="line">      std::cout &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">   }</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">void</span> print_on_some_machines(std::string s) {</div>
<div class="line">     std::vector&lt;procid_t&gt; procs;</div>
<div class="line">     procs.push_back(1); procs.push_back(3); procs.push_back(5);</div>
<div class="line"></div>
<div class="line">     <span class="comment">// calls the print function on machine 1,3,5 with the argument &quot;s&quot;</span></div>
<div class="line">     rmi.<a class="code" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01">remote_call</a>(procs.begin(), procs.end(),</div>
<div class="line">                     &amp;distributed_obj_example::print, s);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">machine_begin</td><td>The beginning of an iterator range containing a list machines to call. Iterator::value_type must be castable to procid_t. </td></tr>
    <tr><td class="paramname">machine_end</td><td>The end of an iterator range containing a list machines to call. Iterator::value_type must be castable to procid_t. </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine. Must be a pointer to member function in the owning object. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23845fd5c66033a13a5c689a65583f1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RetVal <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::remote_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blocking RPC call to the target machine to run the provided function pointer. </p>
<p><a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a> calls the function "fn" on a target remote machine. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, it is sent back to calling machine.</p>
<p>Unlike <a class="el" href="classgraphlab_1_1dc__dist__object.html#a0c423bdc58f79caf04da261b97454d01" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">remote_call()</a>, <a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a> is blocking and waits for the target machine to complete execution of the function. However, different remote_requests may be still be handled by different threads on the target machine.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined in the distributed object</span></div>
<div class="line"><span class="keyword">class </span>distributed_obj_example {</div>
<div class="line"> <a class="code" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object&lt;distributed_obj_example&gt;</a> rmi;</div>
<div class="line">  ... initialization and constructor ...</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">   <span class="keywordtype">int</span> add_one(<span class="keywordtype">int</span> i) {</div>
<div class="line">     <span class="keywordflow">return</span> i + 1;</div>
<div class="line">   }</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">int</span> add_one_from_machine_1(<span class="keywordtype">int</span> i) {</div>
<div class="line">     <span class="comment">// calls the add_one function on machine 1 with the argument i</span></div>
<div class="line">     <span class="keywordflow">return</span> rmi.<a class="code" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b">remote_request</a>(1, &amp;distributed_obj_example::add_one, i);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::object_fiber_remote_request</a> <a class="el" href="classgraphlab_1_1dc__dist__object.html#a058fafc0d3650176df4457eb6f93968f" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::dc_dist_object::future_remote_request</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine. Must be a pointer to member function in the owning object. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same return type as the function fn </dd></dl>

</div>
</div>
<a class="anchor" id="ac7e791b279885109567e759c06182e80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object</a>&lt; T &gt;::send_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends an object to a target machine and blocks until the target machine calls <a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> to receive the object. </p>
<p>This function sends a <a class="el" href="serialization.html#sec_serializable">Serializable</a> object "t" to the target machine, but waits for the target machine to call <a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> before returning to receive the object before returning.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) {</div>
<div class="line">  i = 10;</div>
<div class="line">  <span class="comment">// if I am machine 0, I send the value i = 10 to machine 1</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518">send_to</a>(1, i);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 1) {</div>
<div class="line">  <span class="comment">// machine 1 receives the value of i from machine 0</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f">recv_from</a>(0, i);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// at this point machines 0 and 1 have the value i = 10</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object to send. This should be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target machine to send to. Target machine must call <a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> before this call will return. </td></tr>
    <tr><td class="paramname">t</td><td>The object to send. It must be serializable. The type must match the target machine's call to <a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in bytes_received() or <a class="el" href="classgraphlab_1_1dc__dist__object.html#af46ae9f396bc228f0822a36c59b061ff" title="The number of bytes sent from this object, excluding headers and other control overhead. ">bytes_sent()</a>. This must match the "control" parameter on the target machine's <a class="el" href="classgraphlab_1_1dc__dist__object.html#a160e63e42fb6980db24b77dea84d0c34" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Behavior is undefined if multiple threads on the same machine call send_to simultaneously </dd></dl>

<p>Definition at line <a class="el" href="dc__dist__object_8hpp_source.html#l00796">796</a> of file <a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/rpc/<a class="el" href="dc__dist__object_8hpp_source.html">dc_dist_object.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1dc__dist__object.html">dc_dist_object</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:27 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
