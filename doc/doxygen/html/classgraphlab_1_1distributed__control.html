<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::distributed_control Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1distributed__control.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classgraphlab_1_1distributed__control-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::distributed_control Class Reference<div class="ingroups"><a class="el" href="group__rpc.html">GraphLab RPC</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The distributed control object is primary means of communication between the distributed GraphLab processes.  
 <a href="classgraphlab_1_1distributed__control.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dc_8hpp_source.html">graphlab/rpc/dc.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac73cca4f6a22869400ebab29c50536bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#ac73cca4f6a22869400ebab29c50536bf">distributed_control</a> ()</td></tr>
<tr class="separator:ac73cca4f6a22869400ebab29c50536bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3068063a01d89ac4f08caf5b43c136"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aaf3068063a01d89ac4f08caf5b43c136">distributed_control</a> (<a class="el" href="structgraphlab_1_1dc__init__param.html">dc_init_param</a> initparam)</td></tr>
<tr class="separator:aaf3068063a01d89ac4f08caf5b43c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74718211dffa701bb2ad9edc8467edf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74718211dffa701bb2ad9edc8467edf5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_handler_threads</b> () const </td></tr>
<tr class="separator:a74718211dffa701bb2ad9edc8467edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adaa364edf63ff764aa2aabbe777f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3adaa364edf63ff764aa2aabbe777f65"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a> () const </td></tr>
<tr class="memdesc:a3adaa364edf63ff764aa2aabbe777f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the id of the current process <br /></td></tr>
<tr class="separator:a3adaa364edf63ff764aa2aabbe777f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688dac1ed2de771d65f93d7aae739fd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a688dac1ed2de771d65f93d7aae739fd1"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1">numprocs</a> () const </td></tr>
<tr class="memdesc:a688dac1ed2de771d65f93d7aae739fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of processes in total. <br /></td></tr>
<tr class="separator:a688dac1ed2de771d65f93d7aae739fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f2c437c88d5af8c897b53fc20f53b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a139f2c437c88d5af8c897b53fc20f53b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a139f2c437c88d5af8c897b53fc20f53b">set_fast_track_requests</a> (bool val)</td></tr>
<tr class="memdesc:a139f2c437c88d5af8c897b53fc20f53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fast track status, returning the previous value. <br /></td></tr>
<tr class="separator:a139f2c437c88d5af8c897b53fc20f53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fda9926c40ab12d29687512c79f337"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fda9926c40ab12d29687512c79f337"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a40fda9926c40ab12d29687512c79f337">fast_track_requests</a> ()</td></tr>
<tr class="memdesc:a40fda9926c40ab12d29687512c79f337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we should fast track all request messages. <br /></td></tr>
<tr class="separator:a40fda9926c40ab12d29687512c79f337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16858c9274a54330867809503e58c8f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a16858c9274a54330867809503e58c8f4">register_deletion_callback</a> (boost::function&lt; void(void)&gt; deleter)</td></tr>
<tr class="memdesc:a16858c9274a54330867809503e58c8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback which will be called on deletion of the <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> object.  <a href="#a16858c9274a54330867809503e58c8f4">More...</a><br /></td></tr>
<tr class="separator:a16858c9274a54330867809503e58c8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0387b77bb3b5505d55fbebedd499b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aa0387b77bb3b5505d55fbebedd499b77">remote_call</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:aa0387b77bb3b5505d55fbebedd499b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking RPC call to the target machine to run the provided function pointer.  <a href="#aa0387b77bb3b5505d55fbebedd499b77">More...</a><br /></td></tr>
<tr class="separator:aa0387b77bb3b5505d55fbebedd499b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d50397ae6ba1f72343a7f06af46406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#af8d50397ae6ba1f72343a7f06af46406">remote_call</a> (Iterator machine_begin, Iterator machine_end, Fn fn,...)</td></tr>
<tr class="memdesc:af8d50397ae6ba1f72343a7f06af46406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking RPC call to a collection of machines to run the provided function pointer.  <a href="#af8d50397ae6ba1f72343a7f06af46406">More...</a><br /></td></tr>
<tr class="separator:af8d50397ae6ba1f72343a7f06af46406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15abdebdf3d6ef44994661e562990380"><td class="memItemLeft" align="right" valign="top">RetVal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380">remote_request</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:a15abdebdf3d6ef44994661e562990380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking RPC call to the target machine to run the provided function pointer.  <a href="#a15abdebdf3d6ef44994661e562990380">More...</a><br /></td></tr>
<tr class="separator:a15abdebdf3d6ef44994661e562990380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bff779bee123f4e4506beaa72497e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt; RetVal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a6bff779bee123f4e4506beaa72497e9f">future_remote_request</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:a6bff779bee123f4e4506beaa72497e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a non-blocking RPC call to the target machine to run the provided function pointer.  <a href="#a6bff779bee123f4e4506beaa72497e9f">More...</a><br /></td></tr>
<tr class="separator:a6bff779bee123f4e4506beaa72497e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2014b0bab047c96ae91808191335588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2014b0bab047c96ae91808191335588"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aa2014b0bab047c96ae91808191335588">calls_sent</a> () const </td></tr>
<tr class="memdesc:aa2014b0bab047c96ae91808191335588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of RPC calls made. <br /></td></tr>
<tr class="separator:aa2014b0bab047c96ae91808191335588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca691baeb1c7686f7c8de7416d0c7db4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca691baeb1c7686f7c8de7416d0c7db4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aca691baeb1c7686f7c8de7416d0c7db4">mega_calls_sent</a> () const </td></tr>
<tr class="memdesc:aca691baeb1c7686f7c8de7416d0c7db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of RPC calls made in millions. <br /></td></tr>
<tr class="separator:aca691baeb1c7686f7c8de7416d0c7db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07eefd8d56a7161f5d71e3c6816dd98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa07eefd8d56a7161f5d71e3c6816dd98"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aa07eefd8d56a7161f5d71e3c6816dd98">calls_received</a> () const </td></tr>
<tr class="memdesc:aa07eefd8d56a7161f5d71e3c6816dd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of RPC calls received. <br /></td></tr>
<tr class="separator:aa07eefd8d56a7161f5d71e3c6816dd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e194e4986e7bb0e2130f560cae8bb44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e194e4986e7bb0e2130f560cae8bb44"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44">bytes_sent</a> () const </td></tr>
<tr class="memdesc:a4e194e4986e7bb0e2130f560cae8bb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of bytes sent excluding headers and other control overhead. Also see <a class="el" href="classgraphlab_1_1distributed__control.html#a0835562c7010d35001f954be0246e081" title="Returns the total number of bytes sent including all headers and other control overhead. Also see bytes_sent() ">network_bytes_sent()</a> <br /></td></tr>
<tr class="separator:a4e194e4986e7bb0e2130f560cae8bb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0835562c7010d35001f954be0246e081"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0835562c7010d35001f954be0246e081"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a0835562c7010d35001f954be0246e081">network_bytes_sent</a> () const </td></tr>
<tr class="memdesc:a0835562c7010d35001f954be0246e081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of bytes sent including all headers and other control overhead. Also see <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a> <br /></td></tr>
<tr class="separator:a0835562c7010d35001f954be0246e081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64ab2aed7bd6510c0849144fbf145ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab64ab2aed7bd6510c0849144fbf145ff"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#ab64ab2aed7bd6510c0849144fbf145ff">network_megabytes_sent</a> () const </td></tr>
<tr class="memdesc:ab64ab2aed7bd6510c0849144fbf145ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of megabytes sent including all headers and other control overhead. Also see <a class="el" href="classgraphlab_1_1distributed__control.html#a0835562c7010d35001f954be0246e081" title="Returns the total number of bytes sent including all headers and other control overhead. Also see bytes_sent() ">network_bytes_sent()</a> <br /></td></tr>
<tr class="separator:ab64ab2aed7bd6510c0849144fbf145ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9be35a916f2a021b30eb82ade3bd5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada9be35a916f2a021b30eb82ade3bd5c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c">bytes_received</a> () const </td></tr>
<tr class="memdesc:ada9be35a916f2a021b30eb82ade3bd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of bytes received excluding all headers and other control overhead. Also see <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. <br /></td></tr>
<tr class="separator:ada9be35a916f2a021b30eb82ade3bd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8e0c9064213b2737bcd7cc9b686e81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8e0c9064213b2737bcd7cc9b686e81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#afa8e0c9064213b2737bcd7cc9b686e81">flush</a> ()</td></tr>
<tr class="memdesc:afa8e0c9064213b2737bcd7cc9b686e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a local flush of all send buffers. <br /></td></tr>
<tr class="separator:afa8e0c9064213b2737bcd7cc9b686e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb9bbdf2a3126c8c2c7d0caca4f0fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cb9bbdf2a3126c8c2c7d0caca4f0fe8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a9cb9bbdf2a3126c8c2c7d0caca4f0fe8">flush</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> p)</td></tr>
<tr class="memdesc:a9cb9bbdf2a3126c8c2c7d0caca4f0fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a local flush of all send buffers. <br /></td></tr>
<tr class="separator:a9cb9bbdf2a3126c8c2c7d0caca4f0fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8430b77a4e7a6052bf2f821a72e595d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8430b77a4e7a6052bf2f821a72e595d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a8430b77a4e7a6052bf2f821a72e595d8">flush_soon</a> ()</td></tr>
<tr class="memdesc:a8430b77a4e7a6052bf2f821a72e595d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a flush of all send buffers to happen soon;. <br /></td></tr>
<tr class="separator:a8430b77a4e7a6052bf2f821a72e595d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1001b05cd3a3ae5d65bc01a166d1e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab1001b05cd3a3ae5d65bc01a166d1e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aab1001b05cd3a3ae5d65bc01a166d1e6">flush_soon</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> p)</td></tr>
<tr class="memdesc:aab1001b05cd3a3ae5d65bc01a166d1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a flush of one send buffers to happen soon;. <br /></td></tr>
<tr class="separator:aab1001b05cd3a3ae5d65bc01a166d1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa007adc8635b1f01567fea5eef072cdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa007adc8635b1f01567fea5eef072cdb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aa007adc8635b1f01567fea5eef072cdb">write_to_buffer</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> target, char *c, size_t len)</td></tr>
<tr class="memdesc:aa007adc8635b1f01567fea5eef072cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string to the send buffer and flushes. <br /></td></tr>
<tr class="separator:aa007adc8635b1f01567fea5eef072cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b095ec7d236c456d66ee3a6cf6b518"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a24b095ec7d236c456d66ee3a6cf6b518"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518">send_to</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> target, U &amp;t, bool control=false)</td></tr>
<tr class="memdesc:a24b095ec7d236c456d66ee3a6cf6b518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an object to a target machine and blocks until the target machine calls <a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> to receive the object.  <a href="#a24b095ec7d236c456d66ee3a6cf6b518">More...</a><br /></td></tr>
<tr class="separator:a24b095ec7d236c456d66ee3a6cf6b518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfab1a497d430d7ca675e75737ab2e1f"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acfab1a497d430d7ca675e75737ab2e1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f">recv_from</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> source, U &amp;t, bool control=false)</td></tr>
<tr class="memdesc:acfab1a497d430d7ca675e75737ab2e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits to receives an object a source machine sent via <a class="el" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a>  <a href="#acfab1a497d430d7ca675e75737ab2e1f">More...</a><br /></td></tr>
<tr class="separator:acfab1a497d430d7ca675e75737ab2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9414f3bf9679b88b9e0074bdfc171653"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9414f3bf9679b88b9e0074bdfc171653"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a9414f3bf9679b88b9e0074bdfc171653">broadcast</a> (U &amp;data, bool originator, bool control=false)</td></tr>
<tr class="memdesc:a9414f3bf9679b88b9e0074bdfc171653"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows one machine to broadcasts an object to all machines.  <a href="#a9414f3bf9679b88b9e0074bdfc171653">More...</a><br /></td></tr>
<tr class="separator:a9414f3bf9679b88b9e0074bdfc171653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235a274b33bb64ec76eeefba70ea54d0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a235a274b33bb64ec76eeefba70ea54d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a235a274b33bb64ec76eeefba70ea54d0">gather</a> (std::vector&lt; U &gt; &amp;data, <a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> sendto, bool control=false)</td></tr>
<tr class="memdesc:a235a274b33bb64ec76eeefba70ea54d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects information contributed by each machine onto one machine.  <a href="#a235a274b33bb64ec76eeefba70ea54d0">More...</a><br /></td></tr>
<tr class="separator:a235a274b33bb64ec76eeefba70ea54d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bf32af89963f79f197b40a4abc24ff"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a53bf32af89963f79f197b40a4abc24ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a53bf32af89963f79f197b40a4abc24ff">all_gather</a> (std::vector&lt; U &gt; &amp;data, bool control=false)</td></tr>
<tr class="memdesc:a53bf32af89963f79f197b40a4abc24ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends some information contributed by each machine to all machines.  <a href="#a53bf32af89963f79f197b40a4abc24ff">More...</a><br /></td></tr>
<tr class="separator:a53bf32af89963f79f197b40a4abc24ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f19ef318f7f78ebf4496fbb6cb2180"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a86f19ef318f7f78ebf4496fbb6cb2180"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180">all_reduce</a> (U &amp;data, bool control=false)</td></tr>
<tr class="memdesc:a86f19ef318f7f78ebf4496fbb6cb2180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a value contributed by each machine, making the result available to all machines.  <a href="#a86f19ef318f7f78ebf4496fbb6cb2180">More...</a><br /></td></tr>
<tr class="separator:a86f19ef318f7f78ebf4496fbb6cb2180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353f74d3aece1a8eafb1a436f3501fc7"><td class="memTemplParams" colspan="2">template&lt;typename U , typename PlusEqual &gt; </td></tr>
<tr class="memitem:a353f74d3aece1a8eafb1a436f3501fc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a353f74d3aece1a8eafb1a436f3501fc7">all_reduce2</a> (U &amp;data, PlusEqual plusequal, bool control=false)</td></tr>
<tr class="memdesc:a353f74d3aece1a8eafb1a436f3501fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a value contributed by each machine, making the result available to all machines.  <a href="#a353f74d3aece1a8eafb1a436f3501fc7">More...</a><br /></td></tr>
<tr class="separator:a353f74d3aece1a8eafb1a436f3501fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f0ebebb86a593fa56bf2c567f8c466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a32f0ebebb86a593fa56bf2c567f8c466">barrier</a> ()</td></tr>
<tr class="memdesc:a32f0ebebb86a593fa56bf2c567f8c466"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1distributed__control.html#a32f0ebebb86a593fa56bf2c567f8c466" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a> function before proceeding.  <a href="#a32f0ebebb86a593fa56bf2c567f8c466">More...</a><br /></td></tr>
<tr class="separator:a32f0ebebb86a593fa56bf2c567f8c466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7148dfdffd2e4b0fee75e528939bb982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982">full_barrier</a> ()</td></tr>
<tr class="memdesc:a7148dfdffd2e4b0fee75e528939bb982"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> function before proceeding. Also waits for all previously issued remote calls to complete.  <a href="#a7148dfdffd2e4b0fee75e528939bb982">More...</a><br /></td></tr>
<tr class="separator:a7148dfdffd2e4b0fee75e528939bb982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9008b5428a716346a093c331f6bc47a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9008b5428a716346a093c331f6bc47a4"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a9008b5428a716346a093c331f6bc47a4">cout</a> () const </td></tr>
<tr class="memdesc:a9008b5428a716346a093c331f6bc47a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper on cout, that outputs only on machine 0. <br /></td></tr>
<tr class="separator:a9008b5428a716346a093c331f6bc47a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf0b3082a264e8084260bf0787fcbd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaf0b3082a264e8084260bf0787fcbd6"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aeaf0b3082a264e8084260bf0787fcbd6">cerr</a> () const </td></tr>
<tr class="memdesc:aeaf0b3082a264e8084260bf0787fcbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper on cerr, that outputs only on machine 0. <br /></td></tr>
<tr class="separator:aeaf0b3082a264e8084260bf0787fcbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3a6956c22768cdde038a16269c19d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a5bd3a6956c22768cdde038a16269c19d">gather_statistics</a> ()</td></tr>
<tr class="separator:a5bd3a6956c22768cdde038a16269c19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aed23a153dca9843584b1708c56c13efb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#aed23a153dca9843584b1708c56c13efb">get_instance_procid</a> ()</td></tr>
<tr class="separator:aed23a153dca9843584b1708c56c13efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a43c8d6bfa3235d6132d4c9814c6e7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a8a43c8d6bfa3235d6132d4c9814c6e7f">get_instance</a> ()</td></tr>
<tr class="separator:a8a43c8d6bfa3235d6132d4c9814c6e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9946232b4ad672db290614d0b924881d"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d">set_sequentialization_key</a> (unsigned char newkey)</td></tr>
<tr class="memdesc:a9946232b4ad672db290614d0b924881d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the sequentialization key to a new value, returning the previous value.  <a href="#a9946232b4ad672db290614d0b924881d">More...</a><br /></td></tr>
<tr class="separator:a9946232b4ad672db290614d0b924881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1353d43494995e3ce7b8573eec3cf5bb"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a1353d43494995e3ce7b8573eec3cf5bb">new_sequentialization_key</a> ()</td></tr>
<tr class="memdesc:a1353d43494995e3ce7b8573eec3cf5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new sequentialization key, returning the old value.  <a href="#a1353d43494995e3ce7b8573eec3cf5bb">More...</a><br /></td></tr>
<tr class="separator:a1353d43494995e3ce7b8573eec3cf5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148f18ddb2faec68398f459ed0f4f002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a148f18ddb2faec68398f459ed0f4f002"></a>
static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html#a148f18ddb2faec68398f459ed0f4f002">get_sequentialization_key</a> ()</td></tr>
<tr class="memdesc:a148f18ddb2faec68398f459ed0f4f002"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the current sequentialization key. This function is not generally useful. <br /></td></tr>
<tr class="separator:a148f18ddb2faec68398f459ed0f4f002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aab3c1b2f539322cf9806880485a85697"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab3c1b2f539322cf9806880485a85697"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_fast_track_requests</b></td></tr>
<tr class="separator:aab3c1b2f539322cf9806880485a85697"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa9aaeb7fcecec7a0e68db84e4d0ee1aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9aaeb7fcecec7a0e68db84e4d0ee1aa"></a>
static <a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>last_dc_procid</b> = 0</td></tr>
<tr class="separator:aa9aaeb7fcecec7a0e68db84e4d0ee1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359bc5f3a9d8c18dc96d0149a9a5e874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a359bc5f3a9d8c18dc96d0149a9a5e874"></a>
static <a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>last_dc</b> = NULL</td></tr>
<tr class="separator:a359bc5f3a9d8c18dc96d0149a9a5e874"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The distributed control object is primary means of communication between the distributed GraphLab processes. </p>
<p>The <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> object provides asynchronous, multi-threaded Remote Procedure Call (RPC) services to allow distributed GraphLab processes to communicate with each other. Currently, the only communication method implemented is TCP/IP. There are several ways of setting up the communication layer, but the most reliable, and the preferred method, is to "bootstrap" using MPI. See your local MPI documentation for details on how to launch MPI jobs.</p>
<p>To construct a <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> object, the simplest method is to just invoke the default constructor.</p>
<div class="fragment"><div class="line"><span class="comment">// initialize MPI</span></div>
<div class="line">mpi_tools::init(argc, argv);</div>
<div class="line"><span class="comment">// construct distributed control object</span></div>
<div class="line"><a class="code" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> dc;</div>
</div><!-- fragment --><p>After which all distributed control services will operate correctly.</p>
<p>Each process is assigned a sequential process ID at starting at 0. i.e. The first process will have a process ID of 0, the second process will have an ID of 1, etc. <a class="el" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65" title="returns the id of the current process ">distributed_control::procid()</a> can be used to obtain the current machine's process ID, and <a class="el" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1" title="returns the number of processes in total. ">distributed_control::numprocs()</a> can be used to obtain the total number of processes.</p>
<p>The primary functions used to communicate between processes are <a class="el" href="classgraphlab_1_1distributed__control.html#aa0387b77bb3b5505d55fbebedd499b77" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">distributed_control::remote_call()</a> and <a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">distributed_control::remote_request()</a>. These functions are thread-safe and can be called very rapidly as they only write into a local buffer. Communication is handled by a background thread. On the remote side, RPC calls are handled in parallel by a thread pool, and thus may be parallelized arbitrarily. Operations such as <a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">distributed_control::full_barrier()</a>, or the sequentialization key can be used to get finer grained control over order of execution on the remote machine.</p>
<p>A few other additional helper functions are also provided to support "synchronous" modes of communication. These functions are not thread-safe and can only be called on one thread per machine. These functions block until all machines call the same function. For instance, if <a class="el" href="classgraphlab_1_1distributed__control.html#a235a274b33bb64ec76eeefba70ea54d0" title="Collects information contributed by each machine onto one machine. ">gather()</a> is called on one machine, it will not return until all machines call <a class="el" href="classgraphlab_1_1distributed__control.html#a235a274b33bb64ec76eeefba70ea54d0" title="Collects information contributed by each machine onto one machine. ">gather()</a>.</p>
<ul>
<li><a class="el" href="classgraphlab_1_1distributed__control.html#a32f0ebebb86a593fa56bf2c567f8c466" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">distributed_control::barrier()</a> </li>
<li><a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">distributed_control::full_barrier()</a> </li>
<li><a class="el" href="classgraphlab_1_1distributed__control.html#a9414f3bf9679b88b9e0074bdfc171653" title="This function allows one machine to broadcasts an object to all machines. ">distributed_control::broadcast()</a> </li>
<li><a class="el" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180" title="Combines a value contributed by each machine, making the result available to all machines. ">distributed_control::all_reduce()</a> </li>
<li><a class="el" href="classgraphlab_1_1distributed__control.html#a353f74d3aece1a8eafb1a436f3501fc7" title="Combines a value contributed by each machine, making the result available to all machines. ">distributed_control::all_reduce2()</a> </li>
<li><a class="el" href="classgraphlab_1_1distributed__control.html#a235a274b33bb64ec76eeefba70ea54d0" title="Collects information contributed by each machine onto one machine. ">distributed_control::gather()</a> </li>
<li><a class="el" href="classgraphlab_1_1distributed__control.html#a53bf32af89963f79f197b40a4abc24ff" title="Sends some information contributed by each machine to all machines. ">distributed_control::all_gather()</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>These synchronous operations are modeled after some MPI collective operations. However, these operations here are not particularly optimized and will generally be slower than their MPI counterparts. However, the implementations here are much easier to use, relying extensively on serialization to simplify communication.</dd></dl>
<p>To support Object Oriented Programming like methodologies, we allow the creation of <b>Distributed Objects</b> through <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">graphlab::dc_dist_object</a>. <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">dc_dist_object</a> allows a class to construct its own local copy of a <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> object allowing instances of the class to communicate with each other across the network.</p>
<p>See <a class="el" href="RPC.html">GraphLab RPC</a> for usage examples. </p>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l00200">200</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac73cca4f6a22869400ebab29c50536bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">graphlab::distributed_control::distributed_control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Automatically tries to read the initialization from environment variables, or from MPI (if MPI is initialized). </p>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00117">117</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf3068063a01d89ac4f08caf5b43c136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">graphlab::distributed_control::distributed_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraphlab_1_1dc__init__param.html">dc_init_param</a>&#160;</td>
          <td class="paramname"><em>initparam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Passes custom constructed initialization parameters in <a class="el" href="structgraphlab_1_1dc__init__param.html">dc_init_param</a></p>
<p>Though <a class="el" href="structgraphlab_1_1dc__init__param.html" title="Distributed control constructor parameters. ">dc_init_param</a> can be obtained from environment variables using dc_init_from_env() or from MPI using dc_init_from_mpi(), using the default constructor is prefered. </p>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00149">149</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a53bf32af89963f79f197b40a4abc24ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::all_gather </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends some information contributed by each machine to all machines. </p>
<p>The goal is to have each machine broadcast a piece of information to all machines. This is like <a class="el" href="classgraphlab_1_1distributed__control.html#a235a274b33bb64ec76eeefba70ea54d0" title="Collects information contributed by each machine onto one machine. ">gather()</a>, but all machines have the complete vector at the end. To accomplish this, each machine constructs a vector of length <a class="el" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1" title="returns the number of processes in total. ">numprocs()</a>, and stores the data to communicate in the <a class="el" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65" title="returns the id of the current process ">procid()</a>'th entry in the vector. Then calling all_gather with the vector will result in all machines having a complete copy of the vector containing all contributions (entry 0 from machine 0, entry 1 from machine 1, etc).</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// construct the vector of values</span></div>
<div class="line">std::vector&lt;int&gt; <a class="code" href="namespacegraphlab.html#abb8f631ef7e698460f144b74ffd6d3ee">values</a>;</div>
<div class="line">values.resize(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1">numprocs</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// set my contributed value</span></div>
<div class="line">values[dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>()] = dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>();</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a53bf32af89963f79f197b40a4abc24ff">all_gather</a>(values);</div>
<div class="line"><span class="comment">// at this point all machine will have a vector with length equal to the</span></div>
<div class="line"><span class="comment">// number of processes, and containing values [0, 1, 2, ...]</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Behavior is undefined if multiple threads on the same machine call all_gather simultaneously</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A vector of length equal to the number of processes. The information to communicate is in the entry data[<a class="el" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65" title="returns the id of the current process ">procid()</a>] </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in <a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c" title="Returns the total number of bytes received excluding all headers and other control overhead...">bytes_received()</a> or <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l01436">1436</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86f19ef318f7f78ebf4496fbb6cb2180"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::all_reduce </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines a value contributed by each machine, making the result available to all machines. </p>
<p>Each machine calls <a class="el" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a> with a object which is serializable and has operator+= implemented. When <a class="el" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a> returns, the "data" variable will contain a value corresponding to adding up the objects contributed by each machine.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 1;</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180">all_reduce</a>(i);</div>
<div class="line"><span class="comment">// since each machine contributed the value &quot;1&quot;,</span></div>
<div class="line"><span class="comment">// all machines will have i = numprocs() here.</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A piece of data to perform a reduction over. The type must implement operator+=. </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in <a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c" title="Returns the total number of bytes received excluding all headers and other control overhead...">bytes_received()</a> or <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l01441">1441</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a353f74d3aece1a8eafb1a436f3501fc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename PlusEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::all_reduce2 </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlusEqual&#160;</td>
          <td class="paramname"><em>plusequal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines a value contributed by each machine, making the result available to all machines. </p>
<p>This function is equivalent to <a class="el" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a>, but with an externally defined PlusEqual function.</p>
<p>Each machine calls <a class="el" href="classgraphlab_1_1distributed__control.html#a86f19ef318f7f78ebf4496fbb6cb2180" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce()</a> with a object which is serializable and a function "plusequal" which combines two instances of the object. When <a class="el" href="classgraphlab_1_1distributed__control.html#a353f74d3aece1a8eafb1a436f3501fc7" title="Combines a value contributed by each machine, making the result available to all machines. ">all_reduce2()</a> returns, the "data" variable will contain a value corresponding to adding up the objects contributed by each machine using the plusequal function.</p>
<p>Where U is the type of the object, the plusequal function must be of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> plusequal(U&amp; left, <span class="keyword">const</span> U&amp; right);</div>
</div><!-- fragment --><p> and must implement the equivalent of <code>left += right; </code></p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> int_plus_equal(<span class="keywordtype">int</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; b) {</div>
<div class="line"> a+=b;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> i = 1;</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a353f74d3aece1a8eafb1a436f3501fc7">all_reduce2</a>(i, int_plus_equal);</div>
<div class="line"><span class="comment">// since each machine contributed the value &quot;1&quot;,</span></div>
<div class="line"><span class="comment">// all machines will have i = numprocs() here.</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A piece of data to perform a reduction over. </td></tr>
    <tr><td class="paramname">plusequal</td><td>A plusequal function on the data. Must have the prototype void plusequal(U&amp;, const U&amp;) </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in <a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c" title="Returns the total number of bytes received excluding all headers and other control overhead...">bytes_received()</a> or <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l01447">1447</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32f0ebebb86a593fa56bf2c567f8c466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1distributed__control.html#a32f0ebebb86a593fa56bf2c567f8c466" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a> function before proceeding. </p>
<p>A machine calling the <a class="el" href="classgraphlab_1_1distributed__control.html#a32f0ebebb86a593fa56bf2c567f8c466" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a> will wait until every machine reaches this barrier before continuing. Only one thread from each machine should call the barrier.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier</a> </dd></dl>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00622">622</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9414f3bf9679b88b9e0074bdfc171653"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::broadcast </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>originator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function allows one machine to broadcasts an object to all machines. </p>
<p>The originator calls broadcast with data provided in in 'data' and originator set to true. All other callers call with originator set to false.</p>
<p>The originator will then return 'data'. All other machines will receive the originator's transmission in the "data" parameter.</p>
<p>This call is guaranteed to have barrier-like behavior. That is to say, this call will block until all machines enter the broadcast function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) {</div>
<div class="line">  <span class="comment">// if I am machine 0, I broadcast the value i = 10 to all machines</span></div>
<div class="line">  i = 10;</div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a9414f3bf9679b88b9e0074bdfc171653">broadcast</a>(i, <span class="keyword">true</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// all other machines receive the broadcast value</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a9414f3bf9679b88b9e0074bdfc171653">broadcast</a>(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// at this point, all machines have i = 10</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Behavior is undefined if more than one machine calls broadcast with originator set to true.</dd>
<dd>
Behavior is undefined if multiple threads on the same machine call broadcast simultaneously</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>If this is the originator, this will contain the object to broadcast. Otherwise, this will be a reference to the object receiving the broadcast. </td></tr>
    <tr><td class="paramname">originator</td><td>Set to true if this is the source of the broadcast. Set to false otherwise. </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in <a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c" title="Returns the total number of bytes received excluding all headers and other control overhead...">bytes_received()</a> or <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l01426">1426</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7148dfdffd2e4b0fee75e528939bb982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::full_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A distributed barrier which waits for all machines to call the <a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> function before proceeding. Also waits for all previously issued remote calls to complete. </p>
<p>Similar to the <a class="el" href="classgraphlab_1_1distributed__control.html#a32f0ebebb86a593fa56bf2c567f8c466" title="A distributed barrier which waits for all machines to call the barrier() function before proceeding...">barrier()</a>, but provides additional guarantees that all calls issued prior to this barrier are completed before i returning.</p>
<dl class="section note"><dt>Note</dt><dd>This function could return prematurely if other threads are still issuing function calls since we cannot differentiate between calls issued before the barrier and calls issued while the barrier is being evaluated. Therefore, when used in a multithreaded scenario, the user must ensure that all other threads which may perform operations using this object are stopped before the full barrier is initated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbarrier.html">barrier</a></dd></dl>
<p>This barrier ensures globally across all machines that all calls issued prior to this barrier are completed before returning. This function could return prematurely if other threads are still issuing function calls since we cannot differentiate between calls issued before the barrier and calls issued while the barrier is being evaluated. </p>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00670">670</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6bff779bee123f4e4506beaa72497e9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt;RetVal&gt; graphlab::distributed_control::future_remote_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking RPC call to the target machine to run the provided function pointer. </p>
<p><a class="el" href="classgraphlab_1_1distributed__control.html#a6bff779bee123f4e4506beaa72497e9f" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">future_remote_request()</a> calls the function "fn" on a target remote machine. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, it is sent back to calling machine.</p>
<p><a class="el" href="classgraphlab_1_1distributed__control.html#a6bff779bee123f4e4506beaa72497e9f" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">future_remote_request()</a> is like <a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a>, but is non-blocking. Instead, it returns immediately a <a class="el" href="structgraphlab_1_1request__future.html">graphlab::request_future</a> object which will allow you wait for the return value.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined</span></div>
<div class="line"><span class="keywordtype">int</span> add_one(<span class="keywordtype">int</span> i) {</div>
<div class="line">  <span class="keywordflow">return</span> i + 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">... ...</div>
<div class="line"><span class="comment">// call the add_one function on machine 1</span></div>
<div class="line">int i = 10;</div>
<div class="line"><a class="code" href="structgraphlab_1_1request__future.html">graphlab::request_future&lt;int&gt;</a> ret = dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380">remote_request</a>(1, add_one, i);</div>
<div class="line"><span class="keywordtype">int</span> result = ret();</div>
<div class="line"><span class="comment">// result will be 11</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::fiber_remote_request</a> <a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">graphlab::distributed_control::remote_request</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same return type as the function fn </dd></dl>

</div>
</div>
<a class="anchor" id="a235a274b33bb64ec76eeefba70ea54d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::gather </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>sendto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects information contributed by each machine onto one machine. </p>
<p>The goal is to collect some information from each machine onto a single target machine (sendto). To accomplish this, each machine constructs a vector of length <a class="el" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1" title="returns the number of processes in total. ">numprocs()</a>, and stores the data to communicate in the <a class="el" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65" title="returns the id of the current process ">procid()</a>'th entry in the vector. Then calling gather with the vector and the target machine will send the contributed value to the target. When the function returns, machine sendto will have the complete vector where data[i] is the data contributed by machine i.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// construct the vector of values</span></div>
<div class="line">std::vector&lt;int&gt; <a class="code" href="namespacegraphlab.html#abb8f631ef7e698460f144b74ffd6d3ee">values</a>;</div>
<div class="line">values.resize(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a688dac1ed2de771d65f93d7aae739fd1">numprocs</a>());</div>
<div class="line"></div>
<div class="line"><span class="comment">// set my contributed value</span></div>
<div class="line">values[dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>()] = dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>();</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a235a274b33bb64ec76eeefba70ea54d0">gather</a>(values, 0);</div>
<div class="line"><span class="comment">// at this point machine 0 will have a vector with length equal to the</span></div>
<div class="line"><span class="comment">// number of processes, and containing values [0, 1, 2, ...]</span></div>
<div class="line"><span class="comment">// All other machines value vector will be unchanged.</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Behavior is undefined machines call gather with different values for sendto</dd>
<dd>
Behavior is undefined if multiple threads on the same machine call gather simultaneously</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A vector of length equal to the number of processes. The information to communicate is in the entry data[<a class="el" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65" title="returns the id of the current process ">procid()</a>] </td></tr>
    <tr><td class="paramname">sendto</td><td>Machine which will hold the complete vector at the end of the operation. All machines must have the same value for this parameter. </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in <a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c" title="Returns the total number of bytes received excluding all headers and other control overhead...">bytes_received()</a> or <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. This must be the same on all machines. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l01431">1431</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bd3a6956c22768cdde038a16269c19d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, size_t&gt; graphlab::distributed_control::gather_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gather RPC statistics. All machines must call this function at the same time. However, only proc 0 will return values </p>

</div>
</div>
<a class="anchor" id="a8a43c8d6bfa3235d6132d4c9814c6e7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> * graphlab::distributed_control::get_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a pointer to the last <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> instance created. If there is no <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> instance, this returns NULL. </p>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00087">87</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed23a153dca9843584b1708c56c13efb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> graphlab::distributed_control::get_instance_procid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the procid of the last <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> instance created. If there is no <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> instance, this returns 0. For instance, this returns the current machine's procid if there is only one <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a>. </p>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00083">83</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1353d43494995e3ce7b8573eec3cf5bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char graphlab::distributed_control::new_sequentialization_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new sequentialization key, returning the old value. </p>
<p>All RPC calls made using the same key value (as long as the key is non-zero) will sequentialize. RPC calls made while the key value is 0 can be run in parallel in arbitrary order. However, since <a class="el" href="classgraphlab_1_1distributed__control.html#a1353d43494995e3ce7b8573eec3cf5bb" title="Creates a new sequentialization key, returning the old value. ">new_sequentialization_key()</a> uses a very naive key selection system, we recommend the use of <a class="el" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d" title="Sets the sequentialization key to a new value, returning the previous value. ">set_sequentialization_key()</a>.</p>
<p>User should </p><div class="fragment"><div class="line">oldval = <a class="code" href="classgraphlab_1_1distributed__control.html#a1353d43494995e3ce7b8573eec3cf5bb">distributed_control::new_sequentialization_key</a>();</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// ... do stuff</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d">set_sequentialization_key</a>(oldval);</div>
</div><!-- fragment --><p>The key value is <b>thread-local</b> thus setting the key value in one thread does not affect the key value in another thread. </p>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00102">102</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfab1a497d430d7ca675e75737ab2e1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::recv_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits to receives an object a source machine sent via <a class="el" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a> </p>
<p>This function waits to receives a <a class="el" href="serialization.html#sec_serializable">Serializable</a> object "t" from a source machine. The source machine must send the object using <a class="el" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a>. The source machine will wait for the target machine's <a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> to complete before returning.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) {</div>
<div class="line">  i = 10;</div>
<div class="line">  <span class="comment">// if I am machine 0, I send the value i = 10 to machine 1</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518">send_to</a>(1, i);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 1) {</div>
<div class="line">  <span class="comment">// machine 1 receives the value of i from machine 0</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f">recv_from</a>(0, i);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// at this point machines 0 and 1 have the value i = 10</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object to receive. This should be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The target machine to receive from. This function will block until data is received. </td></tr>
    <tr><td class="paramname">t</td><td>The object to receive. It must be serializable and the type must match the source machine's call to <a class="el" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a> </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in <a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c" title="Returns the total number of bytes received excluding all headers and other control overhead...">bytes_received()</a> or <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. This must match the "control" parameter on the source machine's <a class="el" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518" title="Sends an object to a target machine and blocks until the target machine calls recv_from() to receive ...">send_to()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Behavior is undefined if multiple threads on the same machine call recv_from simultaneously </dd></dl>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l01421">1421</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16858c9274a54330867809503e58c8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::register_deletion_callback </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>deleter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a callback which will be called on deletion of the <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> object. </p>
<p>This function is useful for distributed static variables which may be only be deleted after main(). </p>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l00375">375</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0387b77bb3b5505d55fbebedd499b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::remote_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking RPC call to the target machine to run the provided function pointer. </p>
<p><a class="el" href="classgraphlab_1_1distributed__control.html#aa0387b77bb3b5505d55fbebedd499b77" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">remote_call()</a> calls the function "fn" on a target remote machine. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, the return value is lost.</p>
<p><a class="el" href="classgraphlab_1_1distributed__control.html#aa0387b77bb3b5505d55fbebedd499b77" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">remote_call()</a> is non-blocking and does not wait for the target machine to complete execution of the function. Different remote_calls may be handled by different threads on the target machine and thus the target function should be made thread-safe. Alternatively, see <a class="el" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d" title="Sets the sequentialization key to a new value, returning the previous value. ">set_sequentialization_key()</a> to force sequentialization of groups of remote calls.</p>
<p>If blocking operation is desired, <a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a> may be used. Alternatively, a <a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> may also be used to wait for completion of all incomplete RPC calls.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined</span></div>
<div class="line"><span class="keywordtype">void</span> print(std::string s) {</div>
<div class="line">  std::cout &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">... ...</div>
<div class="line"><span class="comment">// call the print function on machine 1 to print &quot;hello&quot;</span></div>
<div class="line">dc.remote_call(1, print, <span class="stringliteral">&quot;hello&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8d50397ae6ba1f72343a7f06af46406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::remote_call </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>machine_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>machine_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a non-blocking RPC call to a collection of machines to run the provided function pointer. </p>
<p>This function calls the provided function pointer on a collection of machines contained in the iterator range [begin, end). Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, the return value is lost.</p>
<p>This function is functionally equivalent to:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span>(machine_begin != machine_end) {</div>
<div class="line"> <a class="code" href="classgraphlab_1_1distributed__control.html#aa0387b77bb3b5505d55fbebedd499b77">remote_call</a>(*machine_begin, fn, ...);</div>
<div class="line"> ++machine_begin;</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, this function makes some optimizations to ensure all arguments are only serialized once instead of #calls times.</p>
<p>This function is non-blocking and does not wait for the target machines to complete execution of the function. Different remote_calls may be handled by different threads on the target machines and thus the target function should be made thread-safe. Alternatively, see <a class="el" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d" title="Sets the sequentialization key to a new value, returning the previous value. ">set_sequentialization_key()</a> to force sequentialization of groups of remote_calls. A <a class="el" href="classgraphlab_1_1distributed__control.html#a7148dfdffd2e4b0fee75e528939bb982" title="A distributed barrier which waits for all machines to call the full_barrier() function before proceed...">full_barrier()</a> may also be issued to wait for completion of all RPC calls issued prior to the full barrier.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined</span></div>
<div class="line"><span class="keywordtype">void</span> print(std::string s) {</div>
<div class="line">  std::cout &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">... ...</div>
<div class="line"><span class="comment">// call the print function on machine 1, 3 and 5 to print &quot;hello&quot;</span></div>
<div class="line">std::vector&lt;<a class="code" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&gt; procs;</div>
<div class="line">procs.push_back(1); procs.push_back(3); procs.push_back(5);</div>
<div class="line">dc.<a class="code" href="classgraphlab_1_1distributed__control.html#aa0387b77bb3b5505d55fbebedd499b77">remote_call</a>(procs.begin(), procs.end(), print, <span class="stringliteral">&quot;hello&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">machine_begin</td><td>The beginning of an iterator range containing a list machines to call. Iterator::value_type must be castable to procid_t. </td></tr>
    <tr><td class="paramname">machine_end</td><td>The end of an iterator range containing a list machines to call. Iterator::value_type must be castable to procid_t. </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15abdebdf3d6ef44994661e562990380"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RetVal graphlab::distributed_control::remote_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blocking RPC call to the target machine to run the provided function pointer. </p>
<p><a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a> calls the function "fn" on a target remote machine. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, it is sent back to calling machine.</p>
<p>Unlike <a class="el" href="classgraphlab_1_1distributed__control.html#aa0387b77bb3b5505d55fbebedd499b77" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">remote_call()</a>, <a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">remote_request()</a> is blocking and waits for the target machine to complete execution of the function. However, different remote_requests may be still be handled by different threads on the target machine.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined</span></div>
<div class="line"><span class="keywordtype">int</span> add_one(<span class="keywordtype">int</span> i) {</div>
<div class="line">  <span class="keywordflow">return</span> i + 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">... ...</div>
<div class="line"><span class="comment">// call the add_one function on machine 1</span></div>
<div class="line">int i = 10;</div>
<div class="line">i = dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380">remote_request</a>(1, add_one, i);</div>
<div class="line"><span class="comment">// i will now be 11</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::fiber_remote_request</a> <a class="el" href="classgraphlab_1_1distributed__control.html#a6bff779bee123f4e4506beaa72497e9f" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">graphlab::distributed_control::future_remote_request</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same return type as the function fn </dd></dl>

</div>
</div>
<a class="anchor" id="a24b095ec7d236c456d66ee3a6cf6b518"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::distributed_control::send_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends an object to a target machine and blocks until the target machine calls <a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> to receive the object. </p>
<p>This function sends a <a class="el" href="serialization.html#sec_serializable">Serializable</a> object "t" to the target machine, but waits for the target machine to call <a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> before returning to receive the object before returning.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) {</div>
<div class="line">  i = 10;</div>
<div class="line">  <span class="comment">// if I am machine 0, I send the value i = 10 to machine 1</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a24b095ec7d236c456d66ee3a6cf6b518">send_to</a>(1, i);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 1) {</div>
<div class="line">  <span class="comment">// machine 1 receives the value of i from machine 0</span></div>
<div class="line">  dc.<a class="code" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f">recv_from</a>(0, i);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// at this point machines 0 and 1 have the value i = 10</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object to send. This should be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target machine to send to. Target machine must call <a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> before this call will return. </td></tr>
    <tr><td class="paramname">t</td><td>The object to send. It must be serializable. The type must match the target machine's call to <a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> </td></tr>
    <tr><td class="paramname">control</td><td>Optional parameter. Defaults to false. If set to true, this will marked as control plane communication and will not register in <a class="el" href="classgraphlab_1_1distributed__control.html#ada9be35a916f2a021b30eb82ade3bd5c" title="Returns the total number of bytes received excluding all headers and other control overhead...">bytes_received()</a> or <a class="el" href="classgraphlab_1_1distributed__control.html#a4e194e4986e7bb0e2130f560cae8bb44" title="Returns the total number of bytes sent excluding headers and other control overhead. Also see network_bytes_sent() ">bytes_sent()</a>. This must match the "control" parameter on the target machine's <a class="el" href="classgraphlab_1_1distributed__control.html#acfab1a497d430d7ca675e75737ab2e1f" title="Waits to receives an object a source machine sent via send_to() ">recv_from()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Behavior is undefined if multiple threads on the same machine call send_to simultaneously </dd></dl>

<p>Definition at line <a class="el" href="dc_8hpp_source.html#l01416">1416</a> of file <a class="el" href="dc_8hpp_source.html">dc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9946232b4ad672db290614d0b924881d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char graphlab::distributed_control::set_sequentialization_key </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>newkey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the sequentialization key to a new value, returning the previous value. </p>
<p>All RPC calls made using the same key value (as long as the key is non-zero) will sequentialize. RPC calls made while the key value is 0 can be run in parallel in arbitrary order.</p>
<div class="fragment"><div class="line">oldval = <a class="code" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d">distributed_control::set_sequentialization_key</a>(new_key);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// ... do stuff</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code" href="classgraphlab_1_1distributed__control.html#a9946232b4ad672db290614d0b924881d">set_sequentialization_key</a>(oldval);</div>
</div><!-- fragment --><p>The key value is <b>thread-local</b> thus setting the key value in one thread does not affect the key value in another thread. </p>

<p>Definition at line <a class="el" href="dc_8cpp_source.html#l00094">94</a> of file <a class="el" href="dc_8cpp_source.html">dc.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>graphlab/rpc/<a class="el" href="dc_8hpp_source.html">dc.hpp</a></li>
<li>graphlab/rpc/<a class="el" href="dc_8cpp_source.html">dc.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:27 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
