<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('serialization.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Serialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We have a custom serialization scheme which is designed for performance rather than compatibility. It does not perform type checking, It does not perform pointer tracking, and has only limited support across platforms. It has been tested, and should be compatible across x86 platforms.</p>
<p>For a summary of all serialization functionality see <a class="el" href="group__group__serialization.html">Serialization</a></p>
<p>There are two serialization classes <a class="el" href="classgraphlab_1_1oarchive.html">graphlab::oarchive</a> and <a class="el" href="classgraphlab_1_1iarchive.html">graphlab::iarchive</a>. The former does output, while the latter does input. To include all serialization headers, #include &lt;<a class="el" href="serialization__includes_8hpp_source.html">graphlab/serialization/serialization_includes.hpp</a>&gt;.</p>
<h1><a class="anchor" id="sec_basic_serialize"></a>
Basic serialize/deserialize</h1>
<p>To serialize data to disk, you just create an output archive, and associate it wiith an output stream.</p>
<p>For instance, to serialize to a file called "file.bin": </p><div class="fragment"><div class="line">std::ofstream fout(<span class="stringliteral">&quot;file.bin&quot;</span>, std::fstream::binary); </div>
<div class="line"><a class="code" href="classgraphlab_1_1oarchive.html">graphlab::oarchive</a> oarc(fout); </div>
</div><!-- fragment --><p>The &lt;&lt; stream operators are then used to write data into the archive.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 10; </div>
<div class="line"><span class="keywordtype">double</span> j = 20; </div>
<div class="line">std::vector&lt;float&gt; v(10,1.0); <span class="comment">// create a vector of 10 &quot;1.0&quot; values</span></div>
<div class="line">oarc &lt;&lt; i &lt;&lt; j &lt;&lt; v; </div>
</div><!-- fragment --><p>To read back, you use the iarchive with an input stream, and read back the variables in the same order:</p>
<div class="fragment"><div class="line">std::ifstream fin(<span class="stringliteral">&quot;file.bin&quot;</span>, std::fstream::binary); </div>
<div class="line"><a class="code" href="classgraphlab_1_1iarchive.html">graphlab::iarchive</a> iarc(fout);</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordtype">double</span> j; </div>
<div class="line">std::vector&lt;float&gt; v;</div>
<div class="line">iarc &gt;&gt; i &gt;&gt; j &gt;&gt; v; </div>
</div><!-- fragment --><h1><a class="anchor" id="sec_serializable"></a>
Serializable</h1>
<p>So what type of data is serializable?</p>
<h2><a class="anchor" id="sec_serializable_integers"></a>
Integer Types</h2>
<p>All integer datatypes are serializable. </p><ul>
<li><code> bool </code> </li>
<li><code> char </code> and <code> unsigned char </code> </li>
<li><code> short </code>and <code> unsigned short</code> </li>
<li><code> int </code>and <code> unsigned int</code> </li>
<li><code> long </code>and <code> unsigned long </code> </li>
<li><code> long long </code>and <code> unsigned long long</code></li>
</ul>
<p>Since all fixed width integer types from stdint (int16_t, int32_t, etc) are derived from these basic types, all fixed width integer types are also serializable.</p>
<ul>
<li><code> int16_t </code> and <code> uint16_t </code> </li>
<li><code> int32_t </code> and <code> uint32_t </code> </li>
<li><code> int64_t </code> and <code> uint64_t </code></li>
</ul>
<p>All integer types are saved in their raw binary form without any additional re-encoding. It is therefore important to deserialize with the same integer width as what was serialized.</p>
<p>The following code will fail in dramatic ways: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line">oarc &lt;&lt; i; <span class="comment">// write some integer to a file</span></div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"><span class="comment">// some time later we need to read back the integer.</span></div>
<div class="line">long j;</div>
<div class="line">iarc &gt;&gt; j; <span class="comment">// this will fail </span></div>
</div><!-- fragment --><h2><a class="anchor" id="sec_serializable_floats"></a>
Floating Point Types</h2>
<p>All floating point data types are serializable. </p><ul>
<li><code>float</code> </li>
<li><code>double</code> </li>
<li><code>long double</code> if your compiler supports quad precision.</li>
</ul>
<p>Similar to integer types, all floating types are saved in raw binary form without re-encoding. You must deserialize with the same floating point width as what was serialized. (i.e. if you serialize a double, you <b>must</b> deserialize a double.</p>
<h2><a class="anchor" id="sec_serializable_containers"></a>
Containers</h2>
<p>The following template containers are serializable as long as the contained types are all serializable. This can be recursively applied. </p><ul>
<li><code>std::vector</code> </li>
<li><code>std::list</code> </li>
<li><code>std::set</code> </li>
<li><code>std::map</code> </li>
<li><code>boost::unordered_set</code> </li>
<li><code>boost::unordered_map</code></li>
</ul>
<p>For instance, a <code>std::vector&lt;int&gt;</code> is serializable. A <code>std::list&lt;std::vector&lt;int&gt; &gt; </code> is therefore also serializable.</p>
<p>There is special handling for the std::vector&lt;T&gt; for performance in the event that T is a simple POD (Plain Old Data) data type. POD types are data types which occupy a contiguous region in memory. For instance, basic types (double, int, etc), or structs which contains only basic types. Such types can be copied or replicated using a simple mem-copy operation and can be greatly acceleration during serialization / deserialization. All basic data types are automatically POD types. We will discuss structs and other user types in the next section.</p>
<h1><a class="anchor" id="sec_serializable_user"></a>
User Structs and Classes</h1>
<p>To serialize a struct/class, all you need to do is to define a public load/save function. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TestClass{ </div>
<div class="line">  <span class="keyword">public</span>: </div>
<div class="line">    <span class="keywordtype">int</span> i, j; </div>
<div class="line">    std::vector&lt;int&gt; k;</div>
<div class="line">    <span class="keywordtype">void</span> save(<a class="code" href="classgraphlab_1_1oarchive.html">graphlab::oarchive</a>&amp; oarc)<span class="keyword"> const </span>{ </div>
<div class="line">      oarc &lt;&lt; i &lt;&lt; j &lt;&lt; k; </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> load(<a class="code" href="classgraphlab_1_1iarchive.html">graphlab::iarchive</a>&amp; iarc) { </div>
<div class="line">      iarc &gt;&gt; i &gt;&gt; j &gt;&gt; k; </div>
<div class="line">    } </div>
<div class="line">}; </div>
</div><!-- fragment --><p> The save() and load() function prototypes must match <b>exactly</b>. Other conditions are that the class must be Default Constructible: </p><div class="fragment"><div class="line"><span class="comment">// it must be possible to create a variable of TestClass type like this</span></div>
<div class="line">TestClass a;</div>
</div><!-- fragment --><p>And that the class must be Assignable: </p><div class="fragment"><div class="line">TestClass a, b;</div>
<div class="line"><span class="comment">// it must be possible to assign one variable of TestClass to another</span></div>
<div class="line">b = a;</div>
</div><!-- fragment --><p>After which, <code>TestClass</code> becomes serializable, and can be stored and read from an archive:</p>
<div class="fragment"><div class="line">TestClass t; </div>
<div class="line"><span class="comment">// set values to t</span></div>
<div class="line">oarc &lt;&lt; t;  <span class="comment">// write it to a file</span></div>
<div class="line"></div>
<div class="line">... some time afterwords...</div>
<div class="line"></div>
<div class="line">TestClass t2;</div>
<div class="line">iarc &gt;&gt; t2; <span class="comment">// read it to a file</span></div>
</div><!-- fragment --><p>Since <code>TestClass</code> is now serializable, containers of TestClass listed in <a class="el" href="serialization.html#sec_serializable_containers">Containers</a> are also serializable.</p>
<h1><a class="anchor" id="sec_serializable_pod"></a>
POD Serialization</h1>
<p>As mentioned in <a class="el" href="serialization.html#sec_serializable_containers">Containers</a>, POD data types occupy a contiguous region in memory and hence can be serialized and deserialized very quickly. Ideally, determination of whether a data type is POD or not should be handled by the compiler. However, this capability is only available in C++11 and not all compilers support it yet. We therefore implemented a simple workaround which will allow you to identify to the serializer that a class is POD, and avoid writing a save/load function.</p>
<p>We consider the following Coordinate struct. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Coordinate{ </div>
<div class="line">  <span class="keywordtype">int</span> x, y, z; </div>
<div class="line">}; </div>
</div><!-- fragment --><p>This struct can be defined to be a POD type using an accelerated serializer by simply inheriting from <a class="el" href="structgraphlab_1_1IS__POD__TYPE.html" title="Inheriting from this type will force the serializer to treat the derived type as a POD type...">graphlab::IS_POD_TYPE</a></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Coordinate: <span class="keyword">public</span> <a class="code" href="structgraphlab_1_1IS__POD__TYPE.html">graphlab::IS_POD_TYPE</a>{ </div>
<div class="line">  <span class="keywordtype">int</span> x, y, z; </div>
<div class="line">}; </div>
</div><!-- fragment --><p>Now, Coordinate variables, or even vector&lt;Coordinate&gt; variables will serialize/deserialize faster. Also, you avoid writing a save() and load() function.</p>
<dl class="section note"><dt>Note</dt><dd>Currently POD detection is performed through the boost type traits library. When compilers implement std::is_pod (in C++11), POD detection will improve, increasing the scope of types which can be serialized quickly and automatically. A minor concern is that the scope of POD types is still slightly too large, since technically pointer types are POD, and those cannot not be serialized automatically.</dd></dl>
<h1><a class="anchor" id="sec_serializable_out_of_place"></a>
Out of Place Serialization</h1>
<p>In some situations, you may find that you need to make a data type serializable, but the data type is implemented by someone else, in a different library, making it impossible to extend and write a member save() and load() function as described in <a class="el" href="serialization.html#sec_serializable_user">User Structs and Classes</a>.</p>
<p>In this situation, it is necessary to implement an "Out of place" serializer. This is unfortunately somewhat more complicated.</p>
<p>For instance, if there is an external type implemented by some other library called Matrix which I would like to make serializable. The following code will have to be written in the <b>global namespace</b></p>
<div class="fragment"><div class="line"><a class="code" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">BEGIN_OUT_OF_PLACE_SAVE</a>(oarc, Matrix, mat)</div>
<div class="line">  <span class="comment">// write the &quot;mat&quot; variable which is of the type Matrix</span></div>
<div class="line">  <span class="comment">// into the output archive oarc</span></div>
<div class="line">END_OUT_OF_PLACE_SAVE()</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group__serialization.html#gaa04ff6a2c8c9873467c864201cf24f02">BEGIN_OUT_OF_PLACE_LOAD</a>(iarc, Matrix, mat)</div>
<div class="line">  <span class="comment">// read the &quot;mat&quot; variable which is of the type Matrix</span></div>
<div class="line">  <span class="comment">// from the input archive iarc </span></div>
<div class="line">END_OUT_OF_PLACE_LOAD()</div>
</div><!-- fragment --><p>To facilitate reading and writing of data from the archives, the output oarchive object provides an <a class="el" href="classgraphlab_1_1oarchive.html#a7c256cacef70f9b82407eb13ede2f076">graphlab::oarchive::write()</a> oarchive::write() function which directly writes a sequence of bytes to the stream. Similarly, the input iarchive object provides a <a class="el" href="classgraphlab_1_1iarchive.html#a93729a89ddf19561e99958ac195d5ddb">graphlab::iarchive::read()</a> iarchive::read() function which directly reads a sequence of bytes from the stream.</p>
<p>For instance, if the Matrix type example above is defined in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Matrix {</div>
<div class="line">  <span class="keywordtype">int</span> width;  <span class="comment">// width of the matrix</span></div>
<div class="line">  <span class="keywordtype">int</span> height; <span class="comment">// height of the matrix</span></div>
<div class="line">  <span class="keywordtype">double</span>* data; <span class="comment">// an array containing all the values in the matrix</span></div>
<div class="line">  <span class="keywordtype">int</span> datalen; <span class="comment">// the number of elements in the &quot;data&quot; array.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>An "out of place" serializer could be implemented the following way: </p><div class="fragment"><div class="line"><a class="code" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">BEGIN_OUT_OF_PLACE_SAVE</a>(oarc, Matrix, mat)</div>
<div class="line">  <span class="comment">// store the dimensions of the matrix</span></div>
<div class="line">  oarc &lt;&lt; mat.width &lt;&lt; mat.height;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// store the length of the data array</span></div>
<div class="line">  oarc &lt;&lt; mat.datalen;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// write the double array</span></div>
<div class="line">  oarc.write((<span class="keywordtype">char</span>*)(mat.data), sizeof(<span class="keywordtype">double</span>) * mat.datalen);</div>
<div class="line">END_OUT_OF_PLACE_SAVE()</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group__serialization.html#gaa04ff6a2c8c9873467c864201cf24f02">BEGIN_OUT_OF_PLACE_LOAD</a>(iarc, Matrix, mat)</div>
<div class="line">  <span class="comment">// clear the matrix data if there is any</span></div>
<div class="line">  if (mat.data != NULL) delete [] mat.data;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// read the dimensions of the matrix</span></div>
<div class="line">  iarc &gt;&gt; mat.width &gt;&gt; mat.height;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// read the length of the data array</span></div>
<div class="line">  iarc &gt;&gt; mat.datalen;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// allocate sufficient storage for the array</span></div>
<div class="line">  mat.data = new <span class="keywordtype">double</span>[mat.datalen];</div>
<div class="line"></div>
<div class="line">  <span class="comment">// read the double array</span></div>
<div class="line">  iarc.read((<span class="keywordtype">char</span>*)(mat.data), sizeof(<span class="keywordtype">double</span>) * mat.datalen);</div>
<div class="line"></div>
<div class="line">END_OUT_OF_PLACE_LOAD()</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:26 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
