<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::synchronous_engine&lt; VertexProgram &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1synchronous__engine.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgraphlab_1_1synchronous__engine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::synchronous_engine&lt; VertexProgram &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__engines.html">GraphLab Engines</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The synchronous engine executes all active vertex program synchronously in a sequence of super-step (iterations) in both the shared and distributed memory settings.  
 <a href="classgraphlab_1_1synchronous__engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="synchronous__engine_8hpp_source.html">graphlab/engine/synchronous_engine.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a457af918f56deee1cfa4d7388612162b"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a457af918f56deee1cfa4d7388612162b">vertex_program_type</a></td></tr>
<tr class="memdesc:a457af918f56deee1cfa4d7388612162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined vertex program type. Equivalent to the VertexProgram template argument.  <a href="#a457af918f56deee1cfa4d7388612162b">More...</a><br /></td></tr>
<tr class="separator:a457af918f56deee1cfa4d7388612162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce0830e073c4c9f7bde48aa7add78c6"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::gather_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a1ce0830e073c4c9f7bde48aa7add78c6">gather_type</a></td></tr>
<tr class="memdesc:a1ce0830e073c4c9f7bde48aa7add78c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined type returned by the gather function.  <a href="#a1ce0830e073c4c9f7bde48aa7add78c6">More...</a><br /></td></tr>
<tr class="separator:a1ce0830e073c4c9f7bde48aa7add78c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb4ab3893aff7ea922341da156878f7"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::message_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a></td></tr>
<tr class="memdesc:abcb4ab3893aff7ea922341da156878f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined message type used to signal neighboring vertex programs.  <a href="#abcb4ab3893aff7ea922341da156878f7">More...</a><br /></td></tr>
<tr class="separator:abcb4ab3893aff7ea922341da156878f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fae54a2dfc7523fe303c7af9c2dd9c2"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::vertex_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a4fae54a2dfc7523fe303c7af9c2dd9c2">vertex_data_type</a></td></tr>
<tr class="memdesc:a4fae54a2dfc7523fe303c7af9c2dd9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data associated with each vertex in the graph.  <a href="#a4fae54a2dfc7523fe303c7af9c2dd9c2">More...</a><br /></td></tr>
<tr class="separator:a4fae54a2dfc7523fe303c7af9c2dd9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c8f04b5e42f52b1dd531baf207da6f"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::edge_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a74c8f04b5e42f52b1dd531baf207da6f">edge_data_type</a></td></tr>
<tr class="memdesc:a74c8f04b5e42f52b1dd531baf207da6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data associated with each edge in the graph.  <a href="#a74c8f04b5e42f52b1dd531baf207da6f">More...</a><br /></td></tr>
<tr class="separator:a74c8f04b5e42f52b1dd531baf207da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1cb76d31f21796e8eac2918386a33"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::graph_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a58c1cb76d31f21796e8eac2918386a33">graph_type</a></td></tr>
<tr class="memdesc:a58c1cb76d31f21796e8eac2918386a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of graph supported by this vertex program.  <a href="#a58c1cb76d31f21796e8eac2918386a33">More...</a><br /></td></tr>
<tr class="separator:a58c1cb76d31f21796e8eac2918386a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa401498dc228b778e74dd18abe4affc3"><td class="memItemLeft" align="right" valign="top">typedef graph_type::vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#aa401498dc228b778e74dd18abe4affc3">vertex_type</a></td></tr>
<tr class="memdesc:aa401498dc228b778e74dd18abe4affc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent a vertex in the graph. See <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graphlab::distributed_graph::vertex_type</a> for details.  <a href="#aa401498dc228b778e74dd18abe4affc3">More...</a><br /></td></tr>
<tr class="separator:aa401498dc228b778e74dd18abe4affc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630bc97984f82232f90477c281b9566a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a630bc97984f82232f90477c281b9566a">edge_type</a></td></tr>
<tr class="memdesc:a630bc97984f82232f90477c281b9566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent an edge in the graph. See <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graphlab::distributed_graph::edge_type</a> for details.  <a href="#a630bc97984f82232f90477c281b9566a">More...</a><br /></td></tr>
<tr class="separator:a630bc97984f82232f90477c281b9566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c393517c30de7401ca0dfcacf9f21f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1icontext.html">icontext</a>&lt; <a class="el" href="classgraphlab_1_1synchronous__engine.html#a58c1cb76d31f21796e8eac2918386a33">graph_type</a>, <a class="el" href="classgraphlab_1_1synchronous__engine.html#a1ce0830e073c4c9f7bde48aa7add78c6">gather_type</a>, <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a46c393517c30de7401ca0dfcacf9f21f">icontext_type</a></td></tr>
<tr class="memdesc:a46c393517c30de7401ca0dfcacf9f21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the callback interface passed by the engine to vertex programs. See <a class="el" href="classgraphlab_1_1icontext.html">graphlab::icontext</a> for details.  <a href="#a46c393517c30de7401ca0dfcacf9f21f">More...</a><br /></td></tr>
<tr class="separator:a46c393517c30de7401ca0dfcacf9f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01472800a89cef585293b074e4aa9925"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01472800a89cef585293b074e4aa9925"></a>
typedef graph_type::vertex_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a></td></tr>
<tr class="memdesc:a01472800a89cef585293b074e4aa9925"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex identifier type defined in graphlab::vertex_id_type. <br /></td></tr>
<tr class="separator:a01472800a89cef585293b074e4aa9925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab295d6cdb7cdbccfb2dd9748a39065fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#ab295d6cdb7cdbccfb2dd9748a39065fe">synchronous_engine</a> (<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;dc, <a class="el" href="classgraphlab_1_1synchronous__engine.html#a58c1cb76d31f21796e8eac2918386a33">graph_type</a> &amp;graph, const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;opts=<a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>())</td></tr>
<tr class="memdesc:ab295d6cdb7cdbccfb2dd9748a39065fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a synchronous engine for a given graph and options.  <a href="#ab295d6cdb7cdbccfb2dd9748a39065fe">More...</a><br /></td></tr>
<tr class="separator:ab295d6cdb7cdbccfb2dd9748a39065fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dc0f312b34a2f9ecf3a6790a95aeab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a53dc0f312b34a2f9ecf3a6790a95aeab">start</a> ()</td></tr>
<tr class="memdesc:a53dc0f312b34a2f9ecf3a6790a95aeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start execution of the synchronous engine.  <a href="#a53dc0f312b34a2f9ecf3a6790a95aeab">More...</a><br /></td></tr>
<tr class="separator:a53dc0f312b34a2f9ecf3a6790a95aeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8debef60159f9cd584ed57f6d5bfef4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#ad8debef60159f9cd584ed57f6d5bfef4">num_updates</a> () const </td></tr>
<tr class="memdesc:ad8debef60159f9cd584ed57f6d5bfef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the total number of updates (calls to apply) executed since start was last invoked.  <a href="#ad8debef60159f9cd584ed57f6d5bfef4">More...</a><br /></td></tr>
<tr class="separator:ad8debef60159f9cd584ed57f6d5bfef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b75dd97ee2b20d3c5483d4f851e40bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b75dd97ee2b20d3c5483d4f851e40bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signal</b> (<a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a> vid, const <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a>())</td></tr>
<tr class="separator:a6b75dd97ee2b20d3c5483d4f851e40bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43d4539e101c16302d07ba90509882e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa43d4539e101c16302d07ba90509882e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signal_all</b> (const <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)</td></tr>
<tr class="separator:aa43d4539e101c16302d07ba90509882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb9b35b199d2e76bc22b2f261e585ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb9b35b199d2e76bc22b2f261e585ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signal_vset</b> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset, const <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)</td></tr>
<tr class="separator:aceb9b35b199d2e76bc22b2f261e585ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2445bcd6a03578f62a4b3ca471777da3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a2445bcd6a03578f62a4b3ca471777da3">elapsed_seconds</a> () const </td></tr>
<tr class="memdesc:a2445bcd6a03578f62a4b3ca471777da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the elapsed time in seconds since start was last called.  <a href="#a2445bcd6a03578f62a4b3ca471777da3">More...</a><br /></td></tr>
<tr class="separator:a2445bcd6a03578f62a4b3ca471777da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4dc04bce51af81f928f00653fdb4fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#abc4dc04bce51af81f928f00653fdb4fe">iteration</a> () const </td></tr>
<tr class="memdesc:abc4dc04bce51af81f928f00653fdb4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current iteration number since start was last invoked.  <a href="#abc4dc04bce51af81f928f00653fdb4fe">More...</a><br /></td></tr>
<tr class="separator:abc4dc04bce51af81f928f00653fdb4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609d06d25b1e06c17a2d04e00d5b3bbf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a609d06d25b1e06c17a2d04e00d5b3bbf">total_memory_usage</a> () const </td></tr>
<tr class="memdesc:a609d06d25b1e06c17a2d04e00d5b3bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the total memory used by the entire distributed system.  <a href="#a609d06d25b1e06c17a2d04e00d5b3bbf">More...</a><br /></td></tr>
<tr class="separator:a609d06d25b1e06c17a2d04e00d5b3bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b7178b34cf55f0ff27254df488d0e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgraphlab_1_1iengine.html#a7f7635b47e0f3ac5afc7c9d3a334ed94">aggregator_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a23b7178b34cf55f0ff27254df488d0e8">get_aggregator</a> ()</td></tr>
<tr class="memdesc:a23b7178b34cf55f0ff27254df488d0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the distributed aggregator object.  <a href="#a23b7178b34cf55f0ff27254df488d0e8">More...</a><br /></td></tr>
<tr class="separator:a23b7178b34cf55f0ff27254df488d0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa376024471b03353f6af154942524d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fa376024471b03353f6af154942524d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a8fa376024471b03353f6af154942524d">init</a> ()</td></tr>
<tr class="memdesc:a8fa376024471b03353f6af154942524d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the engine and allocate datastructures for vertex, and lock, clear all the messages. <br /></td></tr>
<tr class="separator:a8fa376024471b03353f6af154942524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab945aad4bc982b507efc1ba55dba30d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#ab945aad4bc982b507efc1ba55dba30d8">signal</a> (<a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a> vertex, const <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a>())=0</td></tr>
<tr class="memdesc:ab945aad4bc982b507efc1ba55dba30d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals single a vertex with an optional message.  <a href="#ab945aad4bc982b507efc1ba55dba30d8">More...</a><br /></td></tr>
<tr class="separator:ab945aad4bc982b507efc1ba55dba30d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0afe236029be943f870a77bd2a6b3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a9c0afe236029be943f870a77bd2a6b3f">signal_all</a> (const <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)=0</td></tr>
<tr class="memdesc:a9c0afe236029be943f870a77bd2a6b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all vertices with a particular message.  <a href="#a9c0afe236029be943f870a77bd2a6b3f">More...</a><br /></td></tr>
<tr class="separator:a9c0afe236029be943f870a77bd2a6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a7a9e2b10c0934d4c486c56c649c13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a86a7a9e2b10c0934d4c486c56c649c13">signal_vset</a> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset, const <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)=0</td></tr>
<tr class="memdesc:a86a7a9e2b10c0934d4c486c56c649c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a set of vertices with a particular message.  <a href="#a86a7a9e2b10c0934d4c486c56c649c13">More...</a><br /></td></tr>
<tr class="separator:a86a7a9e2b10c0934d4c486c56c649c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c802e7271358becf2cf2b2418b943a"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename VertexMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:a39c802e7271358becf2cf2b2418b943a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a">add_vertex_aggregator</a> (const std::string &amp;key, VertexMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:a39c802e7271358becf2cf2b2418b943a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name already exists.  <a href="#a39c802e7271358becf2cf2b2418b943a">More...</a><br /></td></tr>
<tr class="separator:a39c802e7271358becf2cf2b2418b943a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafefe848a350d243f62fefe173d3d287"><td class="memTemplParams" colspan="2">template&lt;typename VertexMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:aafefe848a350d243f62fefe173d3d287"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#aafefe848a350d243f62fefe173d3d287">add_vertex_aggregator</a> (const std::string &amp;key, VertexMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:aafefe848a350d243f62fefe173d3d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of add_vertex_aggregator for C++11 which does not require the user to provide the reduction type.  <a href="#aafefe848a350d243f62fefe173d3d287">More...</a><br /></td></tr>
<tr class="separator:aafefe848a350d243f62fefe173d3d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21f70c04f6e9954e5db488cad6bff0"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename EdgeMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:adf21f70c04f6e9954e5db488cad6bff0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0">add_edge_aggregator</a> (const std::string &amp;key, EdgeMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:adf21f70c04f6e9954e5db488cad6bff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name already exists.  <a href="#adf21f70c04f6e9954e5db488cad6bff0">More...</a><br /></td></tr>
<tr class="separator:adf21f70c04f6e9954e5db488cad6bff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1407b75158fdaef63eec9719da40da"><td class="memTemplParams" colspan="2">template&lt;typename EdgeMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:a6d1407b75158fdaef63eec9719da40da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a6d1407b75158fdaef63eec9719da40da">add_edge_aggregator</a> (const std::string &amp;key, EdgeMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:a6d1407b75158fdaef63eec9719da40da"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of add_edge_aggregator for C++11 which does not require the user to provide the reduction type.  <a href="#a6d1407b75158fdaef63eec9719da40da">More...</a><br /></td></tr>
<tr class="separator:a6d1407b75158fdaef63eec9719da40da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742">aggregate_now</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an immediate aggregation on a key.  <a href="#a5f0ebbe2a3dae9ed3e7cbe6538e37742">More...</a><br /></td></tr>
<tr class="separator:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3fde48e79d248db7b815a313cd92e2"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename VertexMapperType &gt; </td></tr>
<tr class="memitem:a1b3fde48e79d248db7b815a313cd92e2"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2">map_reduce_vertices</a> (VertexMapperType mapfunction)</td></tr>
<tr class="memdesc:a1b3fde48e79d248db7b815a313cd92e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each vertex in the graph returning the result.  <a href="#a1b3fde48e79d248db7b815a313cd92e2">More...</a><br /></td></tr>
<tr class="separator:a1b3fde48e79d248db7b815a313cd92e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename EdgeMapperType &gt; </td></tr>
<tr class="memitem:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb">map_reduce_edges</a> (EdgeMapperType mapfunction)</td></tr>
<tr class="memdesc:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each edge in the graph returning the result.  <a href="#a8da8e299fd9bfc87e308d5ad571f35eb">More...</a><br /></td></tr>
<tr class="separator:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e97843604c45c08f71502b3494a7a"><td class="memTemplParams" colspan="2">template&lt;typename VertexMapperType &gt; </td></tr>
<tr class="memitem:a4d9e97843604c45c08f71502b3494a7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a">transform_vertices</a> (VertexMapperType mapfunction)</td></tr>
<tr class="memdesc:a4d9e97843604c45c08f71502b3494a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each vertex in the graph.  <a href="#a4d9e97843604c45c08f71502b3494a7a">More...</a><br /></td></tr>
<tr class="separator:a4d9e97843604c45c08f71502b3494a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memTemplParams" colspan="2">template&lt;typename EdgeMapperType &gt; </td></tr>
<tr class="memitem:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23">transform_edges</a> (EdgeMapperType mapfunction)</td></tr>
<tr class="memdesc:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each edge in the graph.  <a href="#a4ab681ecccc66ad8696f5a4d0103fa23">More...</a><br /></td></tr>
<tr class="separator:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602b1e06b1b4db6537e6e48774499b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a6602b1e06b1b4db6537e6e48774499b9">aggregate_periodic</a> (const std::string &amp;key, float seconds)</td></tr>
<tr class="memdesc:a6602b1e06b1b4db6537e6e48774499b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that a particular aggregation key be recomputed periodically when the engine is running.  <a href="#a6602b1e06b1b4db6537e6e48774499b9">More...</a><br /></td></tr>
<tr class="separator:a6602b1e06b1b4db6537e6e48774499b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VertexProgram&gt;<br />
class graphlab::synchronous_engine&lt; VertexProgram &gt;</h3>

<p>The synchronous engine executes all active vertex program synchronously in a sequence of super-step (iterations) in both the shared and distributed memory settings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexProgram</td><td>The user defined vertex program which should implement the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<h3>Execution Semantics</h3>
<p>On <a class="el" href="classgraphlab_1_1synchronous__engine.html#a53dc0f312b34a2f9ecf3a6790a95aeab" title="Start execution of the synchronous engine. ">start()</a> the <a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">graphlab::ivertex_program::init</a> function is invoked on all vertex programs in parallel to initialize the vertex program, vertex data, and possibly signal vertices. The engine then proceeds to execute a sequence of super-steps (iterations) each of which is further decomposed into a sequence of minor-steps which are also executed synchronously: </p><ul>
<li>Receive all incoming messages (signals) by invoking the <a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">graphlab::ivertex_program::init</a> function on all vertex-programs that have incoming messages. If a vertex-program does not have any incoming messages then it is not active during this super-step. </li>
<li>Execute all gathers for active vertex programs by invoking the user defined <a class="el" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef">graphlab::ivertex_program::gather</a> function on the edge direction returned by the <a class="el" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">graphlab::ivertex_program::gather_edges</a> function. The gather functions can modify edge data but cannot modify the vertex program or vertex data and therefore can be executed on multiple edges in parallel. The gather type is used to accumulate (sum) the result of the gather function calls. </li>
<li>Execute all apply functions for active vertex-programs by invoking the user defined <a class="el" href="classgraphlab_1_1ivertex__program.html#ad1f9db9ebc638f6a9aa22014e8db1854">graphlab::ivertex_program::apply</a> function passing the sum of the gather functions. If <a class="el" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">graphlab::ivertex_program::gather_edges</a> returns no edges then the default gather value is passed to apply. The apply function can modify the vertex program and vertex data. </li>
<li>Execute all scatters for active vertex programs by invoking the user defined <a class="el" href="classgraphlab_1_1ivertex__program.html#a68e93eefb25b31b0df72b4c454a89105">graphlab::ivertex_program::scatter</a> function on the edge direction returned by the <a class="el" href="classgraphlab_1_1ivertex__program.html#aa296513f9727bb48b372a0386c7e0c05">graphlab::ivertex_program::scatter_edges</a> function. The scatter functions can modify edge data but cannot modify the vertex program or vertex data and therefore can be executed on multiple edges in parallel.</li>
</ul>
<h3>Construction</h3>
<p>The synchronous engine is constructed by passing in a <a class="el" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> object which manages coordination between engine threads and a <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a> object which is the graph on which the engine should be run. The graph should already be populated and cannot change after the engine is constructed. In the distributed setting all program instances (running on each machine) should construct an instance of the engine at the same time.</p>
<p>Computation is initiated by signaling vertices using either graphlab::synchronous_engine::signal or graphlab::synchronous_engine::signal_all. In either case all machines should invoke signal or signal all at the same time. Finally, computation is initiated by calling the <a class="el" href="classgraphlab_1_1synchronous__engine.html#a53dc0f312b34a2f9ecf3a6790a95aeab">graphlab::synchronous_engine::start</a> function.</p>
<h3>Example Usage</h3>
<p>The following is a simple example demonstrating how to use the engine: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>vertex_data {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>edge_data {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;vertex_data, edge_data&gt;</a> <a class="code" href="classgraphlab_1_1synchronous__engine.html#a58c1cb76d31f21796e8eac2918386a33">graph_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="classgraphlab_1_1synchronous__engine.html#a1ce0830e073c4c9f7bde48aa7add78c6">gather_type</a>;</div>
<div class="line"><span class="keyword">struct </span>pagerank_vprog :</div>
<div class="line">  <span class="keyword">public</span> <a class="code" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt;graph_type, gather_type&gt; {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Initialize control plain using mpi</span></div>
<div class="line">  graphlab::mpi_tools::init(argc, argv);</div>
<div class="line">  <a class="code" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> dc;</div>
<div class="line">  <span class="comment">// Parse command line options</span></div>
<div class="line">  <a class="code" href="classgraphlab_1_1command__line__options.html">graphlab::command_line_options</a> clopts(<span class="stringliteral">&quot;PageRank algorithm.&quot;</span>);</div>
<div class="line">  std::string graph_dir;</div>
<div class="line">  clopts.attach_option(<span class="stringliteral">&quot;graph&quot;</span>, &amp;graph_dir, graph_dir,</div>
<div class="line">                       <span class="stringliteral">&quot;The graph file.&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span>(!clopts.parse(argc, argv)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Error in parsing arguments.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  graph_type graph(dc, clopts);</div>
<div class="line">  graph.load_structure(graph_dir, <span class="stringliteral">&quot;tsv&quot;</span>);</div>
<div class="line">  graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#ae02d3ec3d347f9428f3bdde3a1cb4095">finalize</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;#vertices: &quot;</span> &lt;&lt; graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#aa5cc3c87e65798a8c934159ea6c1cc9c">num_vertices</a>()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #edges:&quot;</span> &lt;&lt; graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#ad85bc145e123f333af62cfb0d99688fa">num_edges</a>() &lt;&lt; std::endl;</div>
<div class="line">  <a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;pagerank_vprog&gt;</a> engine(dc, graph, clopts);</div>
<div class="line">  engine.signal_all();</div>
<div class="line">  engine.start();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Runtime: &quot;</span> &lt;&lt; engine.elapsed_seconds();</div>
<div class="line">  graphlab::mpi_tools::finalize();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="engineopts"></a>Engine Options </h1>
<p>The synchronous engine supports several engine options which can be set as command line arguments using <code>&ndash;engine_opts</code> :</p>
<ul>
<li><b>max_iterations</b>: (default: infinity) The maximum number of iterations (super-steps) to run.</li>
</ul>
<ul>
<li><b>timeout</b>: (default: infinity) The maximum time in seconds that the engine may run. When the time runs out the current iteration is completed and then the engine terminates.</li>
</ul>
<ul>
<li><b>use_cache</b>: (default: false) This is used to enable caching. When caching is enabled the gather phase is skipped for vertices that already have a cached value. To use caching the vertex program must either clear (<a class="el" href="classgraphlab_1_1icontext.html#a9f7c49ee6b4a59be90ae65841597bd5b">icontext::clear_gather_cache</a>) or update (<a class="el" href="classgraphlab_1_1icontext.html#a9c85c9b34ae08d72a28ca5e698a34482">icontext::post_delta</a>) the cache values of neighboring vertices during the scatter phase.</li>
</ul>
<ul>
<li><b>snapshot_interval</b> If set to a positive value, a snapshot is taken every this number of iterations. If set to 0, a snapshot is taken before the first iteration. If set to a negative value, no snapshots are taken. Defaults to -1. A snapshot is a binary dump of the graph.</li>
</ul>
<ul>
<li><b>snapshot_path</b> If snapshot_interval is set to a value &gt;=0, this option must be specified and should contain a target basename for the snapshot. The path including folder and file prefix in which the snapshots should be saved.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgraphlab_1_1omni__engine.html" title="The omni engine encapsulates all the GraphLab engines allowing the user to select which engine to use...">graphlab::omni_engine</a> </dd>
<dd>
<a class="el" href="classgraphlab_1_1async__consistent__engine.html" title="The asynchronous consistent engine executed vertex programs asynchronously and can ensure mutual excl...">graphlab::async_consistent_engine</a> </dd>
<dd>
graphlab::semi_synchronous_engine </dd></dl>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00207">207</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a74c8f04b5e42f52b1dd531baf207da6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::edge_data_type <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1synchronous__engine.html#a74c8f04b5e42f52b1dd531baf207da6f">edge_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of data associated with each edge in the graph. </p>
<p>The edge data type must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00256">256</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a630bc97984f82232f90477c281b9566a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to represent an edge in the graph. See <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graphlab::distributed_graph::edge_type</a> for details. </p>
<p>The edge type contains the function <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">graphlab::distributed_graph::edge_type::data</a> which returns a reference to the edge data. In addition the edge type contains the function <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a5d8d51b99bfbfb361d7894a6d8e67ce1">graphlab::distributed_graph::edge_type::source</a> and <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">graphlab::distributed_graph::edge_type::target</a>. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00289">289</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ce0830e073c4c9f7bde48aa7add78c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::gather_type <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1synchronous__engine.html#a1ce0830e073c4c9f7bde48aa7add78c6">gather_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined type returned by the gather function. </p>
<p>The gather type is defined in the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface and is the value returned by the <a class="el" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef">graphlab::ivertex_program::gather</a> function. The gather type must have an <code>operator+=(const gather_type&amp; other)</code> function and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00229">229</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58c1cb76d31f21796e8eac2918386a33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::graph_type <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1synchronous__engine.html#a58c1cb76d31f21796e8eac2918386a33">graph_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of graph supported by this vertex program. </p>
<p>See <a class="el" href="classgraphlab_1_1distributed__graph.html" title="A directed graph datastructure which is distributed across multiple machines. ">graphlab::distributed_graph</a> </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00263">263</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46c393517c30de7401ca0dfcacf9f21f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1icontext.html">icontext</a>&lt;<a class="el" href="classgraphlab_1_1synchronous__engine.html#a58c1cb76d31f21796e8eac2918386a33">graph_type</a>, <a class="el" href="classgraphlab_1_1synchronous__engine.html#a1ce0830e073c4c9f7bde48aa7add78c6">gather_type</a>, <a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a>&gt; <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the callback interface passed by the engine to vertex programs. See <a class="el" href="classgraphlab_1_1icontext.html">graphlab::icontext</a> for details. </p>
<p>The context callback is passed to the vertex program functions and is used to signal other vertices, get the current iteration, and access information about the engine. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00299">299</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcb4ab3893aff7ea922341da156878f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::message_type <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1synchronous__engine.html#abcb4ab3893aff7ea922341da156878f7">message_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined message type used to signal neighboring vertex programs. </p>
<p>The message type is defined in the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface and used in the call to <a class="el" href="classgraphlab_1_1icontext.html#ab1b5ca81e1c7665a98f4cad04fb0819d">graphlab::icontext::signal</a>. The message type must have an <code>operator+=(const gather_type&amp; other)</code> function and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00242">242</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fae54a2dfc7523fe303c7af9c2dd9c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::vertex_data_type <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1synchronous__engine.html#a4fae54a2dfc7523fe303c7af9c2dd9c2">vertex_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of data associated with each vertex in the graph. </p>
<p>The vertex data type must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00249">249</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a457af918f56deee1cfa4d7388612162b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1synchronous__engine.html#a457af918f56deee1cfa4d7388612162b">vertex_program_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined vertex program type. Equivalent to the VertexProgram template argument. </p>
<p>The user defined vertex program type which should implement the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00218">218</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa401498dc228b778e74dd18abe4affc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef graph_type::vertex_type <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to represent a vertex in the graph. See <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graphlab::distributed_graph::vertex_type</a> for details. </p>
<p>The vertex type contains the function <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">graphlab::distributed_graph::vertex_type::data</a> which returns a reference to the vertex data as well as other functions like <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a485616c8965fcd995cb705722b6b4757">graphlab::distributed_graph::vertex_type::num_in_edges</a> which returns the number of in edges. </p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l00276">276</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab295d6cdb7cdbccfb2dd9748a39065fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1synchronous__engine.html">synchronous_engine</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1synchronous__engine.html#a58c1cb76d31f21796e8eac2918386a33">graph_type</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a synchronous engine for a given graph and options. </p>
<p>The synchronous engine should be constructed after the graph has been loaded (e.g., <a class="el" href="classgraphlab_1_1distributed__graph.html#af35ff3509a89a9983c3ae11cae3d6a50">graphlab::distributed_graph::load</a>) and the graphlab options have been set (e.g., <a class="el" href="classgraphlab_1_1command__line__options.html">graphlab::command_line_options</a>).</p>
<p>In the distributed engine the synchronous engine must be called on all machines at the same time (in the same order) passing the <a class="el" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> object. Upon construction the synchronous engine allocates several data-structures to store messages, gather accumulants, and vertex programs and therefore may require considerable memory.</p>
<p>The number of threads to create are read from <a class="el" href="classgraphlab_1_1graphlab__options.html#a8dae0062a8b67f8066a20f15c54e6d3e">opts.get_ncpus()</a>.</p>
<p>See the <a href="#engineopts">main class documentation</a> for details on the available options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dc</td><td>Distributed controller to associate with </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">graph</td><td>A reference to the graph object that this engine will modify. The graph must be fully constructed and finalized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>A <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab::graphlab_options</a> object specifying engine parameters. This is typically constructed using <a class="el" href="classgraphlab_1_1command__line__options.html">graphlab::command_line_options</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs an synchronous distributed engine. The number of threads to create are read from opts::get_ncpus().</p>
<p>Valid engine options (<a class="el" href="classgraphlab_1_1graphlab__options.html#ad1e27e9b1d6e49dbb0d3881b2125321e" title="Get the engine arguments. ">graphlab_options::get_engine_args()</a>): </p><ul>
<li><code>max_iterations</code> Sets the maximum number of iterations the engine will run for. </li>
<li><code>use_cache</code> If set to true, partial gathers are cached. See gather_caching to understand the behavior of the gather caching model and how it may be used to accelerate program performance.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>Distributed controller to associate with </td></tr>
    <tr><td class="paramname">graph</td><td>The graph to schedule over. The graph must be fully constructed and finalized. </td></tr>
    <tr><td class="paramname">opts</td><td>A <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> object containing options and parameters for the engine. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l01002">1002</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adf21f70c04f6e9954e5db488cad6bff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename EdgeMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_edge_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name already exists. </p>
<p>Creates a edge aggregator associated to a particular key. The map_function is called over every edge in the graph, and the return value of the map is summed. The finalize_function is then called on the result of the reduction. The finalize_function is called on all machines. The map_function should only read the graph data, and should not make any modifications.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>An aggregator can be constructed to compute the absolute sum of all the edge data. To do this, we define two functions. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_edge_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define the aggregator in the engine by calling <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. We must assign it a unique name which will be used to reference this particular aggregate operation. We shall call it "absolute_edge_sum". </p><div class="fragment"><div class="line">engine.add_edge_aggregator&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>,</div>
<div class="line">                                    absolute_edge_data, </div>
<div class="line">                                    print_finalize);</div>
</div><!-- fragment --><p>When executed, the engine execute <code>absolute_edge_data()</code> on each edge in the graph. <code>absolute_edge_data()</code> reads the edge data, and returns its absolute value. All return values are then summing them together using the float's += operator. The final result is than passed to the <code>print_finalize</code> function. The template argument <code>&lt;float&gt;</code> is necessary to provide information about the return type of <code>absolute_edge_data</code>.</p>
<p>This aggregator can be run immediately by calling <a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742" title="Performs an immediate aggregation on a key. ">aggregate_now()</a> with the name of the aggregator. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>);</div>
</div><!-- fragment --><p>Or can be arranged to run periodically together with the engine execution (in this example, every 1.5 seconds). </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><p>Note that since finalize is called on <b>all machines</b>, multiple copies of the total will be printed. If only one copy is desired, see <a class="el" href="classgraphlab_1_1icontext.html#a7f827dd93aba5809b69cf659554f8869">context.cout()</a> or to get the actual process ID using <a class="el" href="classgraphlab_1_1icontext.html#ab57348d56fb08bd10f3edbccc4137cb1">context.procid()</a></p>
<h3>Details</h3>
<p>The <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> function is also templatized over both function types and there is no strong enforcement of the exact argument types of the map function and the reduce function. For instance, in the above example, the following print_finalize() variants may also be accepted.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">double</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In particlar, the last variation may be useful for performance reasons if the reduction type is large.</p>
<h3>Distributed Behavior</h3>
<p>To obtain consistent distributed behavior in the distributed setting, we designed the aggregator to minimize the amount of asymmetry among the machines. In particular, the finalize operation is guaranteed to be called on all machines. This therefore permits global variables to be modified on finalize since all machines are ensured to be eventually consistent.</p>
<p>For instance, in the above example, print_finalize could store the result in a global variable: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  GLOBAL_TOTAL = total;</div>
<div class="line">}</div>
</div><!-- fragment --><p> which will make it accessible to all other running update functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00692">692</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d1407b75158fdaef63eec9719da40da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename EdgeMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_edge_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload of add_edge_aggregator for C++11 which does not require the user to provide the reduction type. </p>
<p>This function is available only if the compiler has C++11 support. Specifically, it uses C++11's decltype operation to infer the reduction type, thus eliminating the need for the function call to be templatized over the reduction type. For instance, in the <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> example, it allows the following code to be written: </p><div class="fragment"><div class="line">engine.add_edge_aggregator(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>,</div>
<div class="line">                             absolute_edge_data, </div>
<div class="line">                             print_finalize);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00748">748</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39c802e7271358becf2cf2b2418b943a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename VertexMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_vertex_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name already exists. </p>
<p>Creates a vertex aggregator associated to a particular key. The map_function is called over every vertex in the graph, and the return value of the map is summed. The finalize_function is then called on the result of the reduction. The finalize_function is called on all machines. The map_function should only read the graph data, and should not make any modifications.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>An aggregator can be constructed to compute the absolute sum of all the vertex data. To do this, we define two functions. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_vertex_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                           <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, </div>
<div class="line">                    <span class="keywordtype">float</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define the aggregator in the engine by calling <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a>. We must assign it a unique name which will be used to reference this particular aggregate operation. We shall call it "absolute_vertex_sum". </p><div class="fragment"><div class="line">engine.add_vertex_aggregator&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>,</div>
<div class="line">                                    absolute_vertex_data, </div>
<div class="line">                                    print_finalize);</div>
</div><!-- fragment --><p>When executed, the engine execute <code>absolute_vertex_data()</code> on each vertex in the graph. <code>absolute_vertex_data()</code> reads the vertex data, and returns its absolute value. All return values are then summing them together using the float's += operator. The final result is than passed to the <code>print_finalize</code> function. The template argument <code>&lt;float&gt;</code> is necessary to provide information about the return type of <code>absolute_vertex_data</code>.</p>
<p>This aggregator can be run immediately by calling <a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742" title="Performs an immediate aggregation on a key. ">aggregate_now()</a> with the name of the aggregator. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>);</div>
</div><!-- fragment --><p>Or can be arranged to run periodically together with the engine execution (in this example, every 1.5 seconds). </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><p>Note that since finalize is called on <b>all machines</b>, multiple copies of the total will be printed. If only one copy is desired, see <a class="el" href="classgraphlab_1_1icontext.html#a7f827dd93aba5809b69cf659554f8869">context.cout()</a> or to get the actual process ID using <a class="el" href="classgraphlab_1_1icontext.html#ab57348d56fb08bd10f3edbccc4137cb1">context.procid()</a></p>
<p>In practice, the reduction type can be any arbitrary user-defined type as long as a += operator is defined. This permits great flexibility in the type of operations the aggregator can perform.</p>
<h3>Details</h3>
<p>The <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> function is also templatized over both function types and there is no strong enforcement of the exact argument types of the map function and the reduce function. For instance, in the above example, the following print_finalize() variants may also be accepted.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">double</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In particlar, the last variation may be useful for performance reasons if the reduction type is large.</p>
<h3>Distributed Behavior</h3>
<p>To obtain consistent distributed behavior in the distributed setting, we designed the aggregator to minimize the amount of asymmetry among the machines. In particular, the finalize operation is guaranteed to be called on all machines. This therefore permits global variables to be modified on finalize since all machines are ensured to be eventually consistent.</p>
<p>For instance, in the above example, print_finalize could store the result in a global variable: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  GLOBAL_TOTAL = total;</div>
<div class="line">}</div>
</div><!-- fragment --><p> which will make it accessible to all other running update functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00484">484</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafefe848a350d243f62fefe173d3d287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename VertexMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_vertex_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload of add_vertex_aggregator for C++11 which does not require the user to provide the reduction type. </p>
<p>This function is available only if the compiler has C++11 support. Specifically, it uses C++11's decltype operation to infer the reduction type, thus eliminating the need for the function call to be templatized over the reduction type. For instance, in the <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> example, it allows the following code to be written: </p><div class="fragment"><div class="line">engine.add_vertex_aggregator(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>,</div>
<div class="line">                             absolute_vertex_data, </div>
<div class="line">                             print_finalize);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00539">539</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f0ebbe2a3dae9ed3e7cbe6538e37742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::aggregate_now </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an immediate aggregation on a key. </p>
<p>Performs an immediate aggregation on a key. All machines must call this simultaneously. If the key is not found, false is returned. Otherwise returns true on success.</p>
<p>For instance, the following code will run the aggregator with the name "absolute_vertex_sum" immediately. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to aggregate now. Must be a key previously created by <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> or <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if key not found, True on success. </dd></dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00780">780</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6602b1e06b1b4db6537e6e48774499b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::aggregate_periodic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that a particular aggregation key be recomputed periodically when the engine is running. </p>
<p>Requests that the aggregator with a given key be aggregated every certain number of seconds when the engine is running. Note that the period is prescriptive: in practice the actual period will be larger than the requested period. Seconds must be &gt;= 0;</p>
<p>For instance, the following code will schedule the aggregator with the name "absolute_vertex_sum" to run every 1.5 seconds. </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to schedule. Must be a key previously created by <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> or <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>How frequently to schedule. Must be &gt;= 0. seconds == 0 will ensure that this key is continously recomputed.</td></tr>
  </table>
  </dd>
</dl>
<p>All machines must call simultaneously. </p><dl class="section return"><dt>Returns</dt><dd>Returns true if key is found and seconds &gt;= 0, and false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01169">1169</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2445bcd6a03578f62a4b3ca471777da3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::elapsed_seconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the elapsed time in seconds since start was last called. </p>
<dl class="section return"><dt>Returns</dt><dd>elapsed time in seconds </dd></dl>

<p>Implements <a class="el" href="classgraphlab_1_1iengine.html#ab79866fc3e1a3e83cc0c022d1cababcb">graphlab::iengine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l01254">1254</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23b7178b34cf55f0ff27254df488d0e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1synchronous__engine.html">synchronous_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1iengine.html#a7f7635b47e0f3ac5afc7c9d3a334ed94">aggregator_type</a> * <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::get_aggregator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the distributed aggregator object. </p>
<p>This is currently used by the <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a> interface to implement the calls to aggregation.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the local aggregator. </dd></dl>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l01116">1116</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc4dc04bce51af81f928f00653fdb4fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::iteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current iteration number since start was last invoked. </p>
<dl class="section return"><dt>Returns</dt><dd>the current iteration </dd></dl>

<p>Reimplemented from <a class="el" href="classgraphlab_1_1iengine.html#a2bad0c682ba561287f648544cd0a0068">graphlab::iengine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l01258">1258</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8da8e299fd9bfc87e308d5ad571f35eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename EdgeMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::map_reduce_edges </td>
          <td>(</td>
          <td class="paramtype">EdgeMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each edge in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> call the map function on all edges in the graph. The return values are then summed together and the final result returned. The map function should only read data and should not make any modifications. <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the edge data, we would write a function which reads in each a edge, and returns the absolute value of the data on the edge. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_edge_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = engine.map_reduce_edges&lt;<span class="keywordtype">float</span>&gt;(absolute_edge_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_edge_data()</code> function on each edge in the graph. <code>absolute_edge_data()</code> reads the value of the edge and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<h3>Signalling</h3>
<p>Another common use for the <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> function is in signalling. Since the map function is passed a context, it can be used to perform signalling of edges for execution during a later <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">engine.start()</a> call.</p>
<p>For instance, the following code will signal the source vertex of each edge. </p><div class="fragment"><div class="line">graphlab::empty signal_source(engine_type::icontext_type&amp; context,</div>
<div class="line">                              <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  context.signal(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a5d8d51b99bfbfb361d7894a6d8e67ce1">source</a>());</div>
<div class="line">  <span class="keywordflow">return</span> graphlab::empty()</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that in this case, we are not interested in a reduction operation, and thus we return a graphlab::empty object. Calling: </p><div class="fragment"><div class="line">engine.map_reduce_edges&lt;graphlab::empty&gt;(signal_source);</div>
</div><!-- fragment --><p> will run <code>signal_source()</code> on all edges, signalling all source vertices.</p>
<h3>Relations</h3>
<p>The map function has the same structure as that in <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> and may be reused in an aggregator. This function is also very similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">graphlab::distributed_graph::map_reduce_edges()</a> with the difference that this takes a context and thus can be used to perform signalling. Finally <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00974">974</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b3fde48e79d248db7b815a313cd92e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename VertexMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::map_reduce_vertices </td>
          <td>(</td>
          <td class="paramtype">VertexMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each vertex in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> call the map function on all vertices in the graph. The return values are then summed together and the final result returned. The map function should only read the vertex data and should not make any modifications. <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the vertex data, we would write a function which reads in each a vertex, and returns the absolute value of the data on the vertex. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_vertex_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                           <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = engine.map_reduce_vertices&lt;<span class="keywordtype">float</span>&gt;(absolute_vertex_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_vertex_data()</code> function on each vertex in the graph. <code>absolute_vertex_data()</code> reads the value of the vertex and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<h3>Signalling</h3>
<p>Another common use for the <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> function is in signalling. Since the map function is passed a context, it can be used to perform signalling of vertices for execution during a later <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">engine.start()</a> call.</p>
<p>For instance, the following code will signal all vertices with value &gt;= 1 </p><div class="fragment"><div class="line">graphlab::empty signal_vertices(engine_type::icontext_type&amp; context,</div>
<div class="line">                                <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">if</span> (vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() &gt;= 1) context.signal(vertex);</div>
<div class="line">  <span class="keywordflow">return</span> graphlab::empty()</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that in this case, we are not interested in a reduction operation, and thus we return a graphlab::empty object. Calling: </p><div class="fragment"><div class="line">engine.map_reduce_vertices&lt;graphlab::empty&gt;(signal_vertices);</div>
</div><!-- fragment --><p> will run <code>signal_vertices()</code> on all vertices, signalling all vertices with value &lt;= 1</p>
<h3>Relations</h3>
<p>The map function has the same structure as that in <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> and may be reused in an aggregator. This function is also very similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">graphlab::distributed_graph::map_reduce_vertices()</a> with the difference that this takes a context and thus can be used to perform signalling. Finally <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00876">876</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8debef60159f9cd584ed57f6d5bfef4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::num_updates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the total number of updates (calls to apply) executed since start was last invoked. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of updates </dd></dl>

<p>Implements <a class="el" href="classgraphlab_1_1iengine.html#a647a3fa264ee6a9495c07dc746861dc0">graphlab::iengine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l01250">1250</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab945aad4bc982b507efc1ba55dba30d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals single a vertex with an optional message. </p>
<p>This function sends a message to particular vertex which will receive that message on start. The signal function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>Since signal is executed synchronously on all machines it should only be used to schedule a small set of vertices. The preferred method to signal a large set of vertices (e.g., all vertices that are a certain type) is to use either the vertex program init function or the aggregation framework. For example to signal all vertices that have a particular value one could write:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>bipartite_opt : </div>
<div class="line">  <span class="keyword">public</span> <a class="code" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt;graph_type, gather_type&gt; {</div>
<div class="line">  <span class="comment">// The user defined init function</span></div>
<div class="line">  <span class="keywordtype">void</span> init(<a class="code" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; context, <a class="code" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>&amp; vertex) {</div>
<div class="line">    <span class="comment">// Signal myself if I am a certain type</span></div>
<div class="line">    <span class="keywordflow">if</span>(vertex.data().on_left) context.signal(vertex);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// other vastly more interesting code</span></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>the vertex id to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to that vertex. The default message is sent if no message is provided. (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a47405eda2a7799df25d5a4d0ab4a9366">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0afe236029be943f870a77bd2a6b3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal all vertices with a particular message. </p>
<p>This function sends the same message to all vertices which will receive that message on start. The signal_all function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_all(); <span class="comment">// signal all vertices</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal_all(); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>The signal_all function is the most common way to send messages to the engine. For example in the pagerank application we want all vertices to be active on the first round. Therefore we would write:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;pagerank&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_all();</div>
<div class="line">engine.start();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a03414d20429d8b29e5091a6bcee137d2">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a86a7a9e2b10c0934d4c486c56c649c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal_vset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal a set of vertices with a particular message. </p>
<p>This function sends the same message to a set of vertices which will receive that message on start. The signal_vset function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_vset(vset); <span class="comment">// signal a subset of vertices</span></div>
</div><!-- fragment --><p><a class="el" href="classgraphlab_1_1iengine.html#a9c0afe236029be943f870a77bd2a6b3f" title="Signal all vertices with a particular message. ">signal_all()</a> is conceptually equivalent to:</p>
<div class="fragment"><div class="line">engine.signal_vset(graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vset</td><td>The set of vertices to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a6b208b86489a26f00e225efbdf2278de">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a53dc0f312b34a2f9ecf3a6790a95aeab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a> <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start execution of the synchronous engine. </p>
<p>The start function begins computation and does not return until there are no remaining messages or until max_iterations has been reached.</p>
<p>The <a class="el" href="classgraphlab_1_1synchronous__engine.html#a53dc0f312b34a2f9ecf3a6790a95aeab" title="Start execution of the synchronous engine. ">start()</a> function modifies the data graph through the vertex programs and so upon return the data graph should contain the result of the computation.</p>
<dl class="section return"><dt>Returns</dt><dd>The reason for termination </dd></dl>

<p>Implements <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">graphlab::iengine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l01271">1271</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a609d06d25b1e06c17a2d04e00d5b3bbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine</a>&lt; VertexProgram &gt;::total_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the total memory used by the entire distributed system. </p>
<dl class="section return"><dt>Returns</dt><dd>The total memory used in bytes. </dd></dl>

<p>Definition at line <a class="el" href="synchronous__engine_8hpp_source.html#l01263">1263</a> of file <a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ab681ecccc66ad8696f5a4d0103fa23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename EdgeMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::transform_edges </td>
          <td>(</td>
          <td class="paramtype">EdgeMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each edge in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> calls mapfunction on every edge in graph. The map function may make modifications to the data on the edge. <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To set each edge value to be the number of out-going edges of the target vertex, we may write the following: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_edge_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>() = edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>().<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a>: </p><div class="fragment"><div class="line">engine.transform_edges(set_edge_value);</div>
</div><!-- fragment --><p> will run the <code>set_edge_value()</code> function on each edge in the graph, setting its new value.</p>
<h3>Signalling</h3>
<p>Since the mapfunction is provided with a context, the mapfunction can also be used to perform signalling. For instance, the <code>set_edge_value</code> function above may be modified to set the value of the edge, but to also signal the target vertex.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_edge_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>() = edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>().<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">  context.signal(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, if the purpose of the function is to only signal without making modifications, <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> will be more efficient as this function will additionally perform distributed synchronization of modified data.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">graphlab::distributed_graph::transform_edges()</a> provide the same graph modification capabilities, but without a context and thus cannot perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns void. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01132">1132</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d9e97843604c45c08f71502b3494a7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename VertexMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::transform_vertices </td>
          <td>(</td>
          <td class="paramtype">VertexMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each vertex in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> calls mapfunction on every vertex in graph. The map function may make modifications to the data on the vertex. <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> must be called by all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To set each vertex value to be the number of out-going edges, we may write the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_vertex_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() = vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a>: </p><div class="fragment"><div class="line">engine.transform_vertices(set_vertex_value);</div>
</div><!-- fragment --><p> will run the <code>set_vertex_value()</code> function on each vertex in the graph, setting its new value.</p>
<h3>Signalling</h3>
<p>Since the mapfunction is provided with a context, the mapfunction can also be used to perform signalling. For instance, the <code>set_vertex_value</code> function above may be modified to set the value of the vertex, but to also signal the vertex if it has more than 5 outgoing edges.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_vertex_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() = vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>() &gt; 5) context.signal(vertex);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, if the purpose of the function is to only signal without making modifications, <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> will be more efficient as this function will additionally perform distributed synchronization of modified data.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">graphlab::distributed_graph::transform_vertices()</a> provide the same graph modification capabilities, but without a context and thus cannot perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns void. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01055">1055</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/engine/<a class="el" href="synchronous__engine_8hpp_source.html">synchronous_engine.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1synchronous__engine.html">synchronous_engine</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:28 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
