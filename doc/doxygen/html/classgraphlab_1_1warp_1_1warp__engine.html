<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::warp::warp_engine&lt; GraphType, MessageType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1warp_1_1warp__engine.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgraphlab_1_1warp_1_1warp__engine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::warp::warp_engine&lt; GraphType, MessageType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__warp.html">Warp System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The warp engine executed update functions asynchronously and can ensure mutual exclusion such that adjacent vertices are never executed simultaneously. The default mode is "factorized" consistency in which only individual gathers/applys/ scatters are guaranteed to be consistent, but this can be strengthened to provide full mutual exclusion.  
 <a href="classgraphlab_1_1warp_1_1warp__engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="warp__engine_8hpp_source.html">graphlab/engine/warp_engine.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aefb60417fd2e352891f62647d9646360"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefb60417fd2e352891f62647d9646360"></a>
typedef MessageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a></td></tr>
<tr class="memdesc:aefb60417fd2e352891f62647d9646360"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined message type used to signal neighboring vertex programs. <br /></td></tr>
<tr class="separator:aefb60417fd2e352891f62647d9646360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c1afc63ada7737e95f019aa13d53dd"><td class="memItemLeft" align="right" valign="top">typedef GraphType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#ae1c1afc63ada7737e95f019aa13d53dd">graph_type</a></td></tr>
<tr class="separator:ae1c1afc63ada7737e95f019aa13d53dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fe72fd293203845a3cadc2a9afdc2e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">graph_type::vertex_data_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a82fe72fd293203845a3cadc2a9afdc2e">vertex_data_type</a></td></tr>
<tr class="memdesc:a82fe72fd293203845a3cadc2a9afdc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data associated with each vertex in the graph.  <a href="#a82fe72fd293203845a3cadc2a9afdc2e">More...</a><br /></td></tr>
<tr class="separator:a82fe72fd293203845a3cadc2a9afdc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c2f88fd77470212062686039a1f4e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1distributed__graph.html#aa2b3177109bd0f7f217de016b1ce0f29">graph_type::edge_data_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a849c2f88fd77470212062686039a1f4e">edge_data_type</a></td></tr>
<tr class="memdesc:a849c2f88fd77470212062686039a1f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data associated with each edge in the graph.  <a href="#a849c2f88fd77470212062686039a1f4e">More...</a><br /></td></tr>
<tr class="separator:a849c2f88fd77470212062686039a1f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3e4370cc0bca7df56bad7a2b5e1a4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#acab3e4370cc0bca7df56bad7a2b5e1a4">vertex_type</a></td></tr>
<tr class="memdesc:acab3e4370cc0bca7df56bad7a2b5e1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent a vertex in the graph. See <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graphlab::distributed_graph::vertex_type</a> for details.  <a href="#acab3e4370cc0bca7df56bad7a2b5e1a4">More...</a><br /></td></tr>
<tr class="separator:acab3e4370cc0bca7df56bad7a2b5e1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af757a9f7fd39f6659d65a94ec8a25d00"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#af757a9f7fd39f6659d65a94ec8a25d00">edge_type</a></td></tr>
<tr class="memdesc:af757a9f7fd39f6659d65a94ec8a25d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent an edge in the graph. See <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graphlab::distributed_graph::edge_type</a> for details.  <a href="#af757a9f7fd39f6659d65a94ec8a25d00">More...</a><br /></td></tr>
<tr class="separator:af757a9f7fd39f6659d65a94ec8a25d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b0b52ac5085c68bbc32706dd83432"><td class="memItemLeft" align="right" valign="top">typedef context&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aa74b0b52ac5085c68bbc32706dd83432">context_type</a></td></tr>
<tr class="separator:aa74b0b52ac5085c68bbc32706dd83432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4c250b06b3317b326ce1b66ae083b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e4c250b06b3317b326ce1b66ae083b4"></a>
typedef context&#160;</td><td class="memItemRight" valign="bottom"><b>icontext_type</b></td></tr>
<tr class="separator:a7e4c250b06b3317b326ce1b66ae083b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9da2b52a9e48a7ddf11d84659630db3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9da2b52a9e48a7ddf11d84659630db3"></a>
typedef boost::function&lt; void(<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aa74b0b52ac5085c68bbc32706dd83432">context_type</a> &amp;, <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#acab3e4370cc0bca7df56bad7a2b5e1a4">vertex_type</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#af9da2b52a9e48a7ddf11d84659630db3">update_function_type</a></td></tr>
<tr class="memdesc:af9da2b52a9e48a7ddf11d84659630db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the update function. <br /></td></tr>
<tr class="separator:af9da2b52a9e48a7ddf11d84659630db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8d4b5f15cea57d6166d869135711fd1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a8d4b5f15cea57d6166d869135711fd1d">warp_engine</a> (<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;dc, <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#ae1c1afc63ada7737e95f019aa13d53dd">graph_type</a> &amp;graph, const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;opts=<a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>())</td></tr>
<tr class="separator:a8d4b5f15cea57d6166d869135711fd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24910dfd6b6d99142cc875997a419a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af24910dfd6b6d99142cc875997a419a2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_rpc_obj_id</b> ()</td></tr>
<tr class="separator:af24910dfd6b6d99142cc875997a419a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad103f8855ffa197d832080f20f371971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#ad103f8855ffa197d832080f20f371971">set_update_function</a> (<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#af9da2b52a9e48a7ddf11d84659630db3">update_function_type</a> update_function)</td></tr>
<tr class="separator:ad103f8855ffa197d832080f20f371971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa40613ea0fa65ab9f21f29efd406d8d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#afa40613ea0fa65ab9f21f29efd406d8d">num_updates</a> () const </td></tr>
<tr class="memdesc:afa40613ea0fa65ab9f21f29efd406d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the total number of updates (calls to apply) executed since start was last invoked.  <a href="#afa40613ea0fa65ab9f21f29efd406d8d">More...</a><br /></td></tr>
<tr class="separator:afa40613ea0fa65ab9f21f29efd406d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad228fe6ec32d8535812fced2e88d4072"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#ad228fe6ec32d8535812fced2e88d4072">elapsed_seconds</a> () const </td></tr>
<tr class="memdesc:ad228fe6ec32d8535812fced2e88d4072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the elapsed time in seconds since start was last called.  <a href="#ad228fe6ec32d8535812fced2e88d4072">More...</a><br /></td></tr>
<tr class="separator:ad228fe6ec32d8535812fced2e88d4072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ae27e1a3d43c52043a8cd98908e9d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3ae27e1a3d43c52043a8cd98908e9d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aa3ae27e1a3d43c52043a8cd98908e9d0">iteration</a> () const </td></tr>
<tr class="memdesc:aa3ae27e1a3d43c52043a8cd98908e9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not meaningful for the asynchronous engine. Returns -1. <br /></td></tr>
<tr class="separator:aa3ae27e1a3d43c52043a8cd98908e9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13705e9d5407a9472a67228b0b95c3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a13705e9d5407a9472a67228b0b95c3a1">signal</a> (vertex_id_type gvid, const <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a>())</td></tr>
<tr class="memdesc:a13705e9d5407a9472a67228b0b95c3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals single a vertex with an optional message.  <a href="#a13705e9d5407a9472a67228b0b95c3a1">More...</a><br /></td></tr>
<tr class="separator:a13705e9d5407a9472a67228b0b95c3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a3ca607b82b8d5a5de1d5c68ad5b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a36a3ca607b82b8d5a5de1d5c68ad5b96">signal_all</a> (const <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)</td></tr>
<tr class="memdesc:a36a3ca607b82b8d5a5de1d5c68ad5b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all vertices with a particular message.  <a href="#a36a3ca607b82b8d5a5de1d5c68ad5b96">More...</a><br /></td></tr>
<tr class="separator:a36a3ca607b82b8d5a5de1d5c68ad5b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5204f3ebb46545230eb79873eae75b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a5204f3ebb46545230eb79873eae75b12">signal_vset</a> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset, const <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)</td></tr>
<tr class="memdesc:a5204f3ebb46545230eb79873eae75b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a set of vertices with a particular message.  <a href="#a5204f3ebb46545230eb79873eae75b12">More...</a><br /></td></tr>
<tr class="separator:a5204f3ebb46545230eb79873eae75b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed832e04e05e8d8a18f3843d451758c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aed832e04e05e8d8a18f3843d451758c7">start</a> ()</td></tr>
<tr class="memdesc:aed832e04e05e8d8a18f3843d451758c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the engine execution.  <a href="#aed832e04e05e8d8a18f3843d451758c7">More...</a><br /></td></tr>
<tr class="separator:aed832e04e05e8d8a18f3843d451758c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2402741a090c78e9fbe0426fe27f7b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2402741a090c78e9fbe0426fe27f7b8"></a>
aggregator_type *&#160;</td><td class="memItemRight" valign="bottom"><b>get_aggregator</b> ()</td></tr>
<tr class="separator:ad2402741a090c78e9fbe0426fe27f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GraphType, typename MessageType = graphlab::empty&gt;<br />
class graphlab::warp::warp_engine&lt; GraphType, MessageType &gt;</h3>

<p>The warp engine executed update functions asynchronously and can ensure mutual exclusion such that adjacent vertices are never executed simultaneously. The default mode is "factorized" consistency in which only individual gathers/applys/ scatters are guaranteed to be consistent, but this can be strengthened to provide full mutual exclusion. </p>
<h3>Execution Semantics</h3>
<p>The update function is a simple user defined function of the type</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> update_function(engine_type::context&amp; context,</div>
<div class="line">                     <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">}</div>
</div><!-- fragment --><p>Based on a scheduler, update functions are executed on each scheduled vertex. All computation is performed from within fine-grained threads called fibers, which allows to create thousands of such fibers, thus hiding distributed communication latency.</p>
<p>Within the update function, All blocking warp functions such as graphlab::warp::map_reduce_neighborhood, graphlab::warp::transform_neighborhood, and graphlab::warp::broadcast_neighborhood can be used to make changes to the graph data, and to schedule other vertices for computation.</p>
<p>The engine stops when the scheduler is empty.</p>
<h3>Construction</h3>
<p>The warp engine is constructed by passing in a <a class="el" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> object which manages coordination between engine threads and a <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a> object which is the graph on which the engine should be run.</p>
<p>Computation is initiated by signaling vertices using either graphlab::warp_engine::signal or graphlab::warp_engine::signal_all. In either case all machines should invoke signal or signal all at the same time. Finally, computation is initiated by calling the graphlab::warp_engine::start function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__warp.html#ga642f56ae436a5825835ed2c0921732bb">warp::map_reduce_neighborhood()</a> </dd>
<dd>
<a class="el" href="group__warp.html#ga4d8e212ebc1f351fdcaaf5db2bb85b1c">warp::transform_neighborhood()</a> </dd>
<dd>
<a class="el" href="group__warp.html#gaee15548ed56f9ad746bcf1388b552c95">warp::broadcast_neighborhood()</a></dd></dl>
<h3>Example Usage</h3>
<p>The following is a simple example demonstrating how to use the engine: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>vertex_data {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>edge_data {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;vertex_data, edge_data&gt;</a> <a class="code" href="classgraphlab_1_1warp_1_1warp__engine.html#ae1c1afc63ada7737e95f019aa13d53dd">graph_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> graphlab::warp_engine&lt;graph_type&gt; engine_type;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> pagerank(engine_type::context&amp; context,</div>
<div class="line">              <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  ... </div>
<div class="line">} </div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Initialize control plain using mpi</span></div>
<div class="line">  graphlab::mpi_tools::init(argc, argv);</div>
<div class="line">  <a class="code" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> dc;</div>
<div class="line">  <span class="comment">// Parse command line options</span></div>
<div class="line">  <a class="code" href="classgraphlab_1_1command__line__options.html">graphlab::command_line_options</a> clopts(<span class="stringliteral">&quot;PageRank algorithm.&quot;</span>);</div>
<div class="line">  std::string graph_dir;</div>
<div class="line">  clopts.attach_option(<span class="stringliteral">&quot;graph&quot;</span>, graph_dir,</div>
<div class="line">                       <span class="stringliteral">&quot;The graph file.&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span>(!clopts.parse(argc, argv)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Error in parsing arguments.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  graph_type graph(dc, clopts);</div>
<div class="line">  graph.load_structure(graph_dir, <span class="stringliteral">&quot;tsv&quot;</span>);</div>
<div class="line">  graph.finalize();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;#vertices: &quot;</span> &lt;&lt; graph.num_vertices()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #edges:&quot;</span> &lt;&lt; graph.num_edges() &lt;&lt; std::endl;</div>
<div class="line">  engine_type engine(dc, graph, clopts);</div>
<div class="line">  engine.set_update_function(pagerank);</div>
<div class="line">  engine.signal_all();</div>
<div class="line">  engine.start();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Runtime: &quot;</span> &lt;&lt; engine.elapsed_seconds();</div>
<div class="line">  graphlab::mpi_tools::finalize();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="engineopts"></a>Engine Options </h1>
<p>The warp engine supports several engine options which can be set as command line arguments using <code>&ndash;engine_opts</code> :</p>
<ul>
<li><b>timeout</b> (default: infinity) Maximum time in seconds the engine will run for. The actual runtime may be marginally greater as the engine waits for all threads and processes to flush all active tasks before returning. </li>
<li><b>factorized</b> (default: true) Set to true to weaken the consistency model to factorized consistency where only individual gather/apply/scatter calls are guaranteed to be locally consistent. Can produce massive increases in throughput at a consistency penalty. </li>
<li><b>nfibers</b> (default: 10000) Number of fibers to use </li>
<li><b>stacksize</b> (default: 16384) Stacksize of each fiber. </li>
</ul>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00176">176</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa74b0b52ac5085c68bbc32706dd83432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef context <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aa74b0b52ac5085c68bbc32706dd83432">context_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the context. </p>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00451">451</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a849c2f88fd77470212062686039a1f4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1distributed__graph.html#aa2b3177109bd0f7f217de016b1ce0f29">graph_type::edge_data_type</a> <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a849c2f88fd77470212062686039a1f4e">edge_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of data associated with each edge in the graph. </p>
<p>The edge data type must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00202">202</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af757a9f7fd39f6659d65a94ec8a25d00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#af757a9f7fd39f6659d65a94ec8a25d00">edge_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to represent an edge in the graph. See <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graphlab::distributed_graph::edge_type</a> for details. </p>
<p>The edge type contains the function <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">graphlab::distributed_graph::edge_type::data</a> which returns a reference to the edge data. In addition the edge type contains the function <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a5d8d51b99bfbfb361d7894a6d8e67ce1">graphlab::distributed_graph::edge_type::source</a> and <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">graphlab::distributed_graph::edge_type::target</a>. </p>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00229">229</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae1c1afc63ada7737e95f019aa13d53dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef GraphType <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#ae1c1afc63ada7737e95f019aa13d53dd">graph_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the graph associated with this engine. </p>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00188">188</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82fe72fd293203845a3cadc2a9afdc2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">graph_type::vertex_data_type</a> <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a82fe72fd293203845a3cadc2a9afdc2e">vertex_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of data associated with each vertex in the graph. </p>
<p>The vertex data type must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00195">195</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acab3e4370cc0bca7df56bad7a2b5e1a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#acab3e4370cc0bca7df56bad7a2b5e1a4">vertex_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to represent a vertex in the graph. See <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graphlab::distributed_graph::vertex_type</a> for details. </p>
<p>The vertex type contains the function <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">graphlab::distributed_graph::vertex_type::data</a> which returns a reference to the vertex data as well as other functions like <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a485616c8965fcd995cb705722b6b4757">graphlab::distributed_graph::vertex_type::num_in_edges</a> which returns the number of in edges. </p>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00216">216</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8d4b5f15cea57d6166d869135711fd1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::<a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">warp_engine</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#ae1c1afc63ada7737e95f019aa13d53dd">graph_type</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an asynchronous consistent distributed engine. The number of threads to create are read from <a class="el" href="classgraphlab_1_1graphlab__options.html#a8dae0062a8b67f8066a20f15c54e6d3e">opts.get_ncpus()</a>. The scheduler to construct is read from <a class="el" href="classgraphlab_1_1graphlab__options.html#a5e2149acc0d4e2da23e21d54197c5e54">opts.get_scheduler_type()</a>. The default scheduler is the queued_fifo scheduler. For details on the scheduler types </p><dl class="section see"><dt>See also</dt><dd>scheduler_types</dd></dl>
<p>See the <a href="#engineopts">main class documentation</a> for the available engine options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>Distributed controller to associate with </td></tr>
    <tr><td class="paramname">graph</td><td>The graph to schedule over. The graph must be fully constructed and finalized. </td></tr>
    <tr><td class="paramname">opts</td><td>A <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab::graphlab_options</a> object containing options and parameters for the scheduler and the engine. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00580">580</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad228fe6ec32d8535812fced2e88d4072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::elapsed_seconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the elapsed time in seconds since start was last called. </p>
<dl class="section return"><dt>Returns</dt><dd>elapsed time in seconds </dd></dl>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00734">734</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa40613ea0fa65ab9f21f29efd406d8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::num_updates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the total number of updates (calls to apply) executed since start was last invoked. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of updates </dd></dl>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00720">720</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad103f8855ffa197d832080f20f371971"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::set_update_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#af9da2b52a9e48a7ddf11d84659630db3">update_function_type</a>&#160;</td>
          <td class="paramname"><em>update_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the update function to use for execution. The update function must be of the type void(context_type&amp;, vertex_type), but more generally, may be a boost::function&lt;void(context_type&amp;, vertex_type)&gt; </p>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00709">709</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13705e9d5407a9472a67228b0b95c3a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::signal </td>
          <td>(</td>
          <td class="paramtype">vertex_id_type&#160;</td>
          <td class="paramname"><em>gvid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals single a vertex with an optional message. </p>
<p>This function sends a message to particular vertex which will receive that message on start. The signal function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line">graphlab::warp_engine&lt;graph_type&gt; engine(dc, graph, opts);</div>
<div class="line">engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line">graphlab::warp_engine&lt;graph_type&gt; engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>Since signal is executed synchronously on all machines it should only be used to schedule a small set of vertices. The preferred method to signal a large set of vertices (e.g., all vertices that are a certain type) is to use either the vertex program init function or the aggregation framework. For example to signal all vertices that have a particular value one could write:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>bipartite_opt : </div>
<div class="line">  <span class="keyword">public</span> <a class="code" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt;graph_type, gather_type&gt; {</div>
<div class="line">  <span class="comment">// The user defined init function</span></div>
<div class="line">  <span class="keywordtype">void</span> init(icontext_type&amp; context, <a class="code" href="classgraphlab_1_1warp_1_1warp__engine.html#acab3e4370cc0bca7df56bad7a2b5e1a4">vertex_type</a>&amp; vertex) {</div>
<div class="line">    <span class="comment">// Signal myself if I am a certain type</span></div>
<div class="line">    <span class="keywordflow">if</span>(vertex.data().on_left) context.signal(vertex);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// other vastly more interesting code</span></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>the vertex id to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to that vertex. The default message is sent if no message is provided. (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00894">894</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36a3ca607b82b8d5a5de1d5c68ad5b96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::signal_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal all vertices with a particular message. </p>
<p>This function sends the same message to all vertices which will receive that message on start. The signal_all function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line">graphlab::warp_engine&lt;graph_type&gt; engine(dc, graph, opts);</div>
<div class="line">engine.signal_all(); <span class="comment">// signal all vertices</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line">graphlab::warp_engine&lt;graph_type&gt; engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal_all(); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>The signal_all function is the most common way to send messages to the engine. For example in the pagerank application we want all vertices to be active on the first round. Therefore we would write:</p>
<div class="fragment"><div class="line">graphlab::warp_engine&lt;graph_type&gt; engine(dc, graph, opts);</div>
<div class="line">engine.signal_all();</div>
<div class="line">engine.start();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00936">936</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5204f3ebb46545230eb79873eae75b12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::signal_vset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#aefb60417fd2e352891f62647d9646360">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal a set of vertices with a particular message. </p>
<p>This function sends the same message to a set of vertices which will receive that message on start. The signal_vset function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line">graphlab::warp_engine&lt;graph_type&gt; engine(dc, graph, opts);</div>
<div class="line">engine.signal_vset(vset); <span class="comment">// signal a subset of vertices</span></div>
</div><!-- fragment --><p><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html#a36a3ca607b82b8d5a5de1d5c68ad5b96" title="Signal all vertices with a particular message. ">signal_all()</a> is conceptually equivalent to:</p>
<div class="fragment"><div class="line">engine.signal_vset(graph.complete_set());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vset</td><td>The set of vertices to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l00967">967</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed832e04e05e8d8a18f3843d451758c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a> <a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">graphlab::warp::warp_engine</a>&lt; GraphType, MessageType &gt;::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the engine execution. </p>
<p>This function starts the engine and does not return until the scheduler has no tasks remaining.</p>
<dl class="section return"><dt>Returns</dt><dd>the reason for termination </dd></dl>

<p>Definition at line <a class="el" href="warp__engine_8hpp_source.html#l01281">1281</a> of file <a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/engine/<a class="el" href="warp__engine_8hpp_source.html">warp_engine.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><b>warp</b></li><li class="navelem"><a class="el" href="classgraphlab_1_1warp_1_1warp__engine.html">warp_engine</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:28 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
