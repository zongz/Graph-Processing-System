<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: Factor Graph Toolkit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('factor_graphs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Factor Graph Toolkit </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Factor Graph toolkit (defined in toolkits/graphical_models/factors/factor_graph.hpp) is an abstraction layer which is able to translate a factor graph into a graphlab distributed-graph.</p>
<div class="image">
<img src="factor_graph_to_distributed_graph.png" alt="factor_graph_to_distributed_graph.png"/>
</div>
<p>A <a href="http://en.wikipedia.org/wiki/Factor_graph">factor graph</a> is a bipartite graph composed of two types of vertices: variable nodes and factor nodes.</p>
<p>A variable specifies a unary discrete <a href="http://en.wikipedia.org/wiki/Probability_mass_function">probabiltiy mass function</a> (PFM) over a set of labels. A variable's PMF is assumed to be defined by a <code>class dense_table</code> in which each label has a corresponding probability.</p>
<p>A factor specifies a discrete joint probability mass function over a set of neighboring variables which form the factor's domain. The n-D PMF is defined by either a <code>class dense_table</code> or <code>class sparse_table</code> (which is basically just an N-d matrix and is defined in toolkits/graphical_models/factors/dense_table.hpp and sparse_table.hpp), in which each label has a corresponding log probability (we use the log of the belief value for numerical stability). NOTE When constructing an n-D table, take care to understand the sorting order of the values in the table and that expected by the various accessors/constructors of the class.</p>
<p>Inference in a factor graph is commonly performed using <a href="http://en.wikipedia.org/wiki/Belief_propagation">loopy belief propagation</a> (LBP), a well-known message-passing algorithm. The vertex program specified in <code>bp_vertex_program.cpp</code> defines the max-sum variant of belief propagation (although sum-product is also supported). Messages between variables and factors are always dense 1-d tables.</p>
<p>Belief propagation and factor graphs are general tools that have applications in a variety of domains.</p>
<p>While GraphLab proper supports several common portable graph formats, such as tsv, the Factor Graph toolkit instead defines a factor graph programatically. The typical usasge of the <code>class factor_graph</code> interface would consist of:</p>
<ol type="1">
<li>adding a set of variables to the factor graph by using add_variable(),</li>
<li>defining the prior distribution over each variable by using one of the prior related methods (such as set_prior_for_variable(...) )</li>
<li>adding a set of factors to the graph by using add_factor(...),</li>
<li>constructing the distributed graph using make_bp_graph(),</li>
<li>running belief propagation on the distributed graph to propagate the evidence across the graph (outside the scope of this interface), and</li>
<li>loading the results using pull_beliefs_for_variables(...).</li>
</ol>
<p>The resulting belief for a variable can be queried using belief_for_variable(var).logP() (i.e., once the evidence has been propagated across the distributed graph and the results pulled back into the factor_graph using pull_beliefs_for_variables() ).</p>
<h1><a class="anchor" id="factor_graph_structured_prediction"></a>
A Factor Graph for Structured Prediction</h1>
<p>We have implemented the <a class="el" href="graphical_models.html#structured_prediction">Structured Prediction</a> example using a factor graph. We can run the structured prediction application on the synthetic image like this: </p><pre class="fragment">&gt; ./denoise --damping=.3 
</pre><p>The structure prediction application applies the Loopy Belief propagation algorithm to a factor graph encoding encoding the classic <a href="http://en.wikipedia.org/wiki/Potts_model">Potts Model</a>.</p>
<p>Once the application terminates, the final predictions will be stored in denoised.png.</p>
<div class="image">
<img src="denoised.jpeg" alt="denoised.jpeg"/>
</div>
<p>Not bad! Given the synthetic noisy image (noisy_img.png), denoised.png is very similar to the true underlying image (orig_img.png) that we would like to recover.</p>
<h2><a class="anchor" id="structured_predictions_options"></a>
Options</h2>
<ul>
<li><b>&ndash;help</b> Display the help message describing the list of options.</li>
</ul>
<ul>
<li><b>&ndash;damping</b> (Optional, Default 0.1) The amount of damping to use. Damping can help ensure that the algorithm converges. Larger damping values lead to slower but more reliable convergence.</li>
</ul>
<ul>
<li><b>&ndash;engine</b> (Optional, Default: asynchronous) The engine type to use when executing the vertex-programs<ul>
<li><b>synchronous</b>: All LoopyBP updates are run at the same time (Synchronous BP). This engine exposes greater parallelism but is less computationally efficient.</li>
<li><b>asynchronous</b>: LoopyBP updates are run asynchronous with priorities (Residual BP). This engine is has greater overhead and exposes less parallelism but can substantially improve the rate over convergence.</li>
</ul>
</li>
</ul>
<ul>
<li><b>&ndash;ncpus</b> (Optional, Default 2) The number of local computation threads to use on each machine. This should typically match the number of physical cores.</li>
</ul>
<ul>
<li><b>&ndash;scheduler</b> (Optional, Default sweep) The scheduler to use when running with the asynchronous engine. The default is typically sufficient.</li>
</ul>
<ul>
<li><b>&ndash;engine_opts</b> (Optional, Default empty) Any additional engine options. See <b>&ndash;engine_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;graph_opts</b> (Optional, Default empty) Any additional graph options. See <b>&ndash;graph_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;scheduler_opts</b> (Optional, Default empty) Any additional scheduler options. See <b>&ndash;scheduler_help</b> for a list of options.</li>
</ul>
<h1><a class="anchor" id="Example"></a>
Example</h1>
<p>The test file toolkits/graphical_models/factors/tests/test_bool_var/test_cat_bool_var.cpp creates two variables, foo and bool_var_b, each with two states, connected to a 2x2 factor (there is also a unary evidence factor (prior) attached to bool_var_b). Visually, this looks like</p>
<pre class="fragment"> bool_obs (factor)
     |
     |
 bool_var_b (variable : {false, true})
     |
     |
 factor
 cat/fp-tp |  false | true |
 ----------|--------|------|
 state1    |  0.1   |  0.9 |  ---  foo (variable : {state1, false pos})
 ----------|--------|------|
 false pos |  0.8   |  0.2 |
 ---------------------------
 joint belief values (cbj)
</pre><p>This factor graph, creates two variables, foo and bool_var_b, each with two states. The variables are related to each other through the factor node, cbj. (bool_obs is also a unary evidence factor (prior) attached to bool_var_b.)</p>
<p>A factor or variable's probability mass function (PMF) is specified by a dense_table (which is basically just an N-d matrix and is defined in toolkits/graphical_models/factors/dense_table.hpp) in which each label has a corresponding log probability (we use the log of the belief value for numerical stability). A variable is always a 1D dense_table. Factor cbj is a 2D dense_table with a domain that spans the cross product of domains' the two variables.)</p>
<p>The nlog belief values in the table for this example are arbitrary. You can set them to whatever your discrete probability mass function is using one of dense_table::logP(size_t), dense_table::logP(discrete_assignment), or one of the specialized constructors. (A discrete_assignment is a subindex over a domain (in Matlab, for example, to access element (1,2) in an array, you would do myArray(1,2); analogously, a discrete_assignment specifies this assignment. I can explain these in more detail if you'l like)).</p>
<p>Once the evidence has been propagated across the distributed graph and the results pulled back into the factor graph using factor_graph.hpp::pull_beliefs_for_variables(), the resulting marginal distribution for the variable var can be queried using factor_graph.hpp::belief_for_variable(var), which returns a 1D dense_table. Then, you can find the most likely value in the distribution using dense_table::max_index(), which returns the linear index of the largest value. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="toolkits.html">GraphLab Toolkits</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:26 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
