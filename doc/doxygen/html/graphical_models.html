<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: Graphical Models</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('graphical_models.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Graphical Models </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Graphical Models toolkit contains a collection of applications for reasoning about structured noisy data. <a href="http://en.wikipedia.org/wiki/Graphical_model">Graphical models</a> provide a compact interpretable representation of complex statistical phenomena by encoding random variables as vertices in a graph and relationships between those variables as edges. Given a graphical model representation, we can then apply <a href="http://en.wikipedia.org/wiki/Bayes%27_rule">Bayes rule</a> to quantitatively infer properties of some variables given observations about others. Graphical models also provide the unique ability to quantify uncertainty in our prediction.</p>
<h1><a class="anchor" id="distributed_dual_decomposition"></a>
Distributed Dual Decomposition</h1>
<p>Dual Decomposition (DD), also called Lagrangian Relaxation, is a powerful technique with a rich history in Operations Research. DD solves a relaxation of difficult optimization problems by decomposing them into simpler subproblems, solving these simpler subproblems independently and then combining these solutions into an approximate global solution.</p>
<p>More details about DD for solving Maximum A Posteriori (MAP) inference problems in Markov Random Fields (MRFs) can be found in the following:</p>
<pre class="fragment">D. Sontag, A. Globerson, T. Jaakkola. 
Introduction to Dual Decomposition for Inference. 
Optimization for Machine Learning, editors S. Sra, S. Nowozin, and S. J. Wright: MIT Press, 2011.
</pre><p>Implemented by <a href="http://www.cs.cmu.edu/~afm/">Andre' F. T. Martins</a> and <a href="http://filebox.ece.vt.edu/~dbatra/">Dhruv Batra</a>.</p>
<h2><a class="anchor" id="running_ddd"></a>
Running DDD</h2>
<p>The input MRF graph is assumed to be in the standard <a href="http://www.cs.huji.ac.il/project/PASCAL/fileFormat.php">UAI file format</a>. For example a 3x3 grid MRF can be found here: <a href="http://www.cs.huji.ac.il/project/PASCAL/examples/grid3x3.uai">grid3x3.uai</a>.</p>
<p>The program can be run like this:</p>
<pre class="fragment">&gt; ./dd --graph grid3x3.uai 
</pre><p>Other arguments are:</p>
<ul>
<li><b>&ndash;help</b> Display the help message describing the list of options.</li>
</ul>
<ul>
<li><b>&ndash;output</b> The output directory in which to save the final predictions.</li>
</ul>
<ul>
<li><b>&ndash;dualimprovthres</b> (Optional, default 0.00001) The amount of change in dual objective (in log-space) that will be tolerated at convergence.</li>
</ul>
<ul>
<li><b>&ndash;pdgapthres</b> (Optional, default 0.1) The tolerance level for zero primal-dual gap.</li>
</ul>
<ul>
<li><b>&ndash;maxiter</b> (Optional, default 10000) The maximum no. of dual update iterations.</li>
</ul>
<ul>
<li><b>&ndash;engine</b> (Optional, Default: asynchronous) The engine type to use when executing the vertex-programs<ul>
<li><b>synchronous</b>: All LoopyBP updates are run at the same time (Synchronous BP). This engine exposes greater parallelism but is less computationally efficient.</li>
<li><b>asynchronous</b>: LoopyBP updates are run asynchronous with priorities (Residual BP). This engine is has greater overhead and exposes less parallelism but can substantially improve the rate over convergence.</li>
</ul>
</li>
</ul>
<ul>
<li><b>&ndash;ncpus</b> (Optional, Default 2) The number of local computation threads to use on each machine. This should typically match the number of physical cores.</li>
</ul>
<ul>
<li><b>&ndash;scheduler</b> (Optional, Default sweep) The scheduler to use when running with the asynchronous engine. The default is typically sufficient.</li>
</ul>
<ul>
<li><b>&ndash;engine_opts</b> (Optional, Default empty) Any additional engine options. See <b>&ndash;engine_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;graph_opts</b> (Optional, Default empty) Any additional graph options. See <b>&ndash;graph_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;scheduler_opts</b> (Optional, Default empty) Any additional scheduler options. See <b>&ndash;scheduler_help</b> for a list of options.</li>
</ul>
<h1><a class="anchor" id="structured_prediction"></a>
Structured Prediction</h1>
<p>Currently the Graphical Models toolkit contains a discrete structured prediction application which can be applied to a wide range of prediction tasks where we have prior noisy predictions for a large number of variables (e.g., political inclination of each user or article) and a graph encoding similarity or dissimilarity relationships between those variables (e.g., friends share similar political inclinations). The structured prediction application then infers the posterior distribution for each random variable improving upon the prior prediction and providing a measure of uncertainty.</p>
<h2><a class="anchor" id="structured_prediction_example"></a>
Structured Prediction Example</h2>
<p>For example, supposed we had the recent posts for each user in a large social network. Based on frequency each user mentions a conservative or liberal news item we might be able to construct a noisy prior estimate of their political inclination. A user with no posts may have a prior of 0.5 conservative and 0.5 liberal while another user that frequently mentions a conservative pundit might have a prior of 0.8 conservative and 0.2 liberal. If a user with no posts is friends with a user that frequently mentions conservative news items, then it is more likely that the user with no posts is also conservative. More generally we can leverage the social network to improve our prediction for each user by examining not only their immediate friends but also the community around each user. This exactly what the structured prediction application accomplishes. The output of the structured prediction application is the posterior estimates for each user.</p>
<h2><a class="anchor" id="structured_prediction_model"></a>
The Structured Prediction Model</h2>
<p>The structure prediction application applies the <a href="http://en.wikipedia.org/wiki/Belief_propagation">Loopy Belief propagation (LBP)</a> algorithm to a pair-wise <a href="http://en.wikipedia.org/wiki/Markov_random_field">Markov Random Field</a> encoding the classic <a href="http://en.wikipedia.org/wiki/Potts_model">Potts Model</a>. The joint probability mass function is given by:</p>
<div class="image">
<img src="potts_model.png" alt="potts_model.png"/>
</div>
<p>The edge weight <code>w</code> is obtained from the graph file but defaults to w=1 if no edge weight is provided. The smoothing paramater <code>SMOOTHING</code> can be set as a command line argument and controls the general smoothing.</p>
<h2><a class="anchor" id="loopy_bp_algorithm"></a>
Loopy BP Algorithm</h2>
<p>The structured prediction application uses an <a href="http://en.wikipedia.org/wiki/Belief_propagation">Loopy BP</a> approximate inference algorithm to estimate the posterior marginals. The Loopy BP algorithm iteratively estimates a set of edge parameters commonly referred to as "messages." The structured prediction application uses the asynchronous residual variant of the Loopy BP algorithm.</p>
<h2><a class="anchor" id="structured_prediction_data"></a>
Synthetic Data</h2>
<p>To demonstrate the power of the structured prediction application we have provided a synthetic dataset generator. To use the synthetic generator simply build and run:</p>
<pre class="fragment">./synthetic_image_data 
</pre><p>This will create the synthetic noisy image:</p>
<div class="image">
<img src="noisy_img.jpeg" alt="noisy_img.jpeg"/>
</div>
<p>as well as the true underlying image that we would like to recover:</p>
<div class="image">
<img src="orig_img.jpeg" alt="orig_img.jpeg"/>
</div>
<p>Each pixel in the image corresponds to a random variable whose unknown is the true pixel color. The goal is to use the neighborhood of each pixel to improve our estimate and resolve the original image. The <code>synthetic_image_data</code> application will also create the two input files needed to run the structured prediction application. The first is synthetic prior estimates for each pixel. Each row begins with the random variable id followed by the prior probability distribution for that random variable. Notice that the prior assigns half of the mass to the observed pixel value and the remaining mass to the other candidate pixel values.</p>
<pre class="fragment">&gt; head synth_vdata.tsv 
0 0.125 0.5 0.125 0.125 0.125
1 0.125 0.125 0.125 0.125 0.125
2 0.125 0.125 0.5 0.125 0.125
3 0.125 0.125 0.125 0.125 0.5
4 0.125 0.125 0.125 0.125 0.5
</pre><p>The second <code>synth_edata.tsv</code> file contains the graph structure with each line corresponding to an edge. Here we do not assign edge weights (and so the default weight of 1) will be used on all edges. Had we wanted to use weighted edges we would have added the weight value after each edge.</p>
<pre class="fragment">&gt; head synth_edata.tsv 
0 65536
0 1
1 65537
1 2
2 65538
2 3
</pre><p>We can now run the structured prediction application on the synthetic image.</p>
<pre class="fragment">&gt; ./lbp_structured_prediction --prior synth_vdata.tsv --graph synth_edata.tsv \
                          --output posterior_vdata.tsv
</pre><p>Once the application terminates the final predictions will be stored in the sequence of files <code>posterior_vdata.tsv_X_of_X</code> in exactly the same format as the prior <code>synth_vdata.tsv</code>.</p>
<pre class="fragment">&gt; ls -l posterior_vdata.tsv_*
posterior_vdata.tsv_1_of_2
posterior_vdata.tsv_2_of_2
</pre><p>in the format:</p>
<pre class="fragment">&gt; head posterior_vdata.tsv_1_of_2 
0 0.0237064 0.0947784 0.0245065 0.0323516 0.824657
1 0.00886895  0.0176509 0.0114683 0.0112453 0.950767
2 0.00402855  0.00489077  0.0161093 0.00426689  0.970705
3 0.00088747  0.00091284  0.00124409  0.000894688 0.996061
4 0.000696577 0.000695895 0.000706134 0.000695375 0.997206
5 0.000740404 0.000705437 0.000706437 0.000705451 0.997142
</pre><p>To visualize the predictions for the synthetic application we run:</p>
<pre class="fragment">&gt; cat posterior_vdata.tsv_* | ./synthetic_image_data --pred pred_image.jpeg
Create a synthetic noisy image.
Reading in predictions
nrows: 200
ncols: 200
minp:  0
maxp:  4
</pre><p>If we then open <code>pred_image.jpeg</code> we get:</p>
<div class="image">
<img src="pred_img.jpeg" alt="pred_img.jpeg"/>
</div>
<p>Not bad!</p>
<h2><a class="anchor" id="structured_predictions_options"></a>
Options</h2>
<ul>
<li><b>&ndash;help</b> Display the help message describing the list of options.</li>
</ul>
<ul>
<li><b>&ndash;prior</b> The prior vertex data file.</li>
</ul>
<ul>
<li><b>&ndash;output</b> The output directory/file_prefix in which to save the final predictions.</li>
</ul>
<ul>
<li><b>&ndash;graph</b> The graph describing the random variable dependency structure as well as optional weights.</li>
</ul>
<ul>
<li><b>&ndash;smoothing</b> (Optional, Default 2) The default smoothing parameter. Larger values imply stronger relationships between adjacent random variables in the graph.</li>
</ul>
<ul>
<li><b>&ndash;damping</b> (Optional, Default 0.1) The amount of damping to use. Damping can help ensure that the algorithm converges. Larger damping values lead to slower but more reliable convergence.</li>
</ul>
<ul>
<li><b>&ndash;tol</b> (Optional, default 0.01) The amount of change in parameter values (in log-space) that will be tolerated at convergence.</li>
</ul>
<ul>
<li><b>&ndash;map</b> (Optional, default false) If set to true the maximizing assignment will be returned in the output instead of the distribution.</li>
</ul>
<ul>
<li><b>&ndash;engine</b> (Optional, Default: asynchronous) The engine type to use when executing the vertex-programs<ul>
<li><b>synchronous</b>: All LoopyBP updates are run at the same time (Synchronous BP). This engine exposes greater parallelism but is less computationally efficient.</li>
<li><b>asynchronous</b>: LoopyBP updates are run asynchronous with priorities (Residual BP). This engine is has greater overhead and exposes less parallelism but can substantially improve the rate over convergence.</li>
</ul>
</li>
</ul>
<ul>
<li><b>&ndash;ncpus</b> (Optional, Default 2) The number of local computation threads to use on each machine. This should typically match the number of physical cores.</li>
</ul>
<ul>
<li><b>&ndash;scheduler</b> (Optional, Default sweep) The scheduler to use when running with the asynchronous engine. The default is typically sufficient.</li>
</ul>
<ul>
<li><b>&ndash;engine_opts</b> (Optional, Default empty) Any additional engine options. See <b>&ndash;engine_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;graph_opts</b> (Optional, Default empty) Any additional graph options. See <b>&ndash;graph_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;scheduler_opts</b> (Optional, Default empty) Any additional scheduler options. See <b>&ndash;scheduler_help</b> for a list of options. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="toolkits.html">GraphLab Toolkits</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:26 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
