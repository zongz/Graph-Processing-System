<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacegraphlab.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">graphlab Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegraphlab_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab_1_1random.html">random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1any.html">any</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consensus.html">async_consensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements a distributed consensus algorithm which waits for global completion of all computation/RPC events on a given object.  <a href="classgraphlab_1_1async__consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html">async_consistent_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The asynchronous consistent engine executed vertex programs asynchronously and can ensure mutual exclusion such that adjacent vertices are never executed simultaneously. The default mode is "factorized" consistency in which only individual gathers/applys/ scatters are guaranteed to be consistent, but this can be strengthened to provide full mutual exclusion.  <a href="classgraphlab_1_1async__consistent__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1atomic__add__vector2_3_01graphlab_1_1empty_01_4.html">atomic_add_vector2&lt; graphlab::empty &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1binary__input__stream.html">binary_input_stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1binary__output__stream.html">binary_output_stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1blob.html">blob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1block__linked__list.html">block_linked_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1blocking__queue.html">blocking_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a blocking queue useful for producer/consumer models.  <a href="classgraphlab_1_1blocking__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1buffered__exchange.html">buffered_exchange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1cache__line__pad.html">cache_line_pad</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1cancellable__barrier.html">cancellable_barrier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1char__counting__sink.html">char_counting_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1circular__char__buffer__sink.html">circular_char_buffer_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1circular__char__buffer__source.html">circular_char_buffer_source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1command__line__options.html">command_line_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GraphLab command line options class helps parse basic command line options for the GraphLab framework as well as user applications.  <a href="classgraphlab_1_1command__line__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1conditional.html">conditional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1context.html">context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context object mediates the interaction between the vertex program and the graphlab execution environment and implements the <a class="el" href="classgraphlab_1_1icontext.html">icontext</a> interface.  <a href="classgraphlab_1_1context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1csr__storage.html">csr_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1cuckoo__map.html">cuckoo_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1cuckoo__map__pow2.html">cuckoo_map_pow2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1cuckoo__set__pow2.html">cuckoo_set_pow2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dc__dist__object.html">dc_dist_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a class with its own distributed communication context, allowing instances of the class to communicate with other remote instances.  <a href="classgraphlab_1_1dc__dist__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1dc__init__param.html">dc_init_param</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed control constructor parameters.  <a href="structgraphlab_1_1dc__init__param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dense__bitset.html">dense_bitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dht.html">dht</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__constrained__oblivious__ingress.html">distributed_constrained_oblivious_ingress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ingress object assigning edges using randoming hash function.  <a href="classgraphlab_1_1distributed__constrained__oblivious__ingress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__constrained__random__ingress.html">distributed_constrained_random_ingress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ingress object assigning edges using randoming hash function.  <a href="classgraphlab_1_1distributed__constrained__random__ingress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distributed control object is primary means of communication between the distributed GraphLab processes.  <a href="classgraphlab_1_1distributed__control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html">distributed_graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A directed graph datastructure which is distributed across multiple machines.  <a href="classgraphlab_1_1distributed__graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__identity__ingress.html">distributed_identity_ingress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ingress object assigning edges to the loading machine itself.  <a href="classgraphlab_1_1distributed__identity__ingress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__oblivious__ingress.html">distributed_oblivious_ingress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ingress object assigning edges using randoming hash function.  <a href="classgraphlab_1_1distributed__oblivious__ingress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__random__ingress.html">distributed_random_ingress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ingress object assigning edges using randoming hash function.  <a href="classgraphlab_1_1distributed__random__ingress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dynamic__block.html">dynamic_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1dynamic__csr__storage.html">dynamic_csr_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1event__log__thread__local__type.html">event_log_thread_local_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1execution__status.html">execution_status</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the reasons for execution completion.  <a href="structgraphlab_1_1execution__status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fiber__async__consensus.html">fiber_async_consensus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements a distributed consensus algorithm which waits for global completion of all computation/RPC events on a given object.  <a href="classgraphlab_1_1fiber__async__consensus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fiber__blocking__queue.html">fiber_blocking_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a blocking queue useful for producer/consumer models. Similar to the <a class="el" href="classgraphlab_1_1blocking__queue.html">blocking_queue</a>, but requires all threads waiting on the queue to be fibers. Also only supports the basic wait on dequeue operation, and not the other timed_wait, or wait_until_empty operations supported by the <a class="el" href="classgraphlab_1_1blocking__queue.html">blocking_queue</a>.  <a href="classgraphlab_1_1fiber__blocking__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fiber__buffered__exchange.html">fiber_buffered_exchange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fiber__conditional.html">fiber_conditional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fiber__control.html">fiber_control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fiber__group.html">fiber_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1fiber__reply__container.html">fiber_reply_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fifo__scheduler.html">fifo_scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1fixed__dense__bitset.html">fixed_dense_bitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1gl__is__pod.html">gl_is_pod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if T is a POD type.  <a href="structgraphlab_1_1gl__is__pod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniongraphlab_1_1gl__uint128__t.html">gl_uint128_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html">graph_vertex_join</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the ability to pass information between vertices of two different graphs.  <a href="classgraphlab_1_1graph__vertex__join.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1hopscotch__map.html">hopscotch_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1hopscotch__set.html">hopscotch_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1hopscotch__table.html">hopscotch_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iarchive.html">iarchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serialization input archive object which, provided with a reference to an istream, will read from the istream, providing deserialization capabilities.  <a href="classgraphlab_1_1iarchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iarchive__soft__fail.html">iarchive_soft_fail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this archive is used to deserialize an object, and the object does not support serialization, failure will only occur at runtime. Otherwise equivalent to <a class="el" href="classgraphlab_1_1iarchive.html" title="The serialization input archive object which, provided with a reference to an istream, will read from the istream, providing deserialization capabilities. ">graphlab::iarchive</a>.  <a href="classgraphlab_1_1iarchive__soft__fail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1icontext.html">icontext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context object mediates the interaction between the vertex program and the graphlab execution environment.  <a href="classgraphlab_1_1icontext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1identity__hash.html">identity_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html">iengine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract interface of a GraphLab engine.  <a href="classgraphlab_1_1iengine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1IS__POD__TYPE.html">IS_POD_TYPE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheriting from this type will force the serializer to treat the derived type as a POD type.  <a href="structgraphlab_1_1IS__POD__TYPE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ischeduler.html">ischeduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html">ivertex_program</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgraphlab_1_1ivertex__program.html" title="The ivertex_program class defines the vertex program interface that all vertex programs should extend...">ivertex_program</a> class defines the vertex program interface that all vertex programs should extend and implement. The vertex-program is used to encode the user-define computation in a GraphLab program.  <a href="classgraphlab_1_1ivertex__program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1java__any.html">java_any</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1jni__core.html">jni_core</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1lockfree__push__back.html">lockfree_push_back</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1log__entry.html">log_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single entry in time.  <a href="structgraphlab_1_1log__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1log__group.html">log_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging information for a particular log entry (say #updates)  <a href="structgraphlab_1_1log__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1message__array.html">message_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1mutable__queue.html">mutable_queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1mutex.html">mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1oarchive.html">oarchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serialization output archive object which, provided with a reference to an ostream, will write to the ostream, providing serialization capabilities.  <a href="classgraphlab_1_1oarchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1oarchive__soft__fail.html">oarchive_soft_fail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this archive is used to serialize an object, and the object does not support serialization, failure will only occur at runtime. Otherwise equivalent to <a class="el" href="classgraphlab_1_1oarchive.html" title="The serialization output archive object which, provided with a reference to an ostream, will write to the ostream, providing serialization capabilities. ">graphlab::oarchive</a>.  <a href="classgraphlab_1_1oarchive__soft__fail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1omni__engine.html">omni_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The omni engine encapsulates all the GraphLab engines allowing the user to select which engine to use at runtime.  <a href="classgraphlab_1_1omni__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1OpPlusEq.html">OpPlusEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept checks if a type T supports operator+=.  <a href="classgraphlab_1_1OpPlusEq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1options__map.html">options_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1padded__integer.html">padded_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an integer value padded to 64 bytes  <a href="structgraphlab_1_1padded__integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1padded__simple__spinlock.html">padded_simple_spinlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1priority__scheduler.html">priority_scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1proxy__aggregator.html">proxy_aggregator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1proxy__edge.html">proxy_edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1proxy__updater.html">proxy_updater</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1proxy__vertex.html">proxy_vertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1queued__fifo__scheduler.html">queued_fifo_scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1queued__rw__lock.html">queued_rw_lock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1recursive__mutex.html">recursive_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1resizing__array__sink__ref.html">resizing_array_sink_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1rwlock.html">rwlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1safe__circular__char__buffer.html">safe_circular_char_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1sched__status.html">sched_status</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1scheduler__factory.html">scheduler_factory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1semaphore.html">semaphore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1Serializable.html">Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept checks if a type T is serializable.  <a href="classgraphlab_1_1Serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1simple__spinlock.html">simple_spinlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1small__set.html">small_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1spinrwlock.html">spinrwlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1synchronous__engine.html">synchronous_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The synchronous engine executes all active vertex program synchronously in a sequence of super-step (iterations) in both the shared and distributed memory settings.  <a href="classgraphlab_1_1synchronous__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1test__function__or__const__functor__1.html">test_function_or_const_functor_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tests that a type F matches a specification for a function type or implements a specification for a functor type.  <a href="structgraphlab_1_1test__function__or__const__functor__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1test__function__or__const__functor__2.html">test_function_or_const_functor_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tests that a type F matches a specification for a function type or implements a specification for a functor type.  <a href="structgraphlab_1_1test__function__or__const__functor__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1test__function__or__functor__1.html">test_function_or_functor_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tests that a type F matches a specification for a function type or implements a specification for a functor type.  <a href="structgraphlab_1_1test__function__or__functor__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1test__function__or__functor__2.html">test_function_or_functor_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tests that a type F matches a specification for a function type or implements a specification for a functor type.  <a href="structgraphlab_1_1test__function__or__functor__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1thread.html">thread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1thread__group.html">thread_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that can be used for benchmarking/timing up to microsecond resolution.  <a href="classgraphlab_1_1timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1unsupported__serialize.html">unsupported_serialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritting from this class will prevent the serialization of the derived class. Used for debugging purposes.  <a href="structgraphlab_1_1unsupported__serialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a set of vertices.  <a href="classgraphlab_1_1vertex__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a06cb1c495292ff748c5a3f493c59a97e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06cb1c495292ff748c5a3f493c59a97e"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_id_type</b></td></tr>
<tr class="separator:a06cb1c495292ff748c5a3f493c59a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3406fbb1c330d7e61f8efff6e3349"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68c3406fbb1c330d7e61f8efff6e3349"></a>
typedef vertex_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a68c3406fbb1c330d7e61f8efff6e3349">lvid_type</a></td></tr>
<tr class="memdesc:a68c3406fbb1c330d7e61f8efff6e3349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier type of a vertex which is only locally consistent. Guaranteed to be integral. <br /></td></tr>
<tr class="separator:a68c3406fbb1c330d7e61f8efff6e3349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46e72517c3bba4cd6583b8404090b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacegraphlab.html#a68c3406fbb1c330d7e61f8efff6e3349">lvid_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#abf46e72517c3bba4cd6583b8404090b5">edge_id_type</a></td></tr>
<tr class="separator:abf46e72517c3bba4cd6583b8404090b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cf13af0689f97f85df4220c4d7ab33"><td class="memItemLeft" align="right" valign="top">typedef graph&lt; <a class="el" href="classgraphlab_1_1proxy__vertex.html">proxy_vertex</a>, <a class="el" href="classgraphlab_1_1proxy__edge.html">proxy_edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a57cf13af0689f97f85df4220c4d7ab33">proxy_graph</a></td></tr>
<tr class="separator:a57cf13af0689f97f85df4220c4d7ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a27add6103da56425a8584b1bcef46f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a27add6103da56425a8584b1bcef46f"></a>
typedef <a class="el" href="classgraphlab_1_1mutex.html">mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a1a27add6103da56425a8584b1bcef46f">spinlock</a></td></tr>
<tr class="memdesc:a1a27add6103da56425a8584b1bcef46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">if spinlock not supported, it is typedef it to a mutex. <br /></td></tr>
<tr class="separator:a1a27add6103da56425a8584b1bcef46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b6e15157f83c1e4fb909050c2515e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2b6e15157f83c1e4fb909050c2515e2"></a>
typedef <a class="el" href="classgraphlab_1_1cancellable__barrier.html">cancellable_barrier</a>&#160;</td><td class="memItemRight" valign="bottom"><b>barrier</b></td></tr>
<tr class="separator:ad2b6e15157f83c1e4fb909050c2515e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648487a0f9acffb0df08cf24804b1dcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga648487a0f9acffb0df08cf24804b1dcd"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a></td></tr>
<tr class="memdesc:ga648487a0f9acffb0df08cf24804b1dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used for numbering processors. <br /></td></tr>
<tr class="separator:ga648487a0f9acffb0df08cf24804b1dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga353d1693839f28c6aac499ac24b21a7a"><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; std::pair&lt; std::string, std::string &gt;std::map&lt; std::string, std::string &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__httpserver.html#ga353d1693839f28c6aac499ac24b21a7a">http_redirect_callback_type</a></td></tr>
<tr class="separator:ga353d1693839f28c6aac499ac24b21a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c3328e0b1d3b0b0b5787f4b34b58a8"><td class="memItemLeft" align="right" valign="top">typedef boost::iostreams::stream&lt; charstream_impl::resizing_array_sink&lt; true &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga56c3328e0b1d3b0b0b5787f4b34b58a8">charstream</a></td></tr>
<tr class="separator:ga56c3328e0b1d3b0b0b5787f4b34b58a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3bdd1be2325a2bc198b1e18f787fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8a3bdd1be2325a2bc198b1e18f787fe"></a>
typedef boost::iostreams::stream&lt; hashstream_impl::hashstream_sink &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hashstream</b></td></tr>
<tr class="separator:aa8a3bdd1be2325a2bc198b1e18f787fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bf400c9e7c2ee54acd430ebe070f73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84bf400c9e7c2ee54acd430ebe070f73"></a>
typedef charstream_impl::resizing_array_sink&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>resizing_array_sink</b></td></tr>
<tr class="separator:a84bf400c9e7c2ee54acd430ebe070f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7a1c434a751d2eee47f43906ee43fc89"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a> { <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34">NO_EDGES</a> = 0, 
<a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6">IN_EDGES</a> = 1, 
<a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00">OUT_EDGES</a> = 2, 
<a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a968946455ba5885329abe6606b70c365">ALL_EDGES</a> = 3
 }</td></tr>
<tr class="memdesc:a7a1c434a751d2eee47f43906ee43fc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of edges that are traversed during gather and scatter operations.  <a href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">More...</a><br /></td></tr>
<tr class="separator:a7a1c434a751d2eee47f43906ee43fc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab26fa3fe75e572f4be0e446458270e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#adab26fa3fe75e572f4be0e446458270e">dc_comm_type</a> { <a class="el" href="namespacegraphlab.html#adab26fa3fe75e572f4be0e446458270ea13ec03eda9cdd56d4efe1919c9df7e1a">TCP_COMM</a>, 
<a class="el" href="namespacegraphlab.html#adab26fa3fe75e572f4be0e446458270ea52a1dbad97f0b38a81727e00984788b6">SCTP_COMM</a>
 }</td></tr>
<tr class="separator:adab26fa3fe75e572f4be0e446458270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa925d011e072bfa7f14d1f3d0ef14821"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa925d011e072bfa7f14d1f3d0ef14821"></a>
template&lt;typename VertexData , typename EdgeData &gt; </td></tr>
<tr class="memitem:aa925d011e072bfa7f14d1f3d0ef14821"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const dynamic_local_graph&lt; VertexData, EdgeData &gt; &amp;local_graph)</td></tr>
<tr class="separator:aa925d011e072bfa7f14d1f3d0ef14821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c20b2de3a420e39520c6f78e5c73fea"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0c20b2de3a420e39520c6f78e5c73fea"></a>
template&lt;typename VertexData , typename EdgeData &gt; </td></tr>
<tr class="memitem:a0c20b2de3a420e39520c6f78e5c73fea"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, local_graph&lt; VertexData, EdgeData &gt; &amp;g)</td></tr>
<tr class="separator:a0c20b2de3a420e39520c6f78e5c73fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ba8d8f333571cb95ae7842d9ecd1bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32ba8d8f333571cb95ae7842d9ecd1bf"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classgraphlab_1_1options__map.html">graphlab::options_map</a> &amp;opts)</td></tr>
<tr class="separator:a32ba8d8f333571cb95ae7842d9ecd1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e11219328079f7e013e404bbf4d808e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4e11219328079f7e013e404bbf4d808e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga4e11219328079f7e013e404bbf4d808e">atomic_compare_and_swap</a> (T &amp;a, T oldval, T newval)</td></tr>
<tr class="separator:ga4e11219328079f7e013e404bbf4d808e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f4d8f88abfcf4e636205b30968d362"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf4f4d8f88abfcf4e636205b30968d362"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaf4f4d8f88abfcf4e636205b30968d362">atomic_compare_and_swap</a> (volatile T &amp;a, T oldval, T newval)</td></tr>
<tr class="separator:gaf4f4d8f88abfcf4e636205b30968d362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d691570cf989fce408197dd169cb79e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga1d691570cf989fce408197dd169cb79e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga1d691570cf989fce408197dd169cb79e">atomic_compare_and_swap</a> (volatile double &amp;a, double oldval, double newval)</td></tr>
<tr class="separator:ga1d691570cf989fce408197dd169cb79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30d834097c5ba9553be760dc5b0da82"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gac30d834097c5ba9553be760dc5b0da82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gac30d834097c5ba9553be760dc5b0da82">atomic_compare_and_swap</a> (volatile float &amp;a, float oldval, float newval)</td></tr>
<tr class="separator:gac30d834097c5ba9553be760dc5b0da82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7cec31385cbd033b3a21ae5396517f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacc7cec31385cbd033b3a21ae5396517f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gacc7cec31385cbd033b3a21ae5396517f">atomic_exchange</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:gacc7cec31385cbd033b3a21ae5396517f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically exchanges the values of a and b.  <a href="group__util.html#gacc7cec31385cbd033b3a21ae5396517f">More...</a><br /></td></tr>
<tr class="separator:gacc7cec31385cbd033b3a21ae5396517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f737ca4c26913dc091e7a27c6413be1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6f737ca4c26913dc091e7a27c6413be1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga6f737ca4c26913dc091e7a27c6413be1">atomic_exchange</a> (volatile T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:ga6f737ca4c26913dc091e7a27c6413be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically exchanges the values of a and b.  <a href="group__util.html#ga6f737ca4c26913dc091e7a27c6413be1">More...</a><br /></td></tr>
<tr class="separator:ga6f737ca4c26913dc091e7a27c6413be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf659befbcccd93d3078b8d830192784a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf659befbcccd93d3078b8d830192784a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf659befbcccd93d3078b8d830192784a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaf659befbcccd93d3078b8d830192784a">fetch_and_store</a> (T &amp;a, const T &amp;newval)</td></tr>
<tr class="memdesc:gaf659befbcccd93d3078b8d830192784a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically sets a to the newval, returning the old value. <br /></td></tr>
<tr class="separator:gaf659befbcccd93d3078b8d830192784a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e66287c580fe28c89478750b83f230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt; RetVal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230">fiber_remote_request</a> (<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:ae9e66287c580fe28c89478750b83f230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a nonblocking RPC call to the target machine to run the provided function pointer which has an expected return value.  <a href="#ae9e66287c580fe28c89478750b83f230">More...</a><br /></td></tr>
<tr class="separator:ae9e66287c580fe28c89478750b83f230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d8bc6faaeeb404cde12aa9b650ffd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt; RetVal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2">object_fiber_remote_request</a> (<a class="el" href="classgraphlab_1_1dc__dist__object.html">dc_dist_object</a>&lt; T &gt; rmiobj, <a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> targetmachine, Fn fn,...)</td></tr>
<tr class="memdesc:ab6d8bc6faaeeb404cde12aa9b650ffd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a nonblocking RPC call to the target machine to run the provided function pointer which has an expected return value.  <a href="#ab6d8bc6faaeeb404cde12aa9b650ffd2">More...</a><br /></td></tr>
<tr class="separator:ab6d8bc6faaeeb404cde12aa9b650ffd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2f7935c6d0196eb1fcd689bd376f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#abf2f7935c6d0196eb1fcd689bd376f1a">destroy_tls_data</a> (void *ptr)</td></tr>
<tr class="separator:abf2f7935c6d0196eb1fcd689bd376f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac094b38ab112584e02e4a7ef39f105a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgraphlab_1_1thread_1_1tls__data.html">thread::tls_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#ac094b38ab112584e02e4a7ef39f105a6">create_tls_data</a> (size_t thread_id=0)</td></tr>
<tr class="separator:ac094b38ab112584e02e4a7ef39f105a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7db49888f8f2fbeacac4ab0ab0ce0b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7db49888f8f2fbeacac4ab0ab0ce0b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prefetch_range</b> (void *addr, size_t len)</td></tr>
<tr class="separator:ab7db49888f8f2fbeacac4ab0ab0ce0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5474d8b5f5fb60df26614d926f3e7749"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5474d8b5f5fb60df26614d926f3e7749"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prefetch_range_write</b> (void *addr, size_t len)</td></tr>
<tr class="separator:a5474d8b5f5fb60df26614d926f3e7749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef6c21238afca815d17e6607e9e0bab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ef6c21238afca815d17e6607e9e0bab"></a>
<a class="el" href="classgraphlab_1_1thread.html">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a4ef6c21238afca815d17e6607e9e0bab">launch_in_new_thread</a> (const boost::function&lt; void(void)&gt; &amp;f, size_t cpuid=size_t(-1))</td></tr>
<tr class="memdesc:a4ef6c21238afca815d17e6607e9e0bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs f in a new thread. convenience function for creating a new thread quickly. <br /></td></tr>
<tr class="separator:a4ef6c21238afca815d17e6607e9e0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68eba914bac09df157ccb10f9c6f96c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#gaa68eba914bac09df157ccb10f9c6f96c">init_param_from_env</a> (<a class="el" href="structgraphlab_1_1dc__init__param.html">dc_init_param</a> &amp;param)</td></tr>
<tr class="separator:gaa68eba914bac09df157ccb10f9c6f96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c1a14b15b97493f0835ea39399acc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga33c1a14b15b97493f0835ea39399acc6">init_param_from_mpi</a> (<a class="el" href="structgraphlab_1_1dc__init__param.html">dc_init_param</a> &amp;param, <a class="el" href="namespacegraphlab.html#adab26fa3fe75e572f4be0e446458270e">dc_comm_type</a> commtype)</td></tr>
<tr class="separator:ga33c1a14b15b97493f0835ea39399acc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81be787f9fdd112235010491f8110bad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81be787f9fdd112235010491f8110bad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zk_callback</b> (<a class="el" href="classgraphlab_1_1zookeeper_1_1server__list.html">zookeeper::server_list</a> *slist, std::string name_space, std::vector&lt; std::string &gt; servers, std::vector&lt; std::string &gt; &amp;result, size_t num_to_watch_for, <a class="el" href="classgraphlab_1_1mutex.html">mutex</a> &amp;result_lock, <a class="el" href="classgraphlab_1_1conditional.html">conditional</a> &amp;result_cond)</td></tr>
<tr class="separator:a81be787f9fdd112235010491f8110bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46d3dbaa184247df270e0414a10de0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#gaa46d3dbaa184247df270e0414a10de0b">init_param_from_zookeeper</a> (<a class="el" href="structgraphlab_1_1dc__init__param.html">dc_init_param</a> &amp;param)</td></tr>
<tr class="separator:gaa46d3dbaa184247df270e0414a10de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d34c759057fe5192f5619c2557ce6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57d34c759057fe5192f5619c2557ce6e"></a>
distributed_event_logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_event_log</b> ()</td></tr>
<tr class="separator:a57d34c759057fe5192f5619c2557ce6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813bcb3f44aecce8a467b58d23be93a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad813bcb3f44aecce8a467b58d23be93a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>request_reply_handler</b> (<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;dc, <a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a> src, size_t ptr, dc_impl::blob ret)</td></tr>
<tr class="separator:ad813bcb3f44aecce8a467b58d23be93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1849905d3318a0c2f6c56248ed620c3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1849905d3318a0c2f6c56248ed620c3d"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a1849905d3318a0c2f6c56248ed620c3d">get_scheduler_names</a> ()</td></tr>
<tr class="memdesc:a1849905d3318a0c2f6c56248ed620c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get all the scheduler names <br /></td></tr>
<tr class="separator:a1849905d3318a0c2f6c56248ed620c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb93e62e133d06f5b2c5dd186d4bd39e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb93e62e133d06f5b2c5dd186d4bd39e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#aeb93e62e133d06f5b2c5dd186d4bd39e">get_scheduler_names_str</a> ()</td></tr>
<tr class="memdesc:aeb93e62e133d06f5b2c5dd186d4bd39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get all the scheduler names concated into a string <br /></td></tr>
<tr class="separator:aeb93e62e133d06f5b2c5dd186d4bd39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dfd6c2df696d15ba369d7fbf92a285"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89dfd6c2df696d15ba369d7fbf92a285"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a89dfd6c2df696d15ba369d7fbf92a285">print_scheduler_info</a> (std::string s, std::ostream &amp;out)</td></tr>
<tr class="memdesc:a89dfd6c2df696d15ba369d7fbf92a285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the scheduler options for a particular scheduler. <br /></td></tr>
<tr class="separator:a89dfd6c2df696d15ba369d7fbf92a285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091d51d7a9ac1ff9062c8fa71211179d"><td class="memTemplParams" colspan="2">template&lt;typename OutArcType , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga091d51d7a9ac1ff9062c8fa71211179d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga091d51d7a9ac1ff9062c8fa71211179d">serialize_iterator</a> (OutArcType &amp;oarc, RandomAccessIterator begin, RandomAccessIterator end)</td></tr>
<tr class="memdesc:ga091d51d7a9ac1ff9062c8fa71211179d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the contents between the iterators begin and end.  <a href="group__group__serialization.html#ga091d51d7a9ac1ff9062c8fa71211179d">More...</a><br /></td></tr>
<tr class="separator:ga091d51d7a9ac1ff9062c8fa71211179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb49cd6914cad4d56373f276a1e7597"><td class="memTemplParams" colspan="2">template&lt;typename OutArcType , typename InputIterator &gt; </td></tr>
<tr class="memitem:gadbb49cd6914cad4d56373f276a1e7597"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#gadbb49cd6914cad4d56373f276a1e7597">serialize_iterator</a> (OutArcType &amp;oarc, InputIterator begin, InputIterator end, size_t vsize)</td></tr>
<tr class="memdesc:gadbb49cd6914cad4d56373f276a1e7597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the contents between the iterators begin and end.  <a href="group__group__serialization.html#gadbb49cd6914cad4d56373f276a1e7597">More...</a><br /></td></tr>
<tr class="separator:gadbb49cd6914cad4d56373f276a1e7597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23730b05a196b26ae2626c3dc0d37eeb"><td class="memTemplParams" colspan="2">template&lt;typename InArcType , typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga23730b05a196b26ae2626c3dc0d37eeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga23730b05a196b26ae2626c3dc0d37eeb">deserialize_iterator</a> (InArcType &amp;iarc, OutputIterator result)</td></tr>
<tr class="memdesc:ga23730b05a196b26ae2626c3dc0d37eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accompanying function to <a class="el" href="group__group__serialization.html#ga091d51d7a9ac1ff9062c8fa71211179d" title="Serializes the contents between the iterators begin and end. ">serialize_iterator()</a> Reads elements from the stream and writes it to the output iterator.  <a href="group__group__serialization.html#ga23730b05a196b26ae2626c3dc0d37eeb">More...</a><br /></td></tr>
<tr class="separator:ga23730b05a196b26ae2626c3dc0d37eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac4cdac656052995347c4aa86b810e8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaac4cdac656052995347c4aa86b810e8b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#gaac4cdac656052995347c4aa86b810e8b">serialize_to_string</a> (const T &amp;t)</td></tr>
<tr class="memdesc:gaac4cdac656052995347c4aa86b810e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a object to a string.  <a href="group__group__serialization.html#gaac4cdac656052995347c4aa86b810e8b">More...</a><br /></td></tr>
<tr class="separator:gaac4cdac656052995347c4aa86b810e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d369c2ce3d1e91892dc09f439b2cd11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d369c2ce3d1e91892dc09f439b2cd11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga7d369c2ce3d1e91892dc09f439b2cd11">deserialize_from_string</a> (const std::string &amp;s, T &amp;t)</td></tr>
<tr class="memdesc:ga7d369c2ce3d1e91892dc09f439b2cd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a object from a string.  <a href="group__group__serialization.html#ga7d369c2ce3d1e91892dc09f439b2cd11">More...</a><br /></td></tr>
<tr class="separator:ga7d369c2ce3d1e91892dc09f439b2cd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0461d7874e9b02048f443ab9469f8331"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0461d7874e9b02048f443ab9469f8331"></a>
std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>four_oh_four</b> (std::map&lt; std::string, std::string &gt; &amp;varmap)</td></tr>
<tr class="separator:a0461d7874e9b02048f443ab9469f8331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77f91799adb3a95a96f87b60d425f90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77f91799adb3a95a96f87b60d425f90"></a>
std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>echo</b> (std::map&lt; std::string, std::string &gt; &amp;varmap)</td></tr>
<tr class="separator:ad77f91799adb3a95a96f87b60d425f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256db71db5af3d436d3c5cad4d380c60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a256db71db5af3d436d3c5cad4d380c60"></a>
std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>index_page</b> (std::map&lt; std::string, std::string &gt; &amp;varmap)</td></tr>
<tr class="separator:a256db71db5af3d436d3c5cad4d380c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb5129065f79c97da4245281570749b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__httpserver.html#gadcb5129065f79c97da4245281570749b">add_metric_server_callback</a> (std::string page, <a class="el" href="group__httpserver.html#ga353d1693839f28c6aac499ac24b21a7a">http_redirect_callback_type</a> callback)</td></tr>
<tr class="memdesc:gadcb5129065f79c97da4245281570749b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to map a URL on the mtrics server to a processing function.  <a href="group__httpserver.html#gadcb5129065f79c97da4245281570749b">More...</a><br /></td></tr>
<tr class="separator:gadcb5129065f79c97da4245281570749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbea57ed2161d63ade7b12ea866aa1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__httpserver.html#ga4bbea57ed2161d63ade7b12ea866aa1a">launch_metric_server</a> ()</td></tr>
<tr class="memdesc:ga4bbea57ed2161d63ade7b12ea866aa1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the metrics reporting server.  <a href="group__httpserver.html#ga4bbea57ed2161d63ade7b12ea866aa1a">More...</a><br /></td></tr>
<tr class="separator:ga4bbea57ed2161d63ade7b12ea866aa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12410b6098ab43fc1cf8b295ab02604"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__httpserver.html#gaa12410b6098ab43fc1cf8b295ab02604">stop_metric_server</a> ()</td></tr>
<tr class="memdesc:gaa12410b6098ab43fc1cf8b295ab02604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the metrics reporting server if one is started.  <a href="group__httpserver.html#gaa12410b6098ab43fc1cf8b295ab02604">More...</a><br /></td></tr>
<tr class="separator:gaa12410b6098ab43fc1cf8b295ab02604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96234843e9b9ee0cdbb20856535576dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__httpserver.html#ga96234843e9b9ee0cdbb20856535576dc">stop_metric_server_on_eof</a> ()</td></tr>
<tr class="memdesc:ga96234843e9b9ee0cdbb20856535576dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a ctrl-D on machine 0, and stops the metrics reporting server if one is started.  <a href="group__httpserver.html#ga96234843e9b9ee0cdbb20856535576dc">More...</a><br /></td></tr>
<tr class="separator:ga96234843e9b9ee0cdbb20856535576dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d845c964ee0cb696694d9990dcea81e"><td class="memTemplParams" colspan="2">template&lt;typename valuetype , typename sizetype &gt; </td></tr>
<tr class="memitem:a5d845c964ee0cb696694d9990dcea81e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a5d845c964ee0cb696694d9990dcea81e">counting_sort</a> (const std::vector&lt; valuetype &gt; &amp;value_vec, std::vector&lt; sizetype &gt; &amp;permute_index, std::vector&lt; sizetype &gt; *prefix_array=NULL)</td></tr>
<tr class="separator:a5d845c964ee0cb696694d9990dcea81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4805b558a3ad75e687332f026c8ffc54"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename Source &gt; </td></tr>
<tr class="memitem:a4805b558a3ad75e687332f026c8ffc54"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if_c&lt; boost::is_convertible&lt; Source, Target &gt;::value, Target &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a4805b558a3ad75e687332f026c8ffc54">robust_cast</a> (const Source &amp;h)</td></tr>
<tr class="separator:a4805b558a3ad75e687332f026c8ffc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a86d6d4f7bba3fe693e7d4e6abad2cf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a86d6d4f7bba3fe693e7d4e6abad2cf"></a>
template&lt;typename Target , typename Source &gt; </td></tr>
<tr class="memitem:a5a86d6d4f7bba3fe693e7d4e6abad2cf"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c&lt; boost::is_convertible&lt; Source, Target &gt;::value, Target &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>robust_cast</b> (const Source &amp;h)</td></tr>
<tr class="separator:a5a86d6d4f7bba3fe693e7d4e6abad2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d52e28b8cda31dbae766511140716c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename sizetype &gt; </td></tr>
<tr class="memitem:ac2d52e28b8cda31dbae766511140716c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#ac2d52e28b8cda31dbae766511140716c">inplace_shuffle</a> (Iterator begin, Iterator end, std::vector&lt; sizetype &gt; &amp;targets)</td></tr>
<tr class="separator:ac2d52e28b8cda31dbae766511140716c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad985d2f5fb507be6aa0332cd055bded5"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename sizetype &gt; </td></tr>
<tr class="memitem:ad985d2f5fb507be6aa0332cd055bded5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#ad985d2f5fb507be6aa0332cd055bded5">outofplace_shuffle</a> (Container &amp;c, const std::vector&lt; sizetype &gt; &amp;targets)</td></tr>
<tr class="separator:ad985d2f5fb507be6aa0332cd055bded5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac578393426faed9f95cf2cc301eab7a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac578393426faed9f95cf2cc301eab7a2"></a>
template&lt;typename v1 , typename v2 &gt; </td></tr>
<tr class="memitem:ac578393426faed9f95cf2cc301eab7a2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; v1, v2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_zip</b> (std::vector&lt; v1 &gt; &amp;vec1, std::vector&lt; v2 &gt; &amp;vec2)</td></tr>
<tr class="separator:ac578393426faed9f95cf2cc301eab7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310accfd90d1389df8d1617b66dcf9e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a310accfd90d1389df8d1617b66dcf9e1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>integer_mix</b> (uint32_t a)</td></tr>
<tr class="separator:a310accfd90d1389df8d1617b66dcf9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c13ea9b2f6fc30a7ba2f21f8ec83892"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c13ea9b2f6fc30a7ba2f21f8ec83892"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>str_to_ip</b> (const char *c, uint32_t &amp;out)</td></tr>
<tr class="separator:a9c13ea9b2f6fc30a7ba2f21f8ec83892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae195d9d199f09d9cb99ea5ec94b36153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae195d9d199f09d9cb99ea5ec94b36153"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ip_to_str</b> (uint32_t ip, std::string &amp;out)</td></tr>
<tr class="separator:ae195d9d199f09d9cb99ea5ec94b36153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf216a88d8cd495341e2da180da23634"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gabf216a88d8cd495341e2da180da23634">get_local_ip_as_str</a> (bool print)</td></tr>
<tr class="separator:gabf216a88d8cd495341e2da180da23634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3fe612fa90e40fd065ad8e771965e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4a3fe612fa90e40fd065ad8e771965e4">get_local_ip</a> (bool print)</td></tr>
<tr class="separator:ga4a3fe612fa90e40fd065ad8e771965e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb1bf1563f0d78e73c92e374f0e37b2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga1fb1bf1563f0d78e73c92e374f0e37b2">get_free_tcp_port</a> ()</td></tr>
<tr class="separator:ga1fb1bf1563f0d78e73c92e374f0e37b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b91cad71729bc7569a05361af815239"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b91cad71729bc7569a05361af815239"></a>
template&lt;size_t MAX_DIM, typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:a9b91cad71729bc7569a05361af815239"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const graphlab::small_map&lt; MAX_DIM, KeyT, ValueT &gt; &amp;map)</td></tr>
<tr class="separator:a9b91cad71729bc7569a05361af815239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544cad59def48e1d7b56f8e37efab45"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0544cad59def48e1d7b56f8e37efab45"></a>
template&lt;size_t MAX_DIM, typename T &gt; </td></tr>
<tr class="memitem:a0544cad59def48e1d7b56f8e37efab45"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classgraphlab_1_1small__set.html">graphlab::small_set</a>&lt; MAX_DIM, T &gt; &amp;set)</td></tr>
<tr class="separator:a0544cad59def48e1d7b56f8e37efab45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8345221d70e487541998547d645c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77b8345221d70e487541998547d645c4"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a77b8345221d70e487541998547d645c4">set_union</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a77b8345221d70e487541998547d645c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574718697d1fb4754c3f8f9cbf3c83fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a574718697d1fb4754c3f8f9cbf3c83fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a574718697d1fb4754c3f8f9cbf3c83fa"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_union</b> (const std::set&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a574718697d1fb4754c3f8f9cbf3c83fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c1e7504f678295b794f1dc5ccf7f50"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad8c1e7504f678295b794f1dc5ccf7f50"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8c1e7504f678295b794f1dc5ccf7f50"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_intersect</b> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ad8c1e7504f678295b794f1dc5ccf7f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7314d33982aaf2b9e54a4cbaeec9ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a7314d33982aaf2b9e54a4cbaeec9ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a7314d33982aaf2b9e54a4cbaeec9ff"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_difference</b> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a6a7314d33982aaf2b9e54a4cbaeec9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c64bb9359868c20e13b70087cf4bc8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20c64bb9359868c20e13b70087cf4bc8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20c64bb9359868c20e13b70087cf4bc8"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_difference</b> (const std::set&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a20c64bb9359868c20e13b70087cf4bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4b551c8c0884ee93ffb22d20dcedac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e4b551c8c0884ee93ffb22d20dcedac"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::set&lt; T &gt;, std::set&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a8e4b551c8c0884ee93ffb22d20dcedac">set_partition</a> (const std::set&lt; T &gt; &amp;s, const std::set&lt; T &gt; &amp;partition)</td></tr>
<tr class="separator:a8e4b551c8c0884ee93ffb22d20dcedac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab544baa9860533d8d6638c9632f4dc57"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab544baa9860533d8d6638c9632f4dc57"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab544baa9860533d8d6638c9632f4dc57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_disjoint</b> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ab544baa9860533d8d6638c9632f4dc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b301a43b14710ed86d368bbbb18b6e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b301a43b14710ed86d368bbbb18b6e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b301a43b14710ed86d368bbbb18b6e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_equal</b> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a4b301a43b14710ed86d368bbbb18b6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada78d14c71edaf13324cc07ce0c0e004"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada78d14c71edaf13324cc07ce0c0e004"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada78d14c71edaf13324cc07ce0c0e004"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>includes</b> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ada78d14c71edaf13324cc07ce0c0e004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc670d628d9f1f9577f5c40baee7d11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8cc670d628d9f1f9577f5c40baee7d11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a8cc670d628d9f1f9577f5c40baee7d11">is_subset</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a8cc670d628d9f1f9577f5c40baee7d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b4a924ece1c6c7820c56a2fd0d1894"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46b4a924ece1c6c7820c56a2fd0d1894"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46b4a924ece1c6c7820c56a2fd0d1894"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_superset</b> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a46b4a924ece1c6c7820c56a2fd0d1894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43627e48f11279ef92568b967acbc5f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43627e48f11279ef92568b967acbc5f0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43627e48f11279ef92568b967acbc5f0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a43627e48f11279ef92568b967acbc5f0">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a43627e48f11279ef92568b967acbc5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human representation of the set to the supplied stream. <br /></td></tr>
<tr class="separator:a43627e48f11279ef92568b967acbc5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d97a46db44e4d120787aaa5490a2e1"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a57d97a46db44e4d120787aaa5490a2e1"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a57d97a46db44e4d120787aaa5490a2e1">safe_get</a> (const std::map&lt; Key, T &gt; &amp;map, const Key &amp;key)</td></tr>
<tr class="separator:a57d97a46db44e4d120787aaa5490a2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3351861a051abcd43cbd132f451fbe5e"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a3351861a051abcd43cbd132f451fbe5e"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a3351861a051abcd43cbd132f451fbe5e">safe_get</a> (const std::map&lt; Key, T &gt; &amp;map, const Key &amp;key, const T default_value)</td></tr>
<tr class="separator:a3351861a051abcd43cbd132f451fbe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeeb11ec6df09092a6c053ff7970e4c"><td class="memTemplParams" colspan="2">template&lt;typename OldKey , typename NewKey , typename T &gt; </td></tr>
<tr class="memitem:a1eeeb11ec6df09092a6c053ff7970e4c"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; NewKey, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a1eeeb11ec6df09092a6c053ff7970e4c">rekey</a> (const std::map&lt; OldKey, T &gt; &amp;map, const std::map&lt; OldKey, NewKey &gt; &amp;key_map)</td></tr>
<tr class="separator:a1eeeb11ec6df09092a6c053ff7970e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9e0c3f1472be6c8c7d7f89ed901986"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename OldT , typename NewT &gt; </td></tr>
<tr class="memitem:a0b9e0c3f1472be6c8c7d7f89ed901986"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, NewT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a0b9e0c3f1472be6c8c7d7f89ed901986">remap</a> (const std::map&lt; Key, OldT &gt; &amp;map, const std::map&lt; OldT, NewT &gt; &amp;val_map)</td></tr>
<tr class="separator:a0b9e0c3f1472be6c8c7d7f89ed901986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6139b4e0b0662f65d4b283f828c7dd26"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a6139b4e0b0662f65d4b283f828c7dd26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a6139b4e0b0662f65d4b283f828c7dd26">remap</a> (std::map&lt; Key, T &gt; &amp;map, const std::map&lt; T, T &gt; &amp;val_map)</td></tr>
<tr class="separator:a6139b4e0b0662f65d4b283f828c7dd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dd2b0e747013bc3277aeb3e4a413bc"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a11dd2b0e747013bc3277aeb3e4a413bc"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a11dd2b0e747013bc3277aeb3e4a413bc">map_union</a> (const std::map&lt; Key, T &gt; &amp;a, const std::map&lt; Key, T &gt; &amp;b)</td></tr>
<tr class="separator:a11dd2b0e747013bc3277aeb3e4a413bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77421ad626c4978aac3895d1b2fe175a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a77421ad626c4978aac3895d1b2fe175a"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a77421ad626c4978aac3895d1b2fe175a">map_intersect</a> (const std::map&lt; Key, T &gt; &amp;a, const std::map&lt; Key, T &gt; &amp;b)</td></tr>
<tr class="separator:a77421ad626c4978aac3895d1b2fe175a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9cef797fa2f4bb85e3415eaed1fc0a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a6f9cef797fa2f4bb85e3415eaed1fc0a"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a6f9cef797fa2f4bb85e3415eaed1fc0a">map_intersect</a> (const std::map&lt; Key, T &gt; &amp;m, const std::set&lt; Key &gt; &amp;<a class="el" href="namespacegraphlab.html#a5e5de7e3d1eacd0a6f291f4499bb9d44">keys</a>)</td></tr>
<tr class="separator:a6f9cef797fa2f4bb85e3415eaed1fc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb375f49c14e267158ae47bed5baff91"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:abb375f49c14e267158ae47bed5baff91"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#abb375f49c14e267158ae47bed5baff91">map_difference</a> (const std::map&lt; Key, T &gt; &amp;a, const std::map&lt; Key, T &gt; &amp;b)</td></tr>
<tr class="separator:abb375f49c14e267158ae47bed5baff91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5de7e3d1eacd0a6f291f4499bb9d44"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a5e5de7e3d1eacd0a6f291f4499bb9d44"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a5e5de7e3d1eacd0a6f291f4499bb9d44">keys</a> (const std::map&lt; Key, T &gt; &amp;map)</td></tr>
<tr class="separator:a5e5de7e3d1eacd0a6f291f4499bb9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e22ff44fb7ef51bea69e42c0a13ccd"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ae0e22ff44fb7ef51bea69e42c0a13ccd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#ae0e22ff44fb7ef51bea69e42c0a13ccd">keys_as_vector</a> (const std::map&lt; Key, T &gt; &amp;map)</td></tr>
<tr class="separator:ae0e22ff44fb7ef51bea69e42c0a13ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8f631ef7e698460f144b74ffd6d3ee"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:abb8f631ef7e698460f144b74ffd6d3ee"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#abb8f631ef7e698460f144b74ffd6d3ee">values</a> (const std::map&lt; Key, T &gt; &amp;map)</td></tr>
<tr class="separator:abb8f631ef7e698460f144b74ffd6d3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea8ff3768be7293e3b441eb942742ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ea8ff3768be7293e3b441eb942742ec"></a>
template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a2ea8ff3768be7293e3b441eb942742ec"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>values</b> (const std::map&lt; Key, T &gt; &amp;m, const std::set&lt; Key &gt; &amp;<a class="el" href="namespacegraphlab.html#a5e5de7e3d1eacd0a6f291f4499bb9d44">keys</a>)</td></tr>
<tr class="separator:a2ea8ff3768be7293e3b441eb942742ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa8d7360c34f8ebd142950b755cfb4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4fa8d7360c34f8ebd142950b755cfb4d"></a>
template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a4fa8d7360c34f8ebd142950b755cfb4d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>values</b> (const std::map&lt; Key, T &gt; &amp;m, const std::vector&lt; Key &gt; &amp;<a class="el" href="namespacegraphlab.html#a5e5de7e3d1eacd0a6f291f4499bb9d44">keys</a>)</td></tr>
<tr class="separator:a4fa8d7360c34f8ebd142950b755cfb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e8b2b2825aaf7982ca43f1b49a39c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79e8b2b2825aaf7982ca43f1b49a39c7"></a>
template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a79e8b2b2825aaf7982ca43f1b49a39c7"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a79e8b2b2825aaf7982ca43f1b49a39c7">make_identity_map</a> (const std::set&lt; Key &gt; &amp;<a class="el" href="namespacegraphlab.html#a5e5de7e3d1eacd0a6f291f4499bb9d44">keys</a>)</td></tr>
<tr class="memdesc:a79e8b2b2825aaf7982ca43f1b49a39c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an identity map (a map from elements to themselves) <br /></td></tr>
<tr class="separator:a79e8b2b2825aaf7982ca43f1b49a39c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5b694c81ca6d467c00d1c584966229"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca5b694c81ca6d467c00d1c584966229"></a>
template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:aca5b694c81ca6d467c00d1c584966229"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#aca5b694c81ca6d467c00d1c584966229">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; Key, T &gt; &amp;m)</td></tr>
<tr class="memdesc:aca5b694c81ca6d467c00d1c584966229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a map to the supplied stream. <br /></td></tr>
<tr class="separator:aca5b694c81ca6d467c00d1c584966229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87a901ac0e688b927ed71a06224c6c6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#ad87a901ac0e688b927ed71a06224c6c6">trim</a> (const std::string &amp;str)</td></tr>
<tr class="separator:ad87a901ac0e688b927ed71a06224c6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8565d1fc8a5474c7696a0d9e02ee4dc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8565d1fc8a5474c7696a0d9e02ee4dc5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a8565d1fc8a5474c7696a0d9e02ee4dc5">tostr</a> (const T &amp;t)</td></tr>
<tr class="separator:a8565d1fc8a5474c7696a0d9e02ee4dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c75dd5f56d937fa9c7ac6f467cac812"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c75dd5f56d937fa9c7ac6f467cac812"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a6c75dd5f56d937fa9c7ac6f467cac812">fromstr</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a6c75dd5f56d937fa9c7ac6f467cac812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb801720e8591edca9e99bea084bcdcf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#afb801720e8591edca9e99bea084bcdcf">pad_number</a> (const size_t number, const size_t npad, const char pad_value= '0')</td></tr>
<tr class="separator:afb801720e8591edca9e99bea084bcdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd36f7771c6e227c8a90c2d08a3ca4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#acfd36f7771c6e227c8a90c2d08a3ca4f">strsplit</a> (const std::string &amp;str, const std::string &amp;splitchars, const bool auto_trim=false)</td></tr>
<tr class="separator:acfd36f7771c6e227c8a90c2d08a3ca4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df37392c8943d48b87bf25f3cd82a45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4df37392c8943d48b87bf25f3cd82a45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>alarm_wakeup</b> (int i)</td></tr>
<tr class="separator:a4df37392c8943d48b87bf25f3cd82a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2b996fea307957b9ee87020063c00e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2b996fea307957b9ee87020063c00e"></a>
unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>estimate_ticks_per_second</b> ()</td></tr>
<tr class="separator:aca2b996fea307957b9ee87020063c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fa5f57a7768c4f2cb5cec6ff699771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uniongraphlab_1_1gl__uint128__t.html">gl_uint128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a77fa5f57a7768c4f2cb5cec6ff699771">fill_128b</a> ()</td></tr>
<tr class="separator:a77fa5f57a7768c4f2cb5cec6ff699771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd9620ea366c265612aeebcfcc5e54"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#af9cd9620ea366c265612aeebcfcc5e54">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="uniongraphlab_1_1gl__uint128__t.html">gl_uint128_t</a> &amp;val)</td></tr>
<tr class="separator:af9cd9620ea366c265612aeebcfcc5e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adaa8a382cfa5e1cf0394854ac8940394"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaa8a382cfa5e1cf0394854ac8940394"></a>
<a class="el" href="classgraphlab_1_1mutex.html">mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>flush_lock</b></td></tr>
<tr class="separator:adaa8a382cfa5e1cf0394854ac8940394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ef7193898f623a0e7b462dc800b889"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegraphlab.html#a40ef7193898f623a0e7b462dc800b889">__thr_callback</a> )() = NULL</td></tr>
<tr class="separator:a40ef7193898f623a0e7b462dc800b889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6c83fd149fbd25bc1655418016ec5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec6c83fd149fbd25bc1655418016ec5b"></a>
const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>STANDARD_CALL</b> = 1</td></tr>
<tr class="separator:aec6c83fd149fbd25bc1655418016ec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50860fbbadebb6b12533c6efc706ab44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50860fbbadebb6b12533c6efc706ab44"></a>
const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>CONTROL_PACKET</b> = 16</td></tr>
<tr class="separator:a50860fbbadebb6b12533c6efc706ab44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5fcbd7689a03310dcd69e98f6a676d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5fcbd7689a03310dcd69e98f6a676d"></a>
const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>FLUSH_PACKET</b> = 64</td></tr>
<tr class="separator:a0b5fcbd7689a03310dcd69e98f6a676d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36675d81df5424200b3bb32af23c3492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36675d81df5424200b3bb32af23c3492"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_LOG_SIZE</b> = 256</td></tr>
<tr class="separator:a36675d81df5424200b3bb32af23c3492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a31969a59d37af387fa9ac31640df3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6a31969a59d37af387fa9ac31640df3"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_LOG_THREADS</b> = 1024</td></tr>
<tr class="separator:ad6a31969a59d37af387fa9ac31640df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4658d1e8c4cc35e7514efaa8700e89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a4658d1e8c4cc35e7514efaa8700e89"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>TICK_FREQUENCY</b> = 0.5</td></tr>
<tr class="separator:a1a4658d1e8c4cc35e7514efaa8700e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9678d56d65e4e3926a3b5d27aa3f1919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9678d56d65e4e3926a3b5d27aa3f1919"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>RECORD_FREQUENCY</b> = 5.0</td></tr>
<tr class="separator:a9678d56d65e4e3926a3b5d27aa3f1919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e3a9ff2b608667cf4d58c5a38e3eb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e3a9ff2b608667cf4d58c5a38e3eb4"></a>
hundredms_timer&#160;</td><td class="memItemRight" valign="bottom"><b>hmstimer</b></td></tr>
<tr class="separator:a86e3a9ff2b608667cf4d58c5a38e3eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (c) 2009 Carnegie Mellon University. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
 IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>For more about this software visit: </p><pre class="fragment"> http://www.graphlab.ml.cmu.edu</pre><p>Copyright (c) 2009 Carnegie Mellon University. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
 IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>For more about this software visit: </p><pre class="fragment"> http://www.graphlab.ml.cmu.edu</pre><p>Also contains code that is Copyright 2011 Yahoo! Inc. All rights reserved.</p>
<p>Contributed under the iCLA for: Joseph Gonzalez (<a href="#" onclick="location.href='mai'+'lto:'+'jeg'+'on'+'zal'+'@y'+'aho'+'o-'+'inc'+'.c'+'om'; return false;">jegon<span style="display: none;">.nosp@m.</span>zal@<span style="display: none;">.nosp@m.</span>yahoo<span style="display: none;">.nosp@m.</span>-inc<span style="display: none;">.nosp@m.</span>.com</a>)</p>
<p>Copyright (c) 2011 Carnegie Mellon University. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
 IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>For more about this software visit: </p><pre class="fragment"> http://www.graphlab.ml.cmu.edu</pre><p>Copyright (c) 2009 Carnegie Mellon University. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
 IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>For more about this software visit: </p><pre class="fragment"> http://www.graphlab.ml.cmu.edu</pre><p>This class defines the dependencies among the shards when using a constrained partitioning algorithm.</p>
<p>In constrained partitioning, vertices are assgined to a master shard using hash function on the vids. Each shard S masters a partition of vertices: V_s.</p>
<p>Let Ai be the set of shards that Shard i depends on. Then the partitioning algorithm can only put edges with either ends in V_si into Ai. For example, Shard i is the master of vertex u, and Shard j is the master of vertex v, then edge u-&gt;v must be placed into Ai  Aj.</p>
<p>This class currently has two implementations of the shard constraints. One construction is based on a grid, and the other is based on perfect difference set. Both algorithms guarentees that Ai  Aj is non-empty.</p>
<dl class="section note"><dt>Note</dt><dd>: grid methods requires the number of shards to be a perfect square number. pds requires the number of shards to be p^2 + p + 1 where p is a prime number.</dd></dl>
<p>Copyright (c) 2009 Carnegie Mellon University. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
 IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>For more about this software visit: </p><pre class="fragment"> http://www.graphlab.ml.cmu.edu
</pre><p>Also contains code that is Copyright 2011 Yahoo! Inc. All rights reserved. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="abf46e72517c3bba4cd6583b8404090b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacegraphlab.html#a68c3406fbb1c330d7e61f8efff6e3349">lvid_type</a> <a class="el" href="namespacegraphlab.html#abf46e72517c3bba4cd6583b8404090b5">graphlab::edge_id_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identifier type of an edge which is only locally consistent. Guaranteed to be integral and consecutive. </p>

<p>Definition at line <a class="el" href="graph__basic__types_8hpp_source.html#l00048">48</a> of file <a class="el" href="graph__basic__types_8hpp_source.html">graph_basic_types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57cf13af0689f97f85df4220c4d7ab33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef graph&lt;<a class="el" href="classgraphlab_1_1proxy__vertex.html">proxy_vertex</a>, <a class="el" href="classgraphlab_1_1proxy__edge.html">proxy_edge</a>&gt; <a class="el" href="namespacegraphlab.html#a57cf13af0689f97f85df4220c4d7ab33">graphlab::proxy_graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Proxy graph </p>

<p>Definition at line <a class="el" href="org__graphlab__Updater_8hpp_source.html#l00066">66</a> of file <a class="el" href="org__graphlab__Updater_8hpp_source.html">org_graphlab_Updater.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="adab26fa3fe75e572f4be0e446458270e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegraphlab.html#adab26fa3fe75e572f4be0e446458270e">graphlab::dc_comm_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="adab26fa3fe75e572f4be0e446458270ea13ec03eda9cdd56d4efe1919c9df7e1a"></a>TCP_COMM&#160;</td><td class="fielddoc">
<p>TCP/IP. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adab26fa3fe75e572f4be0e446458270ea52a1dbad97f0b38a81727e00984788b6"></a>SCTP_COMM&#160;</td><td class="fielddoc">
<p>SCTP (limited support) </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="dc__types_8hpp_source.html#l00037">37</a> of file <a class="el" href="dc__types_8hpp_source.html">dc_types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a1c434a751d2eee47f43906ee43fc89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">graphlab::edge_dir_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of edges that are traversed during gather and scatter operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34"></a>NO_EDGES&#160;</td><td class="fielddoc">
<p>No edges implies that no edges are processed during the corresponding gather or scatter phase, essentially skipping that phase. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6"></a>IN_EDGES&#160;</td><td class="fielddoc">
<p>In edges implies that only whose target is the center vertex are processed during gather or scatter. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00"></a>OUT_EDGES&#160;</td><td class="fielddoc">
<p>Out edges implies that only whose source is the center vertex are processed during gather or scatter. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a1c434a751d2eee47f43906ee43fc89a968946455ba5885329abe6606b70c365"></a>ALL_EDGES&#160;</td><td class="fielddoc">
<p>All edges implies that all adges adjacent to a the center vertex are processed on gather or scatter. Note that some neighbors may be encountered twice if there is both an in and out edge to that neighbor. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="graph__basic__types_8hpp_source.html#l00054">54</a> of file <a class="el" href="graph__basic__types_8hpp_source.html">graph_basic_types.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5d845c964ee0cb696694d9990dcea81e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename valuetype , typename sizetype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::counting_sort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; valuetype &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; sizetype &gt; &amp;&#160;</td>
          <td class="paramname"><em>permute_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; sizetype &gt; *&#160;</td>
          <td class="paramname"><em>prefix_array</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the value_vec. Generate permute_index for value_vec in ascending order and optionally fill in the prefix array of the counts. </p>

<p>Definition at line <a class="el" href="counting__sort_8hpp_source.html#l00039">39</a> of file <a class="el" href="counting__sort_8hpp_source.html">counting_sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac094b38ab112584e02e4a7ef39f105a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1thread_1_1tls__data.html">thread::tls_data</a>* graphlab::create_tls_data </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_id</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create thread specific data </p>

<p>Definition at line <a class="el" href="pthread__tools_8cpp_source.html#l00064">64</a> of file <a class="el" href="pthread__tools_8cpp_source.html">pthread_tools.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf2f7935c6d0196eb1fcd689bd376f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::destroy_tls_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create thread specific data </p>

<p>Definition at line <a class="el" href="pthread__tools_8cpp_source.html#l00097">97</a> of file <a class="el" href="pthread__tools_8cpp_source.html">pthread_tools.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9e66287c580fe28c89478750b83f230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt;RetVal&gt; graphlab::fiber_remote_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a nonblocking RPC call to the target machine to run the provided function pointer which has an expected return value. </p>
<p><a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">fiber_remote_request()</a> calls the function "fn" on a target remote machine. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, it is sent back to calling machine. <a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">fiber_remote_request()</a> returns immediately a <a class="el" href="structgraphlab_1_1request__future.html">graphlab::request_future</a> object which will allow you wait for the return value.</p>
<p><a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">fiber_remote_request()</a> has an identical interface to <a class="el" href="classgraphlab_1_1distributed__control.html#a6bff779bee123f4e4506beaa72497e9f">graphlab::distributed_control::future_remote_request()</a> , but has the additional capability that if a <a class="el" href="structgraphlab_1_1request__future.html#a950a29dbe1ef7e24abbfed5e31e2af67">graphlab::request_future::wait()</a> is called on the request while within a fiber, it deschedules the fiber and context switches, returning only when the future is ready. This allows the future to be used from within a fiber.</p>
<p>Since this function is not a member of the <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">distributed_control</a> class, it uses the function <a class="el" href="classgraphlab_1_1distributed__control.html#a8a43c8d6bfa3235d6132d4c9814c6e7f">distributed_control::get_instance()</a> to obtain the last instance of the distribute_control class created. This should be sufficient for most use cases.</p>
<p><a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2">graphlab::object_fiber_remote_request</a> is the version of this function for remotely calling class member functions.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined</span></div>
<div class="line"><span class="keywordtype">int</span> add_one(<span class="keywordtype">int</span> i) {</div>
<div class="line">  <span class="keywordflow">return</span> i + 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">... ...</div>
<div class="line"><span class="comment">// call the add_one function on machine 1</span></div>
<div class="line">int i = 10;</div>
<div class="line"><a class="code" href="structgraphlab_1_1request__future.html">graphlab::request_future&lt;int&gt;</a> ret = <a class="code" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230">fiber_remote_request</a>(1, add_one, i);</div>
<div class="line"><span class="comment">// this is safe to do within a fiber as it will not halt other fibers.</span></div>
<div class="line"><span class="keywordtype">int</span> result = ret();</div>
<div class="line"><span class="comment">// result will be 11</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classgraphlab_1_1distributed__control.html#a15abdebdf3d6ef44994661e562990380" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">graphlab::distributed_control::remote_request</a> <a class="el" href="classgraphlab_1_1distributed__control.html#a6bff779bee123f4e4506beaa72497e9f" title="Performs a non-blocking RPC call to the target machine to run the provided function pointer...">graphlab::distributed_control::future_remote_request</a> <a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::object_fiber_remote_request</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine. Must be a pointer to member function in the owning object. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a future templated around the same type as the return value of the called function </dd></dl>

</div>
</div>
<a class="anchor" id="a77fa5f57a7768c4f2cb5cec6ff699771"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uniongraphlab_1_1gl__uint128__t.html">gl_uint128_t</a> graphlab::fill_128b </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all 128bits of the the <a class="el" href="uniongraphlab_1_1gl__uint128__t.html">gl_uint128_t</a> to 'true'. Or the 128-bit integer representation of "-1" </p>

<p>Definition at line <a class="el" href="uint128_8hpp_source.html#l00061">61</a> of file <a class="el" href="uint128_8hpp_source.html">uint128.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c75dd5f56d937fa9c7ac6f467cac812"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T graphlab::fromstr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function for using std streams to convert a string to anything </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00406">406</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2d52e28b8cda31dbae766511140716c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename sizetype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::inplace_shuffle </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; sizetype &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuffles a random access container inplace such at newcont[i] = cont[targets[i]] targets must be the same size as the container Both the container and the targets vector will be modified. </p>

<p>Definition at line <a class="el" href="shuffle_8hpp_source.html#l00045">45</a> of file <a class="el" href="shuffle_8hpp_source.html">shuffle.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cc670d628d9f1f9577f5c40baee7d11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool graphlab::is_subset </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if $a  b$ </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00141">141</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5de7e3d1eacd0a6f291f4499bb9d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;Key&gt; graphlab::keys </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of keys in a map </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00302">302</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0e22ff44fb7ef51bea69e42c0a13ccd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Key&gt; graphlab::keys_as_vector </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get teh set of keys in a map as a vector </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00315">315</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb375f49c14e267158ae47bed5baff91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Key, T&gt; graphlab::map_difference </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the difference between two maps </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00285">285</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77421ad626c4978aac3895d1b2fe175a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Key, T&gt; graphlab::map_intersect </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the intersection of two maps </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00252">252</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f9cef797fa2f4bb85e3415eaed1fc0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Key, T&gt; graphlab::map_intersect </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the entries of a map whose keys show up in the set keys </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00269">269</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11dd2b0e747013bc3277aeb3e4a413bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Key, T&gt; graphlab::map_union </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the union of two maps </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00236">236</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6d8bc6faaeeb404cde12aa9b650ffd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1request__future.html">request_future</a>&lt;RetVal&gt; graphlab::object_fiber_remote_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1dc__dist__object.html">dc_dist_object</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rmiobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td>
          <td class="paramname"><em>targetmachine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a nonblocking RPC call to the target machine to run the provided function pointer which has an expected return value. </p>
<p><a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">object_fiber_remote_request()</a> calls the function "fn" on a target remote machine. Provided arguments are serialized and sent to the target. Therefore, all arguments are necessarily transmitted by value. If the target function has a return value, it is sent back to calling machine. <a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">object_fiber_remote_request()</a> returns immediately a <a class="el" href="structgraphlab_1_1request__future.html">graphlab::request_future</a> object which will allow you wait for the return value.</p>
<p><a class="el" href="namespacegraphlab.html#ab6d8bc6faaeeb404cde12aa9b650ffd2" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">object_fiber_remote_request()</a> has an identical interface to <a class="el" href="classgraphlab_1_1dc__dist__object.html#a058fafc0d3650176df4457eb6f93968f">graphlab::dc_dist_object::future_remote_request()</a> , but has the additional capability that if a <a class="el" href="structgraphlab_1_1request__future.html#a950a29dbe1ef7e24abbfed5e31e2af67">graphlab::request_future::wait()</a> is called on the request while within a fiber, it deschedules the fiber and context switches, returning only when the future is ready. This allows the future to be used from within a fiber.</p>
<p>Since this function is not a member of the <a class="el" href="classgraphlab_1_1dc__dist__object.html">dc_dist_object</a> class, it needs to be provided a reference to the owning object's <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">dc_dist_object</a>.</p>
<p><a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230">graphlab::fiber_remote_request</a> is the version of this function for remotely calling global functions.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// A print function is defined in the distributed object</span></div>
<div class="line"><span class="keyword">class </span>distributed_obj_example {</div>
<div class="line"> <a class="code" href="classgraphlab_1_1dc__dist__object.html">graphlab::dc_dist_object&lt;distributed_obj_example&gt;</a> rmi;</div>
<div class="line">  ... initialization and constructor ...</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">   <span class="keywordtype">int</span> add_one(<span class="keywordtype">int</span> i) {</div>
<div class="line">     <span class="keywordflow">return</span> i + 1;</div>
<div class="line">   }</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">int</span> add_one_from_machine_1(<span class="keywordtype">int</span> i) {</div>
<div class="line">     <span class="comment">// calls the add_one function on machine 1 with the argument i</span></div>
<div class="line">     <span class="comment">// this call returns immediately</span></div>
<div class="line">     <a class="code" href="structgraphlab_1_1request__future.html">graphlab::request_future&lt;int&gt;</a> future =</div>
<div class="line">         object_future_remote_request(rmi, 1, &amp;distributed_obj_example::add_one, i);</div>
<div class="line"></div>
<div class="line">     <span class="comment">// ... we can do other stuff here</span></div>
<div class="line">     <span class="comment">// then when we want the answer</span></div>
<div class="line">     <span class="comment">// this is safe to do within a fiber as it will not halt other fibers.</span></div>
<div class="line">     <span class="keywordtype">int</span> result = future();</div>
<div class="line">     <span class="keywordflow">return</span> result;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classgraphlab_1_1dc__dist__object.html#a23845fd5c66033a13a5c689a65583f1b" title="Performs a blocking RPC call to the target machine to run the provided function pointer. ">graphlab::dc_dist_object::remote_request</a> <a class="el" href="classgraphlab_1_1dc__dist__object.html#a058fafc0d3650176df4457eb6f93968f" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::dc_dist_object::future_remote_request</a> <a class="el" href="namespacegraphlab.html#ae9e66287c580fe28c89478750b83f230" title="Performs a nonblocking RPC call to the target machine to run the provided function pointer which has ...">graphlab::fiber_remote_request</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rmiobj</td><td>The <a class="el" href="classgraphlab_1_1dc__dist__object.html" title="Provides a class with its own distributed communication context, allowing instances of the class to c...">dc_dist_object</a> to use to send the request. </td></tr>
    <tr><td class="paramname">targetmachine</td><td>The ID of the machine to run the function on </td></tr>
    <tr><td class="paramname">fn</td><td>The function to run on the target machine. Must be a pointer to member function in the owning object. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to send to Fn. Arguments must be serializable. and must be castable to the target types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a future templated around the same type as the return value of the called function </dd></dl>

</div>
</div>
<a class="anchor" id="af9cd9620ea366c265612aeebcfcc5e54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; graphlab::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uniongraphlab_1_1gl__uint128__t.html">gl_uint128_t</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the 128-bit integer as hexadecimal </p>

<p>Definition at line <a class="el" href="uint128_8hpp_source.html#l00071">71</a> of file <a class="el" href="uint128_8hpp_source.html">uint128.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad985d2f5fb507be6aa0332cd055bded5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename sizetype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::outofplace_shuffle </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; sizetype &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuffles a random access container inplace such at newcont[i] = cont[targets[i]] targets must be the same size as the container </p>

<p>Definition at line <a class="el" href="shuffle_8hpp_source.html#l00079">79</a> of file <a class="el" href="shuffle_8hpp_source.html">shuffle.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb801720e8591edca9e99bea084bcdcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string graphlab::pad_number </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>npad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>pad_value</em> = <code>'0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string representation of the number, padded to 'npad' characters using the pad_value character </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00418">418</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eeeb11ec6df09092a6c053ff7970e4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OldKey , typename NewKey , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;NewKey, T&gt; graphlab::rekey </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; OldKey, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; OldKey, NewKey &gt; &amp;&#160;</td>
          <td class="paramname"><em>key_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform each key in the map using the key_map transformation. The resulting map will have the form output[key_map[i]] = map[i] </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00192">192</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b9e0c3f1472be6c8c7d7f89ed901986"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename OldT , typename NewT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;Key, NewT&gt; graphlab::remap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, OldT &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; OldT, NewT &gt; &amp;&#160;</td>
          <td class="paramname"><em>val_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform each key in the map using the key_map transformation. The resulting map will have the form output[i] = remap[map[i]] </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00209">209</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6139b4e0b0662f65d4b283f828c7dd26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void graphlab::remap </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; T, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inplace version of remap </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00223">223</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4805b558a3ad75e687332f026c8ffc54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if_c&lt;boost::is_convertible&lt;Source, Target&gt;::value, Target&gt;::type graphlab::robust_cast </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>robust_cast performs a static cast from type A to type B if a cast can be done. Return B() otherwise </p>

<p>Definition at line <a class="el" href="robust__cast_8hpp_source.html#l00036">36</a> of file <a class="el" href="robust__cast_8hpp_source.html">robust_cast.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57d97a46db44e4d120787aaa5490a2e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; graphlab::safe_get </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constant lookup in a map. assertion failure of key not found in map </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00163">163</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3351861a051abcd43cbd132f451fbe5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T graphlab::safe_get </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constant lookup in a map. If key is not found in map, 'default_value' is returned. Note that this can't return a reference and must return a copy </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00177">177</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4b551c8c0884ee93ffb22d20dcedac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::set&lt;T&gt;,std::set&lt;T&gt; &gt; graphlab::set_partition </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>2 sets: &lt;s in partition, s not in partition&gt; </dd></dl>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00114">114</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77b8345221d70e487541998547d645c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T&gt; graphlab::set_union </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes the union of two sets. </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00070">70</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfd36f7771c6e227c8a90c2d08a3ca4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; graphlab::strsplit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>splitchars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>auto_trim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using splitchars as delimiters, splits the string into a vector of strings. if auto_trim is true, <a class="el" href="namespacegraphlab.html#ad87a901ac0e688b927ed71a06224c6c6">trim()</a> is called on all the extracted strings before returning. </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00442">442</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8565d1fc8a5474c7696a0d9e02ee4dc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string graphlab::tostr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function for using std streams to convert anything to a string </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00396">396</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad87a901ac0e688b927ed71a06224c6c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string graphlab::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes white space (space and tabs) from the beginning and end of str, returning the resultant string </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00385">385</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb8f631ef7e698460f144b74ffd6d3ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T&gt; graphlab::values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the values from a map </p>

<p>Definition at line <a class="el" href="stl__util_8hpp_source.html#l00330">330</a> of file <a class="el" href="stl__util_8hpp_source.html">stl_util.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a40ef7193898f623a0e7b462dc800b889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* graphlab::__thr_callback) () = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow defining a callback when thread is destroyed. This is needed at least from Java JNI, where we have to detach thread from JVM before it dies. </p>

<p>Definition at line <a class="el" href="pthread__tools_8cpp_source.html#l00189">189</a> of file <a class="el" href="pthread__tools_8cpp_source.html">pthread_tools.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:26 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
