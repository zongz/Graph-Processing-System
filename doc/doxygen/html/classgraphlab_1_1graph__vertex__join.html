<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::graph_vertex_join&lt; LeftGraph, RightGraph &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1graph__vertex__join.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgraphlab_1_1graph__vertex__join-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::graph_vertex_join&lt; LeftGraph, RightGraph &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides the ability to pass information between vertices of two different graphs.  
 <a href="classgraphlab_1_1graph__vertex__join.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="graph__vertex__join_8hpp_source.html">graphlab/graph/graph_vertex_join.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5cea976d066332ea7b5c4d77b8db292a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cea976d066332ea7b5c4d77b8db292a"></a>
typedef LeftGraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a5cea976d066332ea7b5c4d77b8db292a">left_graph_type</a></td></tr>
<tr class="memdesc:a5cea976d066332ea7b5c4d77b8db292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the left graph. <br /></td></tr>
<tr class="separator:a5cea976d066332ea7b5c4d77b8db292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10c170d4ec71796c5bb98bb569da05f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac10c170d4ec71796c5bb98bb569da05f"></a>
typedef RightGraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#ac10c170d4ec71796c5bb98bb569da05f">right_graph_type</a></td></tr>
<tr class="memdesc:ac10c170d4ec71796c5bb98bb569da05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the right graph. <br /></td></tr>
<tr class="separator:ac10c170d4ec71796c5bb98bb569da05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef14036dee106496b191344daf7fb12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ef14036dee106496b191344daf7fb12"></a>
typedef right_graph_type::vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a6ef14036dee106496b191344daf7fb12">left_vertex_type</a></td></tr>
<tr class="memdesc:a6ef14036dee106496b191344daf7fb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex Type of the left graph. <br /></td></tr>
<tr class="separator:a6ef14036dee106496b191344daf7fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae796156a6a5b805af8a431939d6369e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae796156a6a5b805af8a431939d6369e5"></a>
typedef left_graph_type::vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#ae796156a6a5b805af8a431939d6369e5">right_vertex_type</a></td></tr>
<tr class="memdesc:ae796156a6a5b805af8a431939d6369e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex Type of the right graph. <br /></td></tr>
<tr class="separator:ae796156a6a5b805af8a431939d6369e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943fe0b4506ff420ac83c0f42cc6b5b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a943fe0b4506ff420ac83c0f42cc6b5b3"></a>
typedef right_graph_type::local_vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a943fe0b4506ff420ac83c0f42cc6b5b3">left_local_vertex_type</a></td></tr>
<tr class="memdesc:a943fe0b4506ff420ac83c0f42cc6b5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Vertex Type of the left graph. <br /></td></tr>
<tr class="separator:a943fe0b4506ff420ac83c0f42cc6b5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757200afb320b728582fa53632568b47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a757200afb320b728582fa53632568b47"></a>
typedef left_graph_type::local_vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a757200afb320b728582fa53632568b47">right_local_vertex_type</a></td></tr>
<tr class="memdesc:a757200afb320b728582fa53632568b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Vertex Type of the right graph. <br /></td></tr>
<tr class="separator:a757200afb320b728582fa53632568b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7638fbad62d5526b964e1a7fe095d08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7638fbad62d5526b964e1a7fe095d08"></a>
typedef right_graph_type::vertex_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#aa7638fbad62d5526b964e1a7fe095d08">left_data_type</a></td></tr>
<tr class="memdesc:aa7638fbad62d5526b964e1a7fe095d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex Data Type of the left graph. <br /></td></tr>
<tr class="separator:aa7638fbad62d5526b964e1a7fe095d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965b6e4319d8137ac2ca81bf76d8b314"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a965b6e4319d8137ac2ca81bf76d8b314"></a>
typedef left_graph_type::vertex_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a965b6e4319d8137ac2ca81bf76d8b314">right_data_type</a></td></tr>
<tr class="memdesc:a965b6e4319d8137ac2ca81bf76d8b314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex Data Type of the right graph. <br /></td></tr>
<tr class="separator:a965b6e4319d8137ac2ca81bf76d8b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a217841480619a91c6cadd4e57da9b35e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217841480619a91c6cadd4e57da9b35e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>graph_vertex_join</b> (<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;dc, <a class="el" href="classgraphlab_1_1graph__vertex__join.html#a5cea976d066332ea7b5c4d77b8db292a">left_graph_type</a> &amp;left, <a class="el" href="classgraphlab_1_1graph__vertex__join.html#ac10c170d4ec71796c5bb98bb569da05f">right_graph_type</a> &amp;right)</td></tr>
<tr class="separator:a217841480619a91c6cadd4e57da9b35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff5ba3f517d7fb13fc98865c2999fc2"><td class="memTemplParams" colspan="2">template&lt;typename LeftEmitKey , typename RightEmitKey &gt; </td></tr>
<tr class="memitem:a8ff5ba3f517d7fb13fc98865c2999fc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a8ff5ba3f517d7fb13fc98865c2999fc2">prepare_injective_join</a> (LeftEmitKey left_emit_key, RightEmitKey right_emit_key)</td></tr>
<tr class="memdesc:a8ff5ba3f517d7fb13fc98865c2999fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the join by associating each vertex with a key.  <a href="#a8ff5ba3f517d7fb13fc98865c2999fc2">More...</a><br /></td></tr>
<tr class="separator:a8ff5ba3f517d7fb13fc98865c2999fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c10fa2e5d9957b9a49ef6a75f639068"><td class="memTemplParams" colspan="2">template&lt;typename JoinOp &gt; </td></tr>
<tr class="memitem:a2c10fa2e5d9957b9a49ef6a75f639068"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a2c10fa2e5d9957b9a49ef6a75f639068">left_injective_join</a> (JoinOp join_op)</td></tr>
<tr class="memdesc:a2c10fa2e5d9957b9a49ef6a75f639068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an injective join from the right graph to the left graph.  <a href="#a2c10fa2e5d9957b9a49ef6a75f639068">More...</a><br /></td></tr>
<tr class="separator:a2c10fa2e5d9957b9a49ef6a75f639068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c309b1b16e83efa1f8938dd5fc2313"><td class="memTemplParams" colspan="2">template&lt;typename JoinOp &gt; </td></tr>
<tr class="memitem:af5c309b1b16e83efa1f8938dd5fc2313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1graph__vertex__join.html#af5c309b1b16e83efa1f8938dd5fc2313">right_injective_join</a> (JoinOp join_op)</td></tr>
<tr class="memdesc:af5c309b1b16e83efa1f8938dd5fc2313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an injective join from the left graph to the right graph.  <a href="#af5c309b1b16e83efa1f8938dd5fc2313">More...</a><br /></td></tr>
<tr class="separator:af5c309b1b16e83efa1f8938dd5fc2313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:add848d04c0e1a4ca4c53a4b3598e1340"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add848d04c0e1a4ca4c53a4b3598e1340"></a>
<a class="el" href="classgraphlab_1_1dc__dist__object.html">dc_dist_object</a>&lt; <a class="el" href="classgraphlab_1_1graph__vertex__join.html">graph_vertex_join</a>&lt; LeftGraph, RightGraph &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rmi</b></td></tr>
<tr class="separator:add848d04c0e1a4ca4c53a4b3598e1340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename LeftGraph, typename RightGraph&gt;<br />
class graphlab::graph_vertex_join&lt; LeftGraph, RightGraph &gt;</h3>

<p>Provides the ability to pass information between vertices of two different graphs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LeftGraph</td><td>Type of the left graph </td></tr>
    <tr><td class="paramname">RightGraph</td><td>Type of the right graph</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classgraphlab_1_1graph__vertex__join.html" title="Provides the ability to pass information between vertices of two different graphs. ">graph_vertex_join</a> class allows information to be passed between vertices of two different graphs.</p>
<p>Given two graphs <code>g1</code> and <code>g2</code>, possibly of different types:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> distributed_graph&lt;VData1, EData1&gt; graph_1_type;</div>
<div class="line"><span class="keyword">typedef</span> distributed_graph&lt;VData2, EData2&gt; graph_2_type;</div>
<div class="line">graph_1_type g1;</div>
<div class="line">graph_2_type g2;</div>
</div><!-- fragment --><p>A <a class="el" href="classgraphlab_1_1graph__vertex__join.html" title="Provides the ability to pass information between vertices of two different graphs. ">graph_vertex_join</a> object can be created: </p><div class="fragment"><div class="line">graph_vertex_type&lt;graph_1_type, graph_2_type&gt; vjoin(dc, g1, g2);</div>
</div><!-- fragment --><p>The first argument is the distributed control object. The second argument shall be referred to as the graph on the "left" side of the join, and the third argument shall be referred to as the graph on the "right" side of the join.</p>
<p>The join operates by having each vertex in both graph emit an integer key. Vertices with the same key are then combined into the same group. The semantics of the key depends on the join operation to be performed. Right now, the only join operation supported is the Left Injective Join and the Right Injective Join (see below).</p>
<h2>Left Injective Join</h2>
<p>For the left injective join, vertices in the same graph must emit distinct unique keys. i.e. Each vertex in <code>g1</code> must emit a key which is different from all other vertices in <code>g1</code>. Vertices on the right graph are then matched with vertices on the left graph with the same key. The join operation is then allowed to modify vertices on the left graph given the data on the vertices of the right graph.</p>
<p>To emit the keys: </p><div class="fragment"><div class="line">vjoin.prepare_injective_join(left_emit_key, right_emit_key);</div>
</div><!-- fragment --><p> left_emit_key and right_emit_key are functions (or lambda) with the following prototype: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> left_emit_key(<span class="keyword">const</span> graph_1_type::vertex_type&amp; vertex);</div>
<div class="line"><span class="keywordtype">size_t</span> right_emit_key(<span class="keyword">const</span> graph_2_type::vertex_type&amp; vertex);</div>
</div><!-- fragment --><p> They essentially take as a constant argument, the vertex of their respective graphs, and return an integer key. If the key has value (-1) it does not participate in the join. After keys are emitted and prepared with prepare_join, to perform a left injective join: </p><div class="fragment"><div class="line">vjoin.left_injective_join(join_op);</div>
</div><!-- fragment --><p> Where join_op is a function with the following prototype: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> join_op(graph_1_type::vertex_type&amp; left_vertex, </div>
<div class="line">             <span class="keyword">const</span> graph_2_type::vertex_data_type right_vertex_data);</div>
</div><!-- fragment --><p> Note the asymmetry in the arguments: the left vertex is passed as a vertex_type, while for the right vertex, only the vertex data is accessible. The function may make modifications on the left vertex.</p>
<p>The <a class="el" href="classgraphlab_1_1graph__vertex__join.html#a2c10fa2e5d9957b9a49ef6a75f639068" title="Performs an injective join from the right graph to the left graph. ">left_injective_join()</a> function must be called by all machines. As a result, it may be used from within an engine's <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a">graphlab::iengine::add_vertex_aggregator</a> aggregator's finalize function.</p>
<h3>Left Injective Join Example</h3>
<p>I have two graphs with identical structure. The left graph has data </p><div class="fragment"><div class="line"><span class="keyword">struct </span>left_vertex_data {</div>
<div class="line">  <span class="keywordtype">size_t</span> user_id;</div>
<div class="line">  std::string user_name;</div>
<div class="line">  std::string email_address;</div>
<div class="line">  <span class="comment">// ... serializers omitted ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">typedef</span> distributed_graph&lt;left_vertex_data, some_edge_data&gt; <a class="code" href="classgraphlab_1_1graph__vertex__join.html#a5cea976d066332ea7b5c4d77b8db292a">left_graph_type</a>;</div>
</div><!-- fragment --><p> However, when the left graph was constructed, there was no email address information conveniently available, and thus was left blank.</p>
<p>And the right graph has vertex data: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>right_vertex_data {</div>
<div class="line">  <span class="keywordtype">size_t</span> user_id;</div>
<div class="line">  std::string email_address;</div>
<div class="line">  <span class="comment">// ... serializers omitted ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">typedef</span> distributed_graph&lt;right_vertex_data, some_edge_data&gt; <a class="code" href="classgraphlab_1_1graph__vertex__join.html#ac10c170d4ec71796c5bb98bb569da05f">right_graph_type</a>;</div>
</div><!-- fragment --><p> which was loaded from some other source, and contains all the email address information.</p>
<p>I create emit functions for both graphs : </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> emit_user_id_field_left(<span class="keyword">const</span> left_graph_type::vertex_type&amp; vtype) {</div>
<div class="line">  <span class="keywordflow">return</span> vtype.data().user_id;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">size_t</span> emit_user_id_field_left(<span class="keyword">const</span> right_graph_type::vertex_type&amp; vtype) {</div>
<div class="line">  <span class="keywordflow">return</span> vtype.data().user_id;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Create a join object and prepare the join: </p><div class="fragment"><div class="line">graph_vertex_join&lt;left_graph_type, right_graph_type&gt; vjoin(dc, </div>
<div class="line">                                                           left_graph, </div>
<div class="line">                                                           right_graph);</div>
<div class="line">vjoin.prepare_injective_join(emit_user_id_field_left, </div>
<div class="line">                             emit_user_id_field_right);</div>
</div><!-- fragment --><p>To copy the email address field from the right graph to the left graph: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> join_email_address(left_graph_type::vertex_type&amp; left_vertex,</div>
<div class="line">                        <span class="keyword">const</span> right_vertex_data&amp; rvtx) {</div>
<div class="line">  left_vertex.data().email_address = rvtx.email_address; </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">vjoin.left_injective_join(join_email_address);</div>
</div><!-- fragment --><h2>Right Injective Join</h2>
<p>The right injective join is similar to the left injective join, but with types reversed. </p>

<p>Definition at line <a class="el" href="graph__vertex__join_8hpp_source.html#l00171">171</a> of file <a class="el" href="graph__vertex__join_8hpp_source.html">graph_vertex_join.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2c10fa2e5d9957b9a49ef6a75f639068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftGraph , typename RightGraph &gt; </div>
<div class="memtemplate">
template&lt;typename JoinOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1graph__vertex__join.html">graphlab::graph_vertex_join</a>&lt; LeftGraph, RightGraph &gt;::left_injective_join </td>
          <td>(</td>
          <td class="paramtype">JoinOp&#160;</td>
          <td class="paramname"><em>join_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an injective join from the right graph to the left graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JoinOp</td><td>The type of the joinop function. It should not be necessary to specify this. C++ type inference should be able to infer this automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_op</td><td>The joining function. May be a function pointer or a lambda matching the prototype void join_op(LeftGraph::vertex_type&amp; left_vertex, const RightGraph::vertex_data_type right_vertex_data);</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a8ff5ba3f517d7fb13fc98865c2999fc2" title="Initializes the join by associating each vertex with a key. ">prepare_injective_join()</a> must be called before hand. All machines must call this function. join_op will be called on each left vertex with the data on a right vertex which emitted the same key in <a class="el" href="classgraphlab_1_1graph__vertex__join.html#a8ff5ba3f517d7fb13fc98865c2999fc2" title="Initializes the join by associating each vertex with a key. ">prepare_injective_join()</a>. The join_op function is allowed to modify the vertex data on the left graph. </p>

<p>Definition at line <a class="el" href="graph__vertex__join_8hpp_source.html#l00304">304</a> of file <a class="el" href="graph__vertex__join_8hpp_source.html">graph_vertex_join.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ff5ba3f517d7fb13fc98865c2999fc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftGraph , typename RightGraph &gt; </div>
<div class="memtemplate">
template&lt;typename LeftEmitKey , typename RightEmitKey &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1graph__vertex__join.html">graphlab::graph_vertex_join</a>&lt; LeftGraph, RightGraph &gt;::prepare_injective_join </td>
          <td>(</td>
          <td class="paramtype">LeftEmitKey&#160;</td>
          <td class="paramname"><em>left_emit_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RightEmitKey&#160;</td>
          <td class="paramname"><em>right_emit_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the join by associating each vertex with a key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LeftEmitKey</td><td>Type of the left_emit_key parameter. It should not be necessary to specify this. C++ type inference should be able to infer this automatically. </td></tr>
    <tr><td class="paramname">RightEmitKey</td><td>Type of the right_emit_key parameter. It should not be necessary to specify this. C++ type inference should be able to infer this automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_emit_key</td><td>A function which takes a vertex_type from the left graph and emits an integral key value. Can be a lambda, of the prototype: size_t left_emit_key(const LeftGraph::vertex_type&amp; vertex); </td></tr>
    <tr><td class="paramname">right_emit_key</td><td>A function which takes a vertex_type from the right graph and emits an integral key value. Can be a lambda, of the prototype: size_t right_emit_key(const RightGraph::vertex_type&amp; vertex);</td></tr>
  </table>
  </dd>
</dl>
<p>The semantics of the key depend on the actual join operation performed. This function must be called by all machines.</p>
<p>left_emit_key and right_emit_key are functions (or lambda) with the following prototype: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> left_emit_key(<span class="keyword">const</span> graph_1_type::vertex_type&amp; vertex);</div>
<div class="line"><span class="keywordtype">size_t</span> right_emit_key(<span class="keyword">const</span> graph_2_type::vertex_type&amp; vertex);</div>
</div><!-- fragment --><p> They essentially take as a constant argument, the vertex of their respective graphs, and return an integer key. If a vertex emits the key (size_t)(-1) it does not participate in the join.</p>
<p><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a8ff5ba3f517d7fb13fc98865c2999fc2" title="Initializes the join by associating each vertex with a key. ">prepare_injective_join()</a> only needs to be called once. After which an arbitrary number of <a class="el" href="classgraphlab_1_1graph__vertex__join.html#a2c10fa2e5d9957b9a49ef6a75f639068" title="Performs an injective join from the right graph to the left graph. ">left_injective_join()</a> and <a class="el" href="classgraphlab_1_1graph__vertex__join.html#af5c309b1b16e83efa1f8938dd5fc2313" title="Performs an injective join from the left graph to the right graph. ">right_injective_join()</a> calls may be made.</p>
<p>If after a join, a new join is to be performed on the same graph using new data, or new emit functions, <a class="el" href="classgraphlab_1_1graph__vertex__join.html#a8ff5ba3f517d7fb13fc98865c2999fc2" title="Initializes the join by associating each vertex with a key. ">prepare_injective_join()</a> can be called again to recompute the join. </p>

<p>Definition at line <a class="el" href="graph__vertex__join_8hpp_source.html#l00255">255</a> of file <a class="el" href="graph__vertex__join_8hpp_source.html">graph_vertex_join.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5c309b1b16e83efa1f8938dd5fc2313"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftGraph , typename RightGraph &gt; </div>
<div class="memtemplate">
template&lt;typename JoinOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1graph__vertex__join.html">graphlab::graph_vertex_join</a>&lt; LeftGraph, RightGraph &gt;::right_injective_join </td>
          <td>(</td>
          <td class="paramtype">JoinOp&#160;</td>
          <td class="paramname"><em>join_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an injective join from the left graph to the right graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JoinOp</td><td>The type of the joinop function. It should not be necessary to specify this. C++ type inference should be able to infer this automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_op</td><td>The joining function. May be a function pointer or a lambda matching the prototype void join_op(RightGraph::vertex_type&amp; right_vertex, const LeftGraph::vertex_data_type left_vertex_data);</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classgraphlab_1_1graph__vertex__join.html#a8ff5ba3f517d7fb13fc98865c2999fc2" title="Initializes the join by associating each vertex with a key. ">prepare_injective_join()</a> must be called before hand. All machines must call this function. join_op will be called on each rght vertex with the data on a left vertex which emitted the same key in <a class="el" href="classgraphlab_1_1graph__vertex__join.html#a8ff5ba3f517d7fb13fc98865c2999fc2" title="Initializes the join by associating each vertex with a key. ">prepare_injective_join()</a>. The join_op function is allowed to modify the vertex data on the right graph. </p>

<p>Definition at line <a class="el" href="graph__vertex__join_8hpp_source.html#l00330">330</a> of file <a class="el" href="graph__vertex__join_8hpp_source.html">graph_vertex_join.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/graph/<a class="el" href="graph__vertex__join_8hpp_source.html">graph_vertex_join.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1graph__vertex__join.html">graph_vertex_join</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:27 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
