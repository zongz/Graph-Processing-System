<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: Topic Modeling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('topic_modeling.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Topic Modeling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The topic modeling toolkit contains a collection of applications targeted at clustering documents and extracting topical representations. The resulting topical representation can be used as a feature space in information retrieval tasks and to group topically related words and documents.</p>
<p>Currently the text modeling toolkit implements a fast asynchronous collapsed Gibbs sampler for the widely used Latent Dirichlet Allocation (LDA) model. In the near future we plan to add a Collapsed Variational Bayesian inference algorithm for the LDA model as well as some more general topic models.</p>
<h1><a class="anchor" id="lda_model"></a>
The LDA Model</h1>
<p>The <a href="http://en.wikipedia.org/wiki/Latent_Dirichlet_allocation">LDA model </a> associates a topic id with each token (word) in each document in the input corpus. Conceptually, topic ids correspond to semantic groups like "foods", "colors", and "politics" however the association between the id 1, 2, ..., N and the particular topic meaning "foods", "colors", ... is not know in advance and can be resolved by running the approximate inference algorithm. In addition the LDA model assigns a distribution over topics to each document and a distribution over term to each topic. The the topic id for each token is drawn from the topic distribution for each document. The actual word is then drawn from the term distribution for that topic. At a high-level the LDA model encodes the following intuitive assumptions:</p>
<ul>
<li>Words in the same document are topically related.</li>
</ul>
<ul>
<li>Documents that share common terms are topically related.</li>
</ul>
<p>Solving for the latent topic assignments of each token as well as the topic distribution for each document and the term distribution for each topic is a challenging (NP-Hard) task. Fortunately there are several approximate inference algorithms that typically can resolve coherent posterior estimates for the LDA model.</p>
<h2><a class="anchor" id="collapsed_gibbs"></a>
The Collapsed Gibbs Sampler</h2>
<p>The topic modeling toolkit currently implements an asynchronous variant of the Collapsed Gibbs Sampler described by Griffiths and Steyvers in their landmark paper <a href="http://www.pnas.org/content/101/suppl.1/5228.full.pdf">Finding Scientific Topics</a>. The collapsed Gibbs sampler is a Markov Chain Monte Carlo (MCMC) algorithm which generates a sequence of topic assignments for each token that in the limit converge to a sequence of samples drawn from the posterior distribution. In practice the algorithm is run for a sufficient long time to allow the topics to "converge" (sometimes referred to as burn-in) and then the last few samples are used to estimate the posterior distribution over topics for each document and the posterior distribution over words for each topic.</p>
<h2><a class="anchor" id="parallel_collapsed_gibbs"></a>
The Parallel Collapsed Gibbs Sampler</h2>
<p>The parallelization of the Collapsed Gibbs Sampler is achieved by drawing new assignments for multiple tokens simultaneously using a method that is similar to that described by Ahmed et al. (<a href="http://dl.acm.org/authorize.cfm?key=6666391">Paper</a>). Unfortunately, the collapsed LDA model used to accelerate mixing of the Gibbs sampler also eliminates any conditional independence structure needed to obtain a parallel ergodic sampler as described by Gonzalez et al. (<a href="http://www.select.cs.cmu.edu/publications/paperdir/aistats2011-gonzalez-low-gretton-guestrin.pdf">Paper</a>)</p>
<p>However, by mapping the collapsed Gibbs sampler into the GraphLab abstraction we obtain a statistically more efficient algorithm. To implement the collapsed Gibbs sampler in GraphLab we construct a bipartite graph connecting each document with terms that occur in that document. Each edge contains the token count and latent topic assignments for that token. The GraphLab update function maintains the term and document counts during the gather and apply phases and then samples new values for the tokens on the scatter phase. We exploit local atomic integer operations and the GraphLab caching model to immediately propagate changes. The asynchronous consistency model ensures that only one token per document term pair is sampled at a time improving upon the original formulation of the asynchronous Gibbs sampler described by Ahmed et al. (<a href="http://dl.acm.org/authorize.cfm?key=6666391">Paper</a>) or the sampler described by Asuncion et al. (<a href="http://www.ics.uci.edu/~asuncion/pubs/NIPS_08.pdf">Paper</a>).</p>
<h1>cgs_lda_usage Usage </h1>
<p>The collapsed Gibbs sampler application (cgs_lda.cpp) takes as an input a text corpus represented as one or more token files. Each token consists of lines in the form:</p>
<pre class="fragment">&lt;docid&gt; &lt;wordid&gt; &lt;count&gt;
</pre><p>for example a file containing:</p>
<pre class="fragment">0    0     2
0    4     1
1    2     3
</pre><p>implies that the word with id 0 occurs twice in document 0, the word with id 4 occurs once in document 0, and the word with id 2 occurs three times in document 1.</p>
<p>On termination the system outputs for each term the number of occurrences of that term that have been assigned to each topic and for each document the number of tokens assigned to each document.</p>
<h2><a class="anchor" id="cgs_lda_example"></a>
Example</h2>
<p>To demonstrate how the CGS LDA application works we have obtained a copy of the Daily Kos bag-of-words data from the <a href="http://archive.ics.uci.edu/ml/datasets/Bag+of+Words">UCI Repository </a> and reformatted it for the cgs_lda application. You can download the reformatted data from <a href="http://code.google.com/p/graphlabapi/downloads/detail?name=daily_kos.tar.bz2">here</a>. Once extracted the folder contains:</p>
<pre class="fragment">&gt; ls -lR daily_kos
total 120
-rw-r--r--  1 jegonzal  staff    904 Jul  1 22:37 README
-rw-r--r--@ 1 jegonzal  staff  55467 Jul  1 22:21 dictionary.txt
drwxr-xr-x  3 jegonzal  staff    102 Jul  1 22:21 tokens

./tokens:
total 7960
-rw-r--r--  1 jegonzal  staff  4074516 Jul  1 22:21 doc_word_count.tsv
</pre><p>To run the CGS_LDA GraphLab application on a single machine we simply run: </p><pre class="fragment">&gt; ./cgs_lda --corpus ./daily_kos/tokens --dictionary ./daily_kos/dictionary.txt
</pre><p>This will run indefinitley display the top words in each topic every 10 seconds. To help visualize the output if you open the webpage </p><pre class="fragment">graphlab/toolkits/topic_modeling/http/index.html
</pre><p> We render a word cloud webpage that connects directly to the cgs_lda appliction's internal web-server running on localhost port 8090.</p>
<p>In most cases we will also be interested in collecting the final assignments. This can be done by running: </p><pre class="fragment">&gt; ./cgs_lda --corpus ./daily_kos/tokens --dictionary ./daily_kos/dictionary.txt \
   --word_dir word_counts --doc_dir doc_counts --burnin=60 
</pre><p>This will run the cgs_lda sampler for roughly 60 seconds and the save the counts of tokens in each topic for the words and documents in the files <code>word_counts_x_of_x</code> and <code>doc_counts_x_of_x</code> . If instead you would like to save the counts to seperate folders you can prepend the folder path.</p>
<p>By default GraphLab runs with two threads. However we can increase the parallelism on a single machine by increasing the number of threads: </p><pre class="fragment">&gt; ./cgs_lda --corpus ./daily_kos/tokens --dictionary ./daily_kos/dictionary.txt \
  --ncpus=8
</pre><p>The cgs_lda application can run in the distributed setting as well simply by using MPI to launch it: </p><pre class="fragment">&gt; mpiexec --hostfile machine_list.txt -n 16 ./cgs_lda \
  --corpus ./daily_kos/tokens --dictionary ./daily_kos/dictionary.txt \
  --ncpus=8
</pre><p>This will run 16 instances each consuming 8 on the machines in the <code>machine_list.txt</code> file. Each of these instances will automatically communicate splitting the work as well as the memory requirements. It is really that easy!</p>
<p>Since we are running in the distributed setting it is convenient to be able to read and write to a distributed filesystem. We have built HDFS support into the GraphLab abstraction therefore we can simply change the arguments to be: </p><pre class="fragment">&gt; mpiexec --hostfile machine_list.txt -n 16 ./cgs_lda \
  --corpus hdfs://bros.ml.cmu.edu/daily_kos/tokens \
  --dictionary hdfs://bros.ml.cmu.edu/daily_kos/dictionary.txt \
  --ncpus=8
</pre><h1><a class="anchor" id="convergence"></a>
Tracking progress</h1>
<p>We have added a Likelihood printout every interval seconds (defined using the &ndash;interval command line argument) which captures the convergence progress of the LDA algorithm. The Likelihood should go up every interval.</p>
<h1><a class="anchor" id="cgs_lda_options"></a>
Command Line Options</h1>
<p>There are a wide range of options available when calling the cgs_lda program:</p>
<ul>
<li><b>&ndash;corpus</b> <em>Required</em> The path to the token file(s). This can be a folder, a file, or a folder plus a file prefix. In addition this can be a path in hdfs (e.g., hdfs://namenode/tokens/).</li>
</ul>
<ul>
<li><b>&ndash;help</b> Display the help screen listing the available options</li>
</ul>
<ul>
<li><b>&ndash;dictionary</b> (Optional) The path to the dictionary file. This can be a local path or a path on hdfs (e.g., hdfs://namenode/dictionary.txt). If no dictionary is provided then incremental topk words lists will not be generated and the word list webpage will not be available.</li>
</ul>
<ul>
<li><b>&ndash;engine</b> (Optional, Default: asynchronous) The engine type to use when executing the vertex program. Accepted values are:<ul>
<li><b>synchronous</b>: All tokens are sampled simultaneously leading to faster computation but slower convergence.</li>
<li><b>asynchronous</b>: Tokens are sampled as resources become available and token conditionals are updated immediately after sampling. This reduces parallelism and sampling speed but increases the rate of convergence.</li>
</ul>
</li>
</ul>
<ul>
<li><b>&ndash;ntopics</b> (Optional, Default: 50) The number of topics to use in the LDA model. Using fewer topics will increase speed and result in more "mixed" concepts. Using more topics will slow down sampling but lead to more specific topics.</li>
</ul>
<ul>
<li><b>&ndash;alpha</b> (Optional, Default 1) The hyper-parameter for the topic distribution for each document. Larger values imply documents have a more uniform mix of topics. Smaller values (less than one) imply that documents are more focused on a small subsets of topics. Note that smaller values also slow down convergence of the sampler.</li>
</ul>
<ul>
<li><b>&ndash;beta</b> (Optional, Default 0.1) The hyper-parameter for the word distribution in each topic. Larger values imply that topics contain all words equally and smaller values (less than one) imply that topics are focused on a small set of words. Note that smaller values also slow down convergence of the sampler.</li>
</ul>
<ul>
<li><b>&ndash;topk</b> (Optional, Default 5) The number of words to show in each topic when incrementally listing the top words in each topic. This also affects the word cloud viewer.</li>
</ul>
<ul>
<li><b>&ndash;interval</b> (Optional, Default 10) The time in seconds between when the incremental listing of top words is presented.</li>
</ul>
<ul>
<li><b>&ndash;max_count</b> (Optional, Default 100) The maximum number of occurrences of a token in a document. If a token occurs more than <code>max_count</code> then it is reported as occurring <code>max_count</code> times. This ensures that overly frequent words do not dominate documents.</li>
</ul>
<ul>
<li><b>&ndash;loadjson</b> (Optional, Default false) This flag is used to turn on the experimental JSON graph loader that reads graphs constructed using external graph builder libraries. If set to true then the <code>&ndash;corpus</code> argument must point to the JSON files.</li>
</ul>
<ul>
<li><b>&ndash;burnin</b> (Optional, Default -1) The time in seconds to run the sampler before the sample is saved to file (and the sampler terminates). If the value is less than zero then the sample will run indefinitely.</li>
</ul>
<ul>
<li><b>&ndash;doc_dir</b> (Optional, Default empty) The location (path/prefix) to save the final topic counts for each document after burnin. This can also be an hdfs path (e.g., hdfs://namenode/folder/prefix). If this is not set then the per document topic counts are not saved.</li>
</ul>
<ul>
<li><b>&ndash;word_dir</b> (Optional, Default empty) The location (path/prefix) to save the final topic counts for each word after burnin. This can also be an hdfs path (e.g., hdfs://namenode/folder/prefix). If this is not set then the per word topic counts are not saved.</li>
</ul>
<ul>
<li><b>&ndash;ncpus</b> (Optional, Default 2) The number of local computation threads to use on each machine. This should typically match the number of physical cores.</li>
</ul>
<ul>
<li><b>&ndash;scheduler</b> (Optional, Default sweep) The scheduler to use when running with the asynchronous engine. The default is typically sufficient.</li>
</ul>
<ul>
<li><b>&ndash;engine_opts</b> (Optional, Default empty) Any additional engine options. See <b>&ndash;engine_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;graph_opts</b> (Optional, Default empty) Any additional graph options. See <b>&ndash;graph_help</b> for a list of options.</li>
</ul>
<ul>
<li><b>&ndash;scheduler_opts</b> (Optional, Default empty) Any additional scheduler options. See <b>&ndash;scheduler_help</b> for a list of options. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="toolkits.html">GraphLab Toolkits</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:26 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
