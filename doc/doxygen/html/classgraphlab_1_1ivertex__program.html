<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::ivertex_program&lt; Graph, GatherType, MessageType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1ivertex__program.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgraphlab_1_1ivertex__program-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::ivertex_program&lt; Graph, GatherType, MessageType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classgraphlab_1_1ivertex__program.html" title="The ivertex_program class defines the vertex program interface that all vertex programs should extend...">ivertex_program</a> class defines the vertex program interface that all vertex programs should extend and implement. The vertex-program is used to encode the user-define computation in a GraphLab program.  
 <a href="classgraphlab_1_1ivertex__program.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ivertex__program_8hpp_source.html">graphlab/vertex_program/ivertex_program.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab20a4608d1c3109031f5fd5a3da35b36"><td class="memItemLeft" align="right" valign="top">typedef Graph::vertex_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#ab20a4608d1c3109031f5fd5a3da35b36">vertex_data_type</a></td></tr>
<tr class="memdesc:ab20a4608d1c3109031f5fd5a3da35b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined vertex data associated with each vertex in the graph (see <a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">distributed_graph::vertex_data_type</a>).  <a href="#ab20a4608d1c3109031f5fd5a3da35b36">More...</a><br /></td></tr>
<tr class="separator:ab20a4608d1c3109031f5fd5a3da35b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a053f524199859ce209eef4d6cac486"><td class="memItemLeft" align="right" valign="top">typedef Graph::edge_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a4a053f524199859ce209eef4d6cac486">edge_data_type</a></td></tr>
<tr class="memdesc:a4a053f524199859ce209eef4d6cac486"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined edge data associated with each edge in the graph.  <a href="#a4a053f524199859ce209eef4d6cac486">More...</a><br /></td></tr>
<tr class="separator:a4a053f524199859ce209eef4d6cac486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a026fca976fd6b0f0c00bab2df076f"><td class="memItemLeft" align="right" valign="top">typedef GatherType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a></td></tr>
<tr class="memdesc:a80a026fca976fd6b0f0c00bab2df076f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined gather type is used to accumulate the results of the gather function during the gather phase and must implement the operator += operation.  <a href="#a80a026fca976fd6b0f0c00bab2df076f">More...</a><br /></td></tr>
<tr class="separator:a80a026fca976fd6b0f0c00bab2df076f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca29f15f893bf77e89e5ffd6f572e48"><td class="memItemLeft" align="right" valign="top">typedef MessageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a></td></tr>
<tr class="separator:a9ca29f15f893bf77e89e5ffd6f572e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbde69d82102416f106230ec726e5d55"><td class="memItemLeft" align="right" valign="top">typedef Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#acbde69d82102416f106230ec726e5d55">graph_type</a></td></tr>
<tr class="memdesc:acbde69d82102416f106230ec726e5d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph type associative with this vertex program.  <a href="#acbde69d82102416f106230ec726e5d55">More...</a><br /></td></tr>
<tr class="separator:acbde69d82102416f106230ec726e5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c67ea0ab5120901645c011194af583"><td class="memItemLeft" align="right" valign="top">typedef graph_type::vertex_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a73c67ea0ab5120901645c011194af583">vertex_id_type</a></td></tr>
<tr class="memdesc:a73c67ea0ab5120901645c011194af583"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique integer id used to reference vertices in the graph.  <a href="#a73c67ea0ab5120901645c011194af583">More...</a><br /></td></tr>
<tr class="separator:a73c67ea0ab5120901645c011194af583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccdf8e6d9dc71934b0349b3305363ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a></td></tr>
<tr class="memdesc:adccdf8e6d9dc71934b0349b3305363ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opaque vertex object type used to get vertex information.  <a href="#adccdf8e6d9dc71934b0349b3305363ed">More...</a><br /></td></tr>
<tr class="separator:adccdf8e6d9dc71934b0349b3305363ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bc6ae6da912edc52420c0da1e4749d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a84bc6ae6da912edc52420c0da1e4749d">edge_type</a></td></tr>
<tr class="memdesc:a84bc6ae6da912edc52420c0da1e4749d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opaque edge_object type used to access edge information.  <a href="#a84bc6ae6da912edc52420c0da1e4749d">More...</a><br /></td></tr>
<tr class="separator:a84bc6ae6da912edc52420c0da1e4749d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f02e25c4899bd3d3d3edc9037eeb6b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">graphlab::edge_dir_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a88f02e25c4899bd3d3d3edc9037eeb6b">edge_dir_type</a></td></tr>
<tr class="memdesc:a88f02e25c4899bd3d3d3edc9037eeb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to define the direction of edges used in gather and scatter.  <a href="#a88f02e25c4899bd3d3d3edc9037eeb6b">More...</a><br /></td></tr>
<tr class="separator:a88f02e25c4899bd3d3d3edc9037eeb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bff8bb9a8ce3ba0bdbd34102a7be3b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1icontext.html">icontext</a>&lt; <a class="el" href="classgraphlab_1_1ivertex__program.html#acbde69d82102416f106230ec726e5d55">graph_type</a>, <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a>, <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a></td></tr>
<tr class="memdesc:a47bff8bb9a8ce3ba0bdbd34102a7be3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context type is used by the vertex program to communicate with the engine.  <a href="#a47bff8bb9a8ce3ba0bdbd34102a7be3b">More...</a><br /></td></tr>
<tr class="separator:a47bff8bb9a8ce3ba0bdbd34102a7be3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adaea0e05a24b62d3597e023291c418d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaea0e05a24b62d3597e023291c418d5"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#adaea0e05a24b62d3597e023291c418d5">~ivertex_program</a> ()</td></tr>
<tr class="memdesc:adaea0e05a24b62d3597e023291c418d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard virtual destructor for an abstract class. <br /></td></tr>
<tr class="separator:adaea0e05a24b62d3597e023291c418d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad371b64021ac80eaae332319dec41723"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">init</a> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;<a class="el" href="classgraphlab_1_1context.html">context</a>, const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;vertex, const <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a> &amp;msg)</td></tr>
<tr class="memdesc:ad371b64021ac80eaae332319dec41723"><td class="mdescLeft">&#160;</td><td class="mdescRight">This called by the engine to receive a message to this vertex program. The vertex program can use this to initialize any state before entering the gather phase. The init function is invoked <em>once</em> per execution of the vertex program.  <a href="#ad371b64021ac80eaae332319dec41723">More...</a><br /></td></tr>
<tr class="separator:ad371b64021ac80eaae332319dec41723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b978b86d8c8a47f68f1647b630887f8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">gather_edges</a> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;<a class="el" href="classgraphlab_1_1context.html">context</a>, const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;vertex) const </td></tr>
<tr class="memdesc:a7b978b86d8c8a47f68f1647b630887f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of edges on which to run the gather function. The default edge direction is in edges.  <a href="#a7b978b86d8c8a47f68f1647b630887f8">More...</a><br /></td></tr>
<tr class="separator:a7b978b86d8c8a47f68f1647b630887f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad835ddf125627fcedce3a3172428ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef">gather</a> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;<a class="el" href="classgraphlab_1_1context.html">context</a>, const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;vertex, <a class="el" href="classgraphlab_1_1ivertex__program.html#a84bc6ae6da912edc52420c0da1e4749d">edge_type</a> &amp;edge) const </td></tr>
<tr class="memdesc:a7ad835ddf125627fcedce3a3172428ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gather function is called on all the <a class="el" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">ivertex_program::gather_edges</a> in parallel and returns the <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a> which are added to compute the final output of the gather phase.  <a href="#a7ad835ddf125627fcedce3a3172428ef">More...</a><br /></td></tr>
<tr class="separator:a7ad835ddf125627fcedce3a3172428ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f9db9ebc638f6a9aa22014e8db1854"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#ad1f9db9ebc638f6a9aa22014e8db1854">apply</a> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;<a class="el" href="classgraphlab_1_1context.html">context</a>, <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;vertex, const <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a> &amp;total)=0</td></tr>
<tr class="memdesc:ad1f9db9ebc638f6a9aa22014e8db1854"><td class="mdescLeft">&#160;</td><td class="mdescRight">The apply function is called once the gather phase has completed and must be implemented by all vertex programs.  <a href="#ad1f9db9ebc638f6a9aa22014e8db1854">More...</a><br /></td></tr>
<tr class="separator:ad1f9db9ebc638f6a9aa22014e8db1854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa296513f9727bb48b372a0386c7e0c05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#aa296513f9727bb48b372a0386c7e0c05">scatter_edges</a> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;<a class="el" href="classgraphlab_1_1context.html">context</a>, const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;vertex) const </td></tr>
<tr class="memdesc:aa296513f9727bb48b372a0386c7e0c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of edges on which to run the scatter function. The default edge direction is out edges.  <a href="#aa296513f9727bb48b372a0386c7e0c05">More...</a><br /></td></tr>
<tr class="separator:aa296513f9727bb48b372a0386c7e0c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e93eefb25b31b0df72b4c454a89105"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1ivertex__program.html#a68e93eefb25b31b0df72b4c454a89105">scatter</a> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;<a class="el" href="classgraphlab_1_1context.html">context</a>, const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;vertex, <a class="el" href="classgraphlab_1_1ivertex__program.html#a84bc6ae6da912edc52420c0da1e4749d">edge_type</a> &amp;edge) const </td></tr>
<tr class="memdesc:a68e93eefb25b31b0df72b4c454a89105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter is called on all <a class="el" href="classgraphlab_1_1ivertex__program.html#aa296513f9727bb48b372a0386c7e0c05" title="Returns the set of edges on which to run the scatter function. The default edge direction is out edge...">scatter_edges()</a> in parallel after the apply function has completed and is typically responsible for updating edge data, signaling (messaging) adjacent vertices, and updating the gather cache state when caching is enabled.  <a href="#a68e93eefb25b31b0df72b4c454a89105">More...</a><br /></td></tr>
<tr class="separator:a68e93eefb25b31b0df72b4c454a89105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970350dc6b0941b42cd16564bcbde8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9970350dc6b0941b42cd16564bcbde8a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>pre_local_gather</b> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a> &amp;) const </td></tr>
<tr class="separator:a9970350dc6b0941b42cd16564bcbde8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad90fdfd19bfb8d54cf0c822dceb8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43ad90fdfd19bfb8d54cf0c822dceb8a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>post_local_gather</b> (<a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a> &amp;) const </td></tr>
<tr class="separator:a43ad90fdfd19bfb8d54cf0c822dceb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt;<br />
class graphlab::ivertex_program&lt; Graph, GatherType, MessageType &gt;</h3>

<p>The <a class="el" href="classgraphlab_1_1ivertex__program.html" title="The ivertex_program class defines the vertex program interface that all vertex programs should extend...">ivertex_program</a> class defines the vertex program interface that all vertex programs should extend and implement. The vertex-program is used to encode the user-define computation in a GraphLab program. </p>
<h1>Overview </h1>
<p>A vertex program represents the primary user defined computation in GraphLab. A unique instance of the vertex program is run on each vertex in the graph and can interact with neighboring vertex programs through the gather and scatter functions as well as by signaling neighboring vertex-programs. Conceptually the vertex-program is a class which represents the parts of an update-function in the original formulation of the GraphLab abstraction. Moreover many graph-structured programs can be written in the following pattern:</p>
<div class="fragment"><div class="line">graphlab::update_function(Vertex center, Neighborhood nbrs) {</div>
<div class="line">  <span class="comment">// nbrs represents the state of neighboring vertices and edges</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Gather Phase: </span></div>
<div class="line">  sum = EMPTY;</div>
<div class="line">  <span class="keywordflow">for</span>(edge in nbrs.in_edges()) {</div>
<div class="line">     <span class="comment">// The sum is a general commutative associative operation</span></div>
<div class="line">     <span class="keywordflow">if</span>(sum == EMPTY) sum = gather_function(center, edge, edge.neighbor());</div>
<div class="line">     <span class="keywordflow">else</span> sum += gather_function(center, edge, edge.neighbor());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Apply Phase:</span></div>
<div class="line">  center = apply_function(center, sum);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Scatter Phase:</span></div>
<div class="line">  <span class="keywordflow">for</span>(edge in nbrs.out_edges()) {</div>
<div class="line">    edge = scatter_function(center, edge, edge.neighbor());</div>
<div class="line">    <span class="keywordflow">if</span>(condition is met) trigger_neighbor();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>Vertex programs express computation by implementing what we call the <em>Gather-Apply-Scatter (GAS)</em> model which decomposes the vertex program into a parallel gather phase, followed by an atomic apply phase, and finally a parallel scatter phase. This decomposition allows us to execute a single vertex program on several machines simultaneously and move computation to the data.</p>
<p>We therefore decompose the update function logic into member functions of the vertex-program class that are invoked in the following manner:</p>
<div class="fragment"><div class="line">For the center vertex vtx:</div>
<div class="line">  vprog.init(ctx, vtx, msg);</div>
<div class="line">  <span class="comment">// Gather Phase: </span></div>
<div class="line">  vprog::gather_type sum = EMPTY;</div>
<div class="line">  ParallelFor(adjacent edges in direction vprog.gather_edges(ctx, vtx) )</div>
<div class="line">    <span class="keywordflow">if</span>(sum == EMPTY) sum = vprog.<a class="code" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef">gather</a>(ctx, vtx, edge);</div>
<div class="line">    else sum += vprog.<a class="code" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef">gather</a>(ctx, vtx, edge);</div>
<div class="line">  <span class="comment">// Apply Phase</span></div>
<div class="line">  vprog.<a class="code" href="classgraphlab_1_1ivertex__program.html#ad1f9db9ebc638f6a9aa22014e8db1854">apply</a>(ctx, vtx, sum);</div>
<div class="line">  <span class="comment">// Scatter Phase</span></div>
<div class="line">  ParallelFor(adjacent edges in direction vprog.<a class="code" href="classgraphlab_1_1ivertex__program.html#aa296513f9727bb48b372a0386c7e0c05">scatter_edges</a>(ctx, vtx) )</div>
<div class="line">    vprog.<a class="code" href="classgraphlab_1_1ivertex__program.html#a68e93eefb25b31b0df72b4c454a89105">scatter</a>(ctx, vtx, edge);</div>
<div class="line">  <span class="comment">// Vertex program is destroyed</span></div>
<div class="line">  vprog = vertex_program();</div>
</div><!-- fragment --><p>All user define vertex programs must extend the <a class="el" href="classgraphlab_1_1ivertex__program.html" title="The ivertex_program class defines the vertex program interface that all vertex programs should extend...">ivertex_program</a> interface and implement the <a class="el" href="classgraphlab_1_1ivertex__program.html#ad1f9db9ebc638f6a9aa22014e8db1854" title="The apply function is called once the gather phase has completed and must be implemented by all verte...">ivertex_program::apply</a> function. Most vertex programs will also implement the <a class="el" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef" title="The gather function is called on all the ivertex_program::gather_edges in parallel and returns the ga...">ivertex_program::gather</a> and <a class="el" href="classgraphlab_1_1ivertex__program.html#a68e93eefb25b31b0df72b4c454a89105" title="Scatter is called on all scatter_edges() in parallel after the apply function has completed and is ty...">ivertex_program::scatter</a> functions.</p>
<p>The state of a vertex program <em>does not</em> persist between invocations of <a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">ivertex_program::init</a>. Moreover prior to each call to init the vertex program's previous state is cleared. Therefore any persistent state must be saved into the vertex data.</p>
<p>The vertex program depends on several key types which are template arguments to <a class="el" href="classgraphlab_1_1ivertex__program.html" title="The ivertex_program class defines the vertex program interface that all vertex programs should extend...">ivertex_program</a> interface.</p>
<ul>
<li>graph_type: the type of graph used to store the data for this vertex program. This currently always the <a class="el" href="classgraphlab_1_1distributed__graph.html" title="A directed graph datastructure which is distributed across multiple machines. ">distributed_graph</a>.</li>
</ul>
<ul>
<li>gather_type: the type used in the gather phase and must implement the operator+= function.</li>
</ul>
<ul>
<li>message_type: The type used for signaling and is typically empty. However if a message type is desired it must implement the operator+= to allow message merging across the network. In addition the message type may also implement the priority() function which returns a double assigning a priority to the reception of the message (used by the asynchronous engines). We provide a basic set of simple prioritized messages in graphlab::signals.</li>
</ul>
<p>All user-defined types including the vertex data, edge data, vertex-program, gather type, and message type must be serializable (see <a class="el" href="serialization.html#sec_serializable">Serializable</a>) and default constructible to enable movement between machines.</p>
<h1>Advanced Features </h1>
<p>While the basic Gather-Apply-Scatter approach to graph structure computation can express a wide range of algorithms there are some situation where additional features could either simplify the design or provide additional efficiency.</p>
<h2>Messaging </h2>
<p>Vertex-programs can trigger adjacent vertex programs by sending a signal which can contain a message to neighbor vertices. By default the message type is empty however it is possible for the user to define a message type. For example the following message_type could be used to implement pagerank:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>pagerank_message : <span class="keyword">public</span> <a class="code" href="structgraphlab_1_1IS__POD__TYPE.html">graphlab::IS_POD_TYPE</a> {</div>
<div class="line">  <span class="keywordtype">double</span> value;</div>
<div class="line">  <span class="keywordtype">double</span> priority()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::fabs(value); }</div>
<div class="line">  <a class="code" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a>&amp; operator+=(<span class="keyword">const</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a>&amp; other) {</div>
<div class="line">    value += other.value; </div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --><p>Unlike other messaging abstractions, GraphLab always <em>merges</em> messages destined to the same vertex. This allows the GraphLab engines to minimize network communication and more evenly balance computation. Messages are combined using the operator+= function.</p>
<p>As mentioned earlier some engines may prioritize the <em>reception</em> of messages. Messages can optionally (it is not required) provide a priority function which is used to prioritize message reception. The engine then attempts to prioritize the reception of higher priority messages first.</p>
<p>The message is received in the <a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">ivertex_program::init</a> function. The single message passed into <a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">ivertex_program::init</a> represents the sum of all messages destined to that vertex since the vertex-program was last invoked.</p>
<p>The GraphLab messaging framework allows us to write Pregel-like vertex-programs of the form:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> graphlab::empty <a class="code" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a>;</div>
<div class="line"><span class="keyword">class </span>pregel_pagerank : </div>
<div class="line">  <span class="keyword">public</span> ivertex_program&lt;graph_type, gather_type, pagerank_message&gt;,</div>
<div class="line">  <span class="keyword">public</span> <a class="code" href="structgraphlab_1_1IS__POD__TYPE.html">graphlab::IS_POD_TYPE</a> {</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Store a local copy of the message data</span></div>
<div class="line">  <span class="keywordtype">double</span> message_value;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Receive the inbound message (sum of messages)</span></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">init</a>(<a class="code" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a>&amp; context, <span class="keyword">const</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a>&amp; vertex, </div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a>&amp; msg) { </div>
<div class="line">    message_value = message.value;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Skip the gather phase</span></div>
<div class="line">  <a class="code" href="classgraphlab_1_1ivertex__program.html#a88f02e25c4899bd3d3d3edc9037eeb6b">edge_dir_type</a> <a class="code" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">gather_edges</a>(<a class="code" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a>&amp; context,</div>
<div class="line">                             <span class="keyword">const</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a>&amp; vertex)<span class="keyword"> const </span>{ </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34">graphlab::NO_EDGES</a>; </div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Update the pagerank using the message</span></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#ad1f9db9ebc638f6a9aa22014e8db1854">apply</a>(<a class="code" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a>&amp; context, <a class="code" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a>&amp; vertex, </div>
<div class="line">             <span class="keyword">const</span> gather_type&amp; total) {</div>
<div class="line">    vertex.data() += message_value;      </div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Scatter along out edges</span></div>
<div class="line">  <a class="code" href="classgraphlab_1_1ivertex__program.html#a88f02e25c4899bd3d3d3edc9037eeb6b">edge_dir_type</a> <a class="code" href="classgraphlab_1_1ivertex__program.html#aa296513f9727bb48b372a0386c7e0c05">scatter_edges</a>(<a class="code" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a>&amp; context,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a>&amp; vertex)<span class="keyword"> const </span>{ </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00">OUT_EDGES</a>; </div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Compute new messages encoding the change in the pagerank of</span></div>
<div class="line">  <span class="comment">// adjacent vertices.</span></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#a68e93eefb25b31b0df72b4c454a89105">scatter</a>(<a class="code" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a>&amp; context, <span class="keyword">const</span> <a class="code" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a>&amp; vertex, </div>
<div class="line">               <a class="code" href="classgraphlab_1_1ivertex__program.html#a84bc6ae6da912edc52420c0da1e4749d">edge_type</a>&amp; edge)<span class="keyword"> const </span>{ </div>
<div class="line">    pagerank_message msg;</div>
<div class="line">    msg.value = message_value * (1 - RESET_PROBABILITY);</div>
<div class="line">    context.signal(edge.target(), msg);</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --><p>Notice that the gather phase is skipped and instead the gather computation is accomplished using the messages. However unlike Pregel the scatter function which computs and sends the new message is actually run on the machine that is receiving the message.</p>
<p>The message abstraction is surprisingly powerful and can often often express computation that can be written using the Gather operation. However, the message combination is done outside of the consistency model and so can lead to more confusing code.</p>
<h2>Gather Caching </h2>
<p>In many applications the gather computation can be costly and high-degree vertices will be signaled often even only a small fraction of its neighbors values have changed. In this case running the gather function on all neighbors can be wasteful. To address this important issue the GraphLab engines expose a gather caching mechanism. However to take advantage of the gather caching the vertex-program must notify the engine when a cache is no longer valid and can even correct the cache to ensure that it remains valid.</p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00279">279</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a4a053f524199859ce209eef4d6cac486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Graph::edge_data_type <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#a4a053f524199859ce209eef4d6cac486">edge_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined edge data associated with each edge in the graph. </p>
<p>The edge data type must be serializable (see <a class="el" href="serialization.html#sec_serializable">Serializable</a>) </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00317">317</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88f02e25c4899bd3d3d3edc9037eeb6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">graphlab::edge_dir_type</a> <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to define the direction of edges used in gather and scatter. </p>
<p>Possible values include:</p>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34" title="No edges implies that no edges are processed during the corresponding gather or scatter phase...">graphlab::NO_EDGES</a> : Do not process any edges</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6" title="In edges implies that only whose target is the center vertex are processed during gather or scatter...">graphlab::IN_EDGES</a> : Process only inbound edges to this vertex</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00" title="Out edges implies that only whose source is the center vertex are processed during gather or scatter...">graphlab::OUT_EDGES</a> : Process only outbound edges to this vertex</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a968946455ba5885329abe6606b70c365" title="All edges implies that all adges adjacent to a the center vertex are processed on gather or scatter...">graphlab::ALL_EDGES</a> : Process both inbound and outbound edges on this vertes.</li>
</ul>
<p>See <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">graphlab::edge_dir_type</a> for details. </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00495">495</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84bc6ae6da912edc52420c0da1e4749d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#a84bc6ae6da912edc52420c0da1e4749d">edge_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The opaque edge_object type used to access edge information. </p>
<p>The edge type is defined by the graph. See <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">distributed_graph::edge_type</a> for details. </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00474">474</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80a026fca976fd6b0f0c00bab2df076f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef GatherType <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined gather type is used to accumulate the results of the gather function during the gather phase and must implement the operator += operation. </p>
<p>The gather type plays the following role in the vertex program:</p>
<div class="fragment"><div class="line">gather_type sum = EMPTY;</div>
<div class="line"><span class="keywordflow">for</span>(edges in vprog.gather_edges()) {</div>
<div class="line">  <span class="keywordflow">if</span>(sum == EMPTY) sum = vprog.gather(...);</div>
<div class="line">  <span class="keywordflow">else</span> sum += vprog.gather( ... );</div>
<div class="line">}</div>
<div class="line">vprog.apply(..., sum);</div>
</div><!-- fragment --><p>In addition to implementing the operator+= operation the gather type must also be serializable (see <a class="el" href="serialization.html#sec_serializable">Serializable</a>). </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00348">348</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbde69d82102416f106230ec726e5d55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Graph <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#acbde69d82102416f106230ec726e5d55">graph_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The graph type associative with this vertex program. </p>
<p>The graph type is specified as a template argument and will usually be <a class="el" href="classgraphlab_1_1distributed__graph.html">distributed_graph</a>. </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00449">449</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47bff8bb9a8ce3ba0bdbd34102a7be3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1icontext.html">icontext</a>&lt;<a class="el" href="classgraphlab_1_1ivertex__program.html#acbde69d82102416f106230ec726e5d55">graph_type</a>, <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a>, <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a>&gt; <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The context type is used by the vertex program to communicate with the engine. </p>
<p>The context and provides facilities for signaling adjacent vertices (sending messages), interacting with the GraphLab gather cache (posting deltas), and accessing engine state. </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00508">508</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ca29f15f893bf77e89e5ffd6f572e48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef MessageType <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The message type which must be provided by the vertex_program </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00404">404</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab20a4608d1c3109031f5fd5a3da35b36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Graph::vertex_data_type <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#ab20a4608d1c3109031f5fd5a3da35b36">vertex_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined vertex data associated with each vertex in the graph (see <a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">distributed_graph::vertex_data_type</a>). </p>
<p>The vertex data is the data associated with each vertex in the graph. Unlike the vertex-program the vertex data of adjacent vertices is visible to other vertex programs during the gather and scatter phases and persists between executions of the vertex-program.</p>
<p>The vertex data type must be serializable (see <a class="el" href="serialization.html#sec_serializable">Serializable</a>) </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00296">296</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73c67ea0ab5120901645c011194af583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef graph_type::vertex_id_type <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#a73c67ea0ab5120901645c011194af583">vertex_id_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unique integer id used to reference vertices in the graph. </p>
<p>See graphlab::vertex_id_type for details. </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00456">456</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adccdf8e6d9dc71934b0349b3305363ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::<a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The opaque vertex object type used to get vertex information. </p>
<p>The vertex type is defined by the graph. See <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">distributed_graph::vertex_type</a> for details. </p>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00465">465</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad1f9db9ebc638f6a9aa22014e8db1854"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a> &amp;&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The apply function is called once the gather phase has completed and must be implemented by all vertex programs. </p>
<p>The apply function is responsible for modifying the vertex data and is run only once per vertex per execution of a vertex program. In addition the apply function can modify the state of the vertex program.</p>
<p>If a vertex has no neighbors than the apply function is called passing the default value for the gather_type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The context is used to interact with the engine</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vertex</td><td>The vertex on which this vertex-program is running.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">total</td><td>The result of the gather phase. If a vertex has no neighbors then the total is the default value (i.e., <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f" title="The user defined gather type is used to accumulate the results of the gather function during the gath...">gather_type()</a>) of the gather type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ad835ddf125627fcedce3a3172428ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a> <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a84bc6ae6da912edc52420c0da1e4749d">edge_type</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The gather function is called on all the <a class="el" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">ivertex_program::gather_edges</a> in parallel and returns the <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a> which are added to compute the final output of the gather phase. </p>
<p>The gather function is the core computational element of the Gather phase and is responsible for collecting the information about the state of adjacent vertices and edges.</p>
<dl class="section warning"><dt>Warning</dt><dd>The gather function is executed in parallel on multiple machines and therefore cannot modify the vertex-program's state or the vertex data.</dd></dl>
<p>A default implementation of the gather function is provided which will fail if invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The context is used to interact with the engine</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The vertex on which this vertex-program is running. Note that the vertex is constant and its value should not be modified.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">edge</td><td>The adjacent edge to be processed. The edge is not constant and therefore the edge data can be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the gather computation which will be "summed" to produce the input to the apply operation. The behavior of the "sum" is defined by the <a class="el" href="classgraphlab_1_1ivertex__program.html#a80a026fca976fd6b0f0c00bab2df076f">gather_type</a>. </dd></dl>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00617">617</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b978b86d8c8a47f68f1647b630887f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a> <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::gather_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of edges on which to run the gather function. The default edge direction is in edges. </p>
<p>The gather_edges function is invoked after the init function has completed.</p>
<dl class="section warning"><dt>Warning</dt><dd>The gather_edges function may be invoked multiple times for the same execution of the vertex-program and should return the same value. In addition it cannot modify the vertex-programs state or the vertex data.</dd></dl>
<p>Possible return values include:</p>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34" title="No edges implies that no edges are processed during the corresponding gather or scatter phase...">graphlab::NO_EDGES</a> : The gather phase is completely skipped potentially reducing network communication.</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6" title="In edges implies that only whose target is the center vertex are processed during gather or scatter...">graphlab::IN_EDGES</a> : The gather function is only run on inbound edges to this vertex.</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00" title="Out edges implies that only whose source is the center vertex are processed during gather or scatter...">graphlab::OUT_EDGES</a> : The gather function is only run on outbound edges to this vertex.</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a968946455ba5885329abe6606b70c365" title="All edges implies that all adges adjacent to a the center vertex are processed on gather or scatter...">graphlab::ALL_EDGES</a> : The gather function is run on both inbound and outbound edges to this vertes.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The context is used to interact with the engine</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The vertex on which this vertex-program is running. Note that the vertex is constant and its value should not be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34" title="No edges implies that no edges are processed during the corresponding gather or scatter phase...">graphlab::NO_EDGES</a>, <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6" title="In edges implies that only whose target is the center vertex are processed during gather or scatter...">graphlab::IN_EDGES</a>, <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00" title="Out edges implies that only whose source is the center vertex are processed during gather or scatter...">graphlab::OUT_EDGES</a>, or <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a968946455ba5885329abe6606b70c365" title="All edges implies that all adges adjacent to a the center vertex are processed on gather or scatter...">graphlab::ALL_EDGES</a>. </dd></dl>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00578">578</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad371b64021ac80eaae332319dec41723"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This called by the engine to receive a message to this vertex program. The vertex program can use this to initialize any state before entering the gather phase. The init function is invoked <em>once</em> per execution of the vertex program. </p>
<p>If the vertex program does not implement this function then the default implementation (NOP) is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The context is used to interact with the engine</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The vertex on which this vertex-program is running. Note that the vertex is constant and its value should not be modified within the init function. If there is some message state that is needed then it must be saved to the vertex-program and not the vertex data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The sum of all the signal calls to this vertex since it was last run. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00536">536</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68e93eefb25b31b0df72b4c454a89105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a84bc6ae6da912edc52420c0da1e4749d">edge_type</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter is called on all <a class="el" href="classgraphlab_1_1ivertex__program.html#aa296513f9727bb48b372a0386c7e0c05" title="Returns the set of edges on which to run the scatter function. The default edge direction is out edge...">scatter_edges()</a> in parallel after the apply function has completed and is typically responsible for updating edge data, signaling (messaging) adjacent vertices, and updating the gather cache state when caching is enabled. </p>
<p>The scatter function is almost identical to the gather function except that nothing is returned.</p>
<dl class="section warning"><dt>Warning</dt><dd>The scatter function is executed in parallel on multiple machines and therefore cannot modify the vertex-program's state or the vertex data.</dd></dl>
<p>A default implementation of the gather function is provided which will fail if invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The context is used to interact with the engine</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The vertex on which this vertex-program is running. Note that the vertex is constant and its value should not be modified.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">edge</td><td>The adjacent edge to be processed. The edge is not constant and therefore the edge data can be modified. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00723">723</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa296513f9727bb48b372a0386c7e0c05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph, typename GatherType, typename MessageType = graphlab::empty&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a> <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt; Graph, GatherType, MessageType &gt;::scatter_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1ivertex__program.html#a47bff8bb9a8ce3ba0bdbd34102a7be3b">icontext_type</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1ivertex__program.html#adccdf8e6d9dc71934b0349b3305363ed">vertex_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of edges on which to run the scatter function. The default edge direction is out edges. </p>
<p>The scatter_edges function is invoked after the apply function has completed.</p>
<dl class="section warning"><dt>Warning</dt><dd>The scatter_edges function may be invoked multiple times for the same execution of the vertex-program and should return the same value. In addition it cannot modify the vertex-programs state or the vertex data.</dd></dl>
<p>Possible return values include:</p>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34" title="No edges implies that no edges are processed during the corresponding gather or scatter phase...">graphlab::NO_EDGES</a> : The scatter phase is completely skipped potentially reducing network communication.</li>
</ul>
<ul>
<li>graphlab::IN_EDGE : The scatter function is only run on inbound edges to this vertex.</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00" title="Out edges implies that only whose source is the center vertex are processed during gather or scatter...">graphlab::OUT_EDGES</a> : The scatter function is only run on outbound edges to this vertex.</li>
</ul>
<ul>
<li><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a968946455ba5885329abe6606b70c365" title="All edges implies that all adges adjacent to a the center vertex are processed on gather or scatter...">graphlab::ALL_EDGES</a> : The scatter function is run on both inbound and outbound edges to this vertes.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The context is used to interact with the engine</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The vertex on which this vertex-program is running. Note that the vertex is constant and its value should not be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89aebe40f1ac82207ff11bc70fb14954e34" title="No edges implies that no edges are processed during the corresponding gather or scatter phase...">graphlab::NO_EDGES</a>, <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6" title="In edges implies that only whose target is the center vertex are processed during gather or scatter...">graphlab::IN_EDGES</a>, <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89ad00c78683bc4a0495b12a3b1ba99dd00" title="Out edges implies that only whose source is the center vertex are processed during gather or scatter...">graphlab::OUT_EDGES</a>, or <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a968946455ba5885329abe6606b70c365" title="All edges implies that all adges adjacent to a the center vertex are processed on gather or scatter...">graphlab::ALL_EDGES</a>. </dd></dl>

<p>Definition at line <a class="el" href="ivertex__program_8hpp_source.html#l00689">689</a> of file <a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/vertex_program/<a class="el" href="ivertex__program_8hpp_source.html">ivertex_program.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1ivertex__program.html">ivertex_program</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:28 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
