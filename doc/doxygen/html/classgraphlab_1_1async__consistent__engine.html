<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::async_consistent_engine&lt; VertexProgram &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1async__consistent__engine.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgraphlab_1_1async__consistent__engine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::async_consistent_engine&lt; VertexProgram &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__engines.html">GraphLab Engines</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The asynchronous consistent engine executed vertex programs asynchronously and can ensure mutual exclusion such that adjacent vertices are never executed simultaneously. The default mode is "factorized" consistency in which only individual gathers/applys/ scatters are guaranteed to be consistent, but this can be strengthened to provide full mutual exclusion.  
 <a href="classgraphlab_1_1async__consistent__engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="async__consistent__engine_8hpp_source.html">graphlab/engine/async_consistent_engine.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2891dfe4f06647e4574d5e06f83b27e0"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a2891dfe4f06647e4574d5e06f83b27e0">vertex_program_type</a></td></tr>
<tr class="memdesc:a2891dfe4f06647e4574d5e06f83b27e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined vertex program type. Equivalent to the VertexProgram template argument.  <a href="#a2891dfe4f06647e4574d5e06f83b27e0">More...</a><br /></td></tr>
<tr class="separator:a2891dfe4f06647e4574d5e06f83b27e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3274ece76793cb995c7472d5927f6659"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::gather_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a3274ece76793cb995c7472d5927f6659">gather_type</a></td></tr>
<tr class="memdesc:a3274ece76793cb995c7472d5927f6659"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined type returned by the gather function.  <a href="#a3274ece76793cb995c7472d5927f6659">More...</a><br /></td></tr>
<tr class="separator:a3274ece76793cb995c7472d5927f6659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6de61894637a15a7ddc2c02591791ef"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::message_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a></td></tr>
<tr class="memdesc:ab6de61894637a15a7ddc2c02591791ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined message type used to signal neighboring vertex programs.  <a href="#ab6de61894637a15a7ddc2c02591791ef">More...</a><br /></td></tr>
<tr class="separator:ab6de61894637a15a7ddc2c02591791ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab7c1d1fab2c3d7255e933b6ea481d4"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::vertex_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#afab7c1d1fab2c3d7255e933b6ea481d4">vertex_data_type</a></td></tr>
<tr class="memdesc:afab7c1d1fab2c3d7255e933b6ea481d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data associated with each vertex in the graph.  <a href="#afab7c1d1fab2c3d7255e933b6ea481d4">More...</a><br /></td></tr>
<tr class="separator:afab7c1d1fab2c3d7255e933b6ea481d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb58058f6696de8487d69874fe440a1"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::edge_data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a2fb58058f6696de8487d69874fe440a1">edge_data_type</a></td></tr>
<tr class="memdesc:a2fb58058f6696de8487d69874fe440a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data associated with each edge in the graph.  <a href="#a2fb58058f6696de8487d69874fe440a1">More...</a><br /></td></tr>
<tr class="separator:a2fb58058f6696de8487d69874fe440a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7ffa03bdea6d0bb29cf1f3a958969f"><td class="memItemLeft" align="right" valign="top">typedef VertexProgram::graph_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a6d7ffa03bdea6d0bb29cf1f3a958969f">graph_type</a></td></tr>
<tr class="memdesc:a6d7ffa03bdea6d0bb29cf1f3a958969f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of graph supported by this vertex program.  <a href="#a6d7ffa03bdea6d0bb29cf1f3a958969f">More...</a><br /></td></tr>
<tr class="separator:a6d7ffa03bdea6d0bb29cf1f3a958969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7c391670c7f5f9d34b1b528bc7275"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#ad4d7c391670c7f5f9d34b1b528bc7275">vertex_type</a></td></tr>
<tr class="memdesc:ad4d7c391670c7f5f9d34b1b528bc7275"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent a vertex in the graph. See <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graphlab::distributed_graph::vertex_type</a> for details.  <a href="#ad4d7c391670c7f5f9d34b1b528bc7275">More...</a><br /></td></tr>
<tr class="separator:ad4d7c391670c7f5f9d34b1b528bc7275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c69960be1acdd5dce2dcad947298da"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a78c69960be1acdd5dce2dcad947298da">edge_type</a></td></tr>
<tr class="memdesc:a78c69960be1acdd5dce2dcad947298da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent an edge in the graph. See <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graphlab::distributed_graph::edge_type</a> for details.  <a href="#a78c69960be1acdd5dce2dcad947298da">More...</a><br /></td></tr>
<tr class="separator:a78c69960be1acdd5dce2dcad947298da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdf2e92167ac1765c3aa9adf4fba436"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgraphlab_1_1icontext.html">icontext</a>&lt; <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a6d7ffa03bdea6d0bb29cf1f3a958969f">graph_type</a>, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a3274ece76793cb995c7472d5927f6659">gather_type</a>, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#acbdf2e92167ac1765c3aa9adf4fba436">icontext_type</a></td></tr>
<tr class="memdesc:acbdf2e92167ac1765c3aa9adf4fba436"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the callback interface passed by the engine to vertex programs. See <a class="el" href="classgraphlab_1_1icontext.html">graphlab::icontext</a> for details.  <a href="#acbdf2e92167ac1765c3aa9adf4fba436">More...</a><br /></td></tr>
<tr class="separator:acbdf2e92167ac1765c3aa9adf4fba436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01472800a89cef585293b074e4aa9925"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01472800a89cef585293b074e4aa9925"></a>
typedef graph_type::vertex_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a></td></tr>
<tr class="memdesc:a01472800a89cef585293b074e4aa9925"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex identifier type defined in graphlab::vertex_id_type. <br /></td></tr>
<tr class="separator:a01472800a89cef585293b074e4aa9925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7eacc7f1ecff97059519f609686c9b5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a7eacc7f1ecff97059519f609686c9b5f">async_consistent_engine</a> (<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;dc, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a6d7ffa03bdea6d0bb29cf1f3a958969f">graph_type</a> &amp;graph, const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;opts=<a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>())</td></tr>
<tr class="separator:a7eacc7f1ecff97059519f609686c9b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6664119b88c6e6f71c37312c511b6f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a4e6664119b88c6e6f71c37312c511b6f">num_updates</a> () const </td></tr>
<tr class="memdesc:a4e6664119b88c6e6f71c37312c511b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the total number of updates (calls to apply) executed since start was last invoked.  <a href="#a4e6664119b88c6e6f71c37312c511b6f">More...</a><br /></td></tr>
<tr class="separator:a4e6664119b88c6e6f71c37312c511b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bb090bb0404f9de780130411724fdc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#aa8bb090bb0404f9de780130411724fdc">elapsed_seconds</a> () const </td></tr>
<tr class="memdesc:aa8bb090bb0404f9de780130411724fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the elapsed time in seconds since start was last called.  <a href="#aa8bb090bb0404f9de780130411724fdc">More...</a><br /></td></tr>
<tr class="separator:aa8bb090bb0404f9de780130411724fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b31760f49c29c0e0fff0c043e8a5028"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b31760f49c29c0e0fff0c043e8a5028"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a0b31760f49c29c0e0fff0c043e8a5028">iteration</a> () const </td></tr>
<tr class="memdesc:a0b31760f49c29c0e0fff0c043e8a5028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not meaningful for the asynchronous engine. Returns -1. <br /></td></tr>
<tr class="separator:a0b31760f49c29c0e0fff0c043e8a5028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f32124209d4151de74cb4035c03ce83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f32124209d4151de74cb4035c03ce83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signal</b> (<a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a> gvid, const <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a>())</td></tr>
<tr class="separator:a2f32124209d4151de74cb4035c03ce83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77492a69e7785a8cbe5c5b9fbcdd0c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77492a69e7785a8cbe5c5b9fbcdd0c6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signal_all</b> (const <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)</td></tr>
<tr class="separator:a77492a69e7785a8cbe5c5b9fbcdd0c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8927552dfb59a91eec54fc5701f6afd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8927552dfb59a91eec54fc5701f6afd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signal_vset</b> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset, const <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)</td></tr>
<tr class="separator:a8927552dfb59a91eec54fc5701f6afd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d23f6137fa3816023fc501060fc816d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a8d23f6137fa3816023fc501060fc816d">start</a> ()</td></tr>
<tr class="memdesc:a8d23f6137fa3816023fc501060fc816d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the engine execution.  <a href="#a8d23f6137fa3816023fc501060fc816d">More...</a><br /></td></tr>
<tr class="separator:a8d23f6137fa3816023fc501060fc816d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38068c8c9b361a30e2f736568858a99c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38068c8c9b361a30e2f736568858a99c"></a>
aggregator_type *&#160;</td><td class="memItemRight" valign="bottom"><b>get_aggregator</b> ()</td></tr>
<tr class="separator:a38068c8c9b361a30e2f736568858a99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab945aad4bc982b507efc1ba55dba30d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#ab945aad4bc982b507efc1ba55dba30d8">signal</a> (<a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a> vertex, const <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a>())=0</td></tr>
<tr class="memdesc:ab945aad4bc982b507efc1ba55dba30d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals single a vertex with an optional message.  <a href="#ab945aad4bc982b507efc1ba55dba30d8">More...</a><br /></td></tr>
<tr class="separator:ab945aad4bc982b507efc1ba55dba30d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0afe236029be943f870a77bd2a6b3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a9c0afe236029be943f870a77bd2a6b3f">signal_all</a> (const <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)=0</td></tr>
<tr class="memdesc:a9c0afe236029be943f870a77bd2a6b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all vertices with a particular message.  <a href="#a9c0afe236029be943f870a77bd2a6b3f">More...</a><br /></td></tr>
<tr class="separator:a9c0afe236029be943f870a77bd2a6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a7a9e2b10c0934d4c486c56c649c13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a86a7a9e2b10c0934d4c486c56c649c13">signal_vset</a> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset, const <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)=0</td></tr>
<tr class="memdesc:a86a7a9e2b10c0934d4c486c56c649c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a set of vertices with a particular message.  <a href="#a86a7a9e2b10c0934d4c486c56c649c13">More...</a><br /></td></tr>
<tr class="separator:a86a7a9e2b10c0934d4c486c56c649c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c802e7271358becf2cf2b2418b943a"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename VertexMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:a39c802e7271358becf2cf2b2418b943a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a">add_vertex_aggregator</a> (const std::string &amp;key, VertexMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:a39c802e7271358becf2cf2b2418b943a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name already exists.  <a href="#a39c802e7271358becf2cf2b2418b943a">More...</a><br /></td></tr>
<tr class="separator:a39c802e7271358becf2cf2b2418b943a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafefe848a350d243f62fefe173d3d287"><td class="memTemplParams" colspan="2">template&lt;typename VertexMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:aafefe848a350d243f62fefe173d3d287"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#aafefe848a350d243f62fefe173d3d287">add_vertex_aggregator</a> (const std::string &amp;key, VertexMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:aafefe848a350d243f62fefe173d3d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of add_vertex_aggregator for C++11 which does not require the user to provide the reduction type.  <a href="#aafefe848a350d243f62fefe173d3d287">More...</a><br /></td></tr>
<tr class="separator:aafefe848a350d243f62fefe173d3d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21f70c04f6e9954e5db488cad6bff0"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename EdgeMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:adf21f70c04f6e9954e5db488cad6bff0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0">add_edge_aggregator</a> (const std::string &amp;key, EdgeMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:adf21f70c04f6e9954e5db488cad6bff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name already exists.  <a href="#adf21f70c04f6e9954e5db488cad6bff0">More...</a><br /></td></tr>
<tr class="separator:adf21f70c04f6e9954e5db488cad6bff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1407b75158fdaef63eec9719da40da"><td class="memTemplParams" colspan="2">template&lt;typename EdgeMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:a6d1407b75158fdaef63eec9719da40da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a6d1407b75158fdaef63eec9719da40da">add_edge_aggregator</a> (const std::string &amp;key, EdgeMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:a6d1407b75158fdaef63eec9719da40da"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of add_edge_aggregator for C++11 which does not require the user to provide the reduction type.  <a href="#a6d1407b75158fdaef63eec9719da40da">More...</a><br /></td></tr>
<tr class="separator:a6d1407b75158fdaef63eec9719da40da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742">aggregate_now</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an immediate aggregation on a key.  <a href="#a5f0ebbe2a3dae9ed3e7cbe6538e37742">More...</a><br /></td></tr>
<tr class="separator:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3fde48e79d248db7b815a313cd92e2"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename VertexMapperType &gt; </td></tr>
<tr class="memitem:a1b3fde48e79d248db7b815a313cd92e2"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2">map_reduce_vertices</a> (VertexMapperType mapfunction)</td></tr>
<tr class="memdesc:a1b3fde48e79d248db7b815a313cd92e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each vertex in the graph returning the result.  <a href="#a1b3fde48e79d248db7b815a313cd92e2">More...</a><br /></td></tr>
<tr class="separator:a1b3fde48e79d248db7b815a313cd92e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename EdgeMapperType &gt; </td></tr>
<tr class="memitem:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb">map_reduce_edges</a> (EdgeMapperType mapfunction)</td></tr>
<tr class="memdesc:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each edge in the graph returning the result.  <a href="#a8da8e299fd9bfc87e308d5ad571f35eb">More...</a><br /></td></tr>
<tr class="separator:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e97843604c45c08f71502b3494a7a"><td class="memTemplParams" colspan="2">template&lt;typename VertexMapperType &gt; </td></tr>
<tr class="memitem:a4d9e97843604c45c08f71502b3494a7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a">transform_vertices</a> (VertexMapperType mapfunction)</td></tr>
<tr class="memdesc:a4d9e97843604c45c08f71502b3494a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each vertex in the graph.  <a href="#a4d9e97843604c45c08f71502b3494a7a">More...</a><br /></td></tr>
<tr class="separator:a4d9e97843604c45c08f71502b3494a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memTemplParams" colspan="2">template&lt;typename EdgeMapperType &gt; </td></tr>
<tr class="memitem:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23">transform_edges</a> (EdgeMapperType mapfunction)</td></tr>
<tr class="memdesc:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each edge in the graph.  <a href="#a4ab681ecccc66ad8696f5a4d0103fa23">More...</a><br /></td></tr>
<tr class="separator:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602b1e06b1b4db6537e6e48774499b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a6602b1e06b1b4db6537e6e48774499b9">aggregate_periodic</a> (const std::string &amp;key, float seconds)</td></tr>
<tr class="memdesc:a6602b1e06b1b4db6537e6e48774499b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that a particular aggregation key be recomputed periodically when the engine is running.  <a href="#a6602b1e06b1b4db6537e6e48774499b9">More...</a><br /></td></tr>
<tr class="separator:a6602b1e06b1b4db6537e6e48774499b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VertexProgram&gt;<br />
class graphlab::async_consistent_engine&lt; VertexProgram &gt;</h3>

<p>The asynchronous consistent engine executed vertex programs asynchronously and can ensure mutual exclusion such that adjacent vertices are never executed simultaneously. The default mode is "factorized" consistency in which only individual gathers/applys/ scatters are guaranteed to be consistent, but this can be strengthened to provide full mutual exclusion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexProgram</td><td>The user defined vertex program type which should implement the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<h3>Execution Semantics</h3>
<p>On <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a8d23f6137fa3816023fc501060fc816d" title="Start the engine execution. ">start()</a> the <a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">graphlab::ivertex_program::init</a> function is invoked on all vertex programs in parallel to initialize the vertex program, vertex data, and possibly signal vertices.</p>
<p>After which, the engine spawns a collection of threads where each thread individually performs the following tasks: </p><ul>
<li>Extract a message from the scheduler. </li>
<li>Perform distributed lock acquisition on the vertex which is supposed to receive the message. The lock system enforces that no neighboring vertex is executing at the same time. The implementation is based on the Chandy-Misra solution to the dining philosophers problem. (Chandy, K.M.; Misra, J. (1984). The Drinking Philosophers Problem. ACM Trans. Program. Lang. Syst) </li>
<li>Once lock acquisition is complete, <a class="el" href="classgraphlab_1_1ivertex__program.html#ad371b64021ac80eaae332319dec41723">graphlab::ivertex_program::init</a> is called on the vertex program. As an optimization, any messages sent to this vertex before completion of lock acquisition is merged into original message extracted from the scheduler. </li>
<li>Execute the gather on the vertex program by invoking the user defined <a class="el" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef">graphlab::ivertex_program::gather</a> function on the edge direction returned by the <a class="el" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">graphlab::ivertex_program::gather_edges</a> function. The gather functions can modify edge data but cannot modify the vertex program or vertex data and can be executed on multiple edges in parallel.<ul>
<li></li>
</ul>
</li>
<li>Execute the apply function on the vertex-program by invoking the user defined <a class="el" href="classgraphlab_1_1ivertex__program.html#ad1f9db9ebc638f6a9aa22014e8db1854">graphlab::ivertex_program::apply</a> function passing the sum of the gather functions. If <a class="el" href="classgraphlab_1_1ivertex__program.html#a7b978b86d8c8a47f68f1647b630887f8">graphlab::ivertex_program::gather_edges</a> returns no edges then the default gather value is passed to apply. The apply function can modify the vertex program and vertex data. </li>
<li>Execute the scatter on the vertex program by invoking the user defined <a class="el" href="classgraphlab_1_1ivertex__program.html#a68e93eefb25b31b0df72b4c454a89105">graphlab::ivertex_program::scatter</a> function on the edge direction returned by the <a class="el" href="classgraphlab_1_1ivertex__program.html#aa296513f9727bb48b372a0386c7e0c05">graphlab::ivertex_program::scatter_edges</a> function. The scatter functions can modify edge data but cannot modify the vertex program or vertex data and can be executed on multiple edges in parallel. </li>
<li>Release all locks acquired in the lock acquisition stage, and repeat until the scheduler is empty.</li>
</ul>
<p>The engine threads multiplexes the above procedure through a secondary internal queue, allowing an arbitrary large number of vertices to begin processing at the same time.</p>
<h3>Construction</h3>
<p>The asynchronous consistent engine is constructed by passing in a <a class="el" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> object which manages coordination between engine threads and a <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a> object which is the graph on which the engine should be run. The graph should already be populated and cannot change after the engine is constructed. In the distributed setting all program instances (running on each machine) should construct an instance of the engine at the same time.</p>
<p>Computation is initiated by signaling vertices using either graphlab::async_consistent_engine::signal or graphlab::async_consistent_engine::signal_all. In either case all machines should invoke signal or signal all at the same time. Finally, computation is initiated by calling the <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a8d23f6137fa3816023fc501060fc816d">graphlab::async_consistent_engine::start</a> function.</p>
<h3>Example Usage</h3>
<p>The following is a simple example demonstrating how to use the engine: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graphlab.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>vertex_data {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>edge_data {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;vertex_data, edge_data&gt;</a> <a class="code" href="classgraphlab_1_1async__consistent__engine.html#a6d7ffa03bdea6d0bb29cf1f3a958969f">graph_type</a>;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="classgraphlab_1_1async__consistent__engine.html#a3274ece76793cb995c7472d5927f6659">gather_type</a>;</div>
<div class="line"><span class="keyword">struct </span>pagerank_vprog :</div>
<div class="line">  <span class="keyword">public</span> <a class="code" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt;graph_type, gather_type&gt; {</div>
<div class="line">  <span class="comment">// code</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Initialize control plain using mpi</span></div>
<div class="line">  graphlab::mpi_tools::init(argc, argv);</div>
<div class="line">  <a class="code" href="classgraphlab_1_1distributed__control.html">graphlab::distributed_control</a> dc;</div>
<div class="line">  <span class="comment">// Parse command line options</span></div>
<div class="line">  <a class="code" href="classgraphlab_1_1command__line__options.html">graphlab::command_line_options</a> clopts(<span class="stringliteral">&quot;PageRank algorithm.&quot;</span>);</div>
<div class="line">  std::string graph_dir;</div>
<div class="line">  clopts.attach_option(<span class="stringliteral">&quot;graph&quot;</span>, &amp;graph_dir, graph_dir,</div>
<div class="line">                       <span class="stringliteral">&quot;The graph file.&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span>(!clopts.parse(argc, argv)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Error in parsing arguments.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  graph_type graph(dc, clopts);</div>
<div class="line">  graph.load_structure(graph_dir, <span class="stringliteral">&quot;tsv&quot;</span>);</div>
<div class="line">  graph.finalize();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;#vertices: &quot;</span> &lt;&lt; graph.num_vertices()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #edges:&quot;</span> &lt;&lt; graph.num_edges() &lt;&lt; std::endl;</div>
<div class="line">  <a class="code" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine&lt;pagerank_vprog&gt;</a> engine(dc, graph, clopts);</div>
<div class="line">  engine.signal_all();</div>
<div class="line">  engine.start();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Runtime: &quot;</span> &lt;&lt; engine.elapsed_seconds();</div>
<div class="line">  graphlab::mpi_tools::finalize();</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classgraphlab_1_1omni__engine.html" title="The omni engine encapsulates all the GraphLab engines allowing the user to select which engine to use...">graphlab::omni_engine</a> </dd>
<dd>
<a class="el" href="classgraphlab_1_1synchronous__engine.html" title="The synchronous engine executes all active vertex program synchronously in a sequence of super-step (...">graphlab::synchronous_engine</a></dd></dl>
<h1><a class="anchor" id="engineopts"></a>Engine Options </h1>
<p>The asynchronous engine supports several engine options which can be set as command line arguments using <code>&ndash;engine_opts</code> :</p>
<ul>
<li><b>timeout</b> (default: infinity) Maximum time in seconds the engine will run for. The actual runtime may be marginally greater as the engine waits for all threads and processes to flush all active tasks before returning. </li>
<li><b>factorized</b> (default: true) Set to true to weaken the consistency model to factorized consistency where only individual gather/apply/scatter calls are guaranteed to be locally consistent. Can produce massive increases in throughput at a consistency penalty. </li>
<li><b>nfibers</b> (default: 10000) Number of fibers to use </li>
<li><b>stacksize</b> (default: 16384) Stacksize of each fiber. </li>
</ul>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00205">205</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2fb58058f6696de8487d69874fe440a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::edge_data_type <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#a2fb58058f6696de8487d69874fe440a1">edge_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of data associated with each edge in the graph. </p>
<p>The edge data type must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00252">252</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78c69960be1acdd5dce2dcad947298da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#a78c69960be1acdd5dce2dcad947298da">edge_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to represent an edge in the graph. See <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graphlab::distributed_graph::edge_type</a> for details. </p>
<p>The edge type contains the function <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">graphlab::distributed_graph::edge_type::data</a> which returns a reference to the edge data. In addition the edge type contains the function <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a5d8d51b99bfbfb361d7894a6d8e67ce1">graphlab::distributed_graph::edge_type::source</a> and <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">graphlab::distributed_graph::edge_type::target</a>. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00285">285</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3274ece76793cb995c7472d5927f6659"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::gather_type <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#a3274ece76793cb995c7472d5927f6659">gather_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined type returned by the gather function. </p>
<p>The gather type is defined in the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface and is the value returned by the <a class="el" href="classgraphlab_1_1ivertex__program.html#a7ad835ddf125627fcedce3a3172428ef">graphlab::ivertex_program::gather</a> function. The gather type must have an <code>operator+=(const gather_type&amp; other)</code> function and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00226">226</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d7ffa03bdea6d0bb29cf1f3a958969f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::graph_type <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#a6d7ffa03bdea6d0bb29cf1f3a958969f">graph_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of graph supported by this vertex program. </p>
<p>See <a class="el" href="classgraphlab_1_1distributed__graph.html" title="A directed graph datastructure which is distributed across multiple machines. ">graphlab::distributed_graph</a> </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00259">259</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbdf2e92167ac1765c3aa9adf4fba436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgraphlab_1_1icontext.html">icontext</a>&lt;<a class="el" href="classgraphlab_1_1async__consistent__engine.html#a6d7ffa03bdea6d0bb29cf1f3a958969f">graph_type</a>, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a3274ece76793cb995c7472d5927f6659">gather_type</a>, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a>&gt; <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#acbdf2e92167ac1765c3aa9adf4fba436">icontext_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the callback interface passed by the engine to vertex programs. See <a class="el" href="classgraphlab_1_1icontext.html">graphlab::icontext</a> for details. </p>
<p>The context callback is passed to the vertex program functions and is used to signal other vertices, get the current iteration, and access information about the engine. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00295">295</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6de61894637a15a7ddc2c02591791ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::message_type <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ab6de61894637a15a7ddc2c02591791ef">message_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined message type used to signal neighboring vertex programs. </p>
<p>The message type is defined in the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface and used in the call to <a class="el" href="classgraphlab_1_1icontext.html#ab1b5ca81e1c7665a98f4cad04fb0819d">graphlab::icontext::signal</a>. The message type must have an <code>operator+=(const gather_type&amp; other)</code> function and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00238">238</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afab7c1d1fab2c3d7255e933b6ea481d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram::vertex_data_type <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#afab7c1d1fab2c3d7255e933b6ea481d4">vertex_data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of data associated with each vertex in the graph. </p>
<p>The vertex data type must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00245">245</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2891dfe4f06647e4574d5e06f83b27e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VertexProgram <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#a2891dfe4f06647e4574d5e06f83b27e0">vertex_program_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user defined vertex program type. Equivalent to the VertexProgram template argument. </p>
<p>The user defined vertex program type which should implement the <a class="el" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a> interface. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00215">215</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4d7c391670c7f5f9d34b1b528bc7275"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html#ad4d7c391670c7f5f9d34b1b528bc7275">vertex_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used to represent a vertex in the graph. See <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graphlab::distributed_graph::vertex_type</a> for details. </p>
<p>The vertex type contains the function <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">graphlab::distributed_graph::vertex_type::data</a> which returns a reference to the vertex data as well as other functions like <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a485616c8965fcd995cb705722b6b4757">graphlab::distributed_graph::vertex_type::num_in_edges</a> which returns the number of in edges. </p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00272">272</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7eacc7f1ecff97059519f609686c9b5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1async__consistent__engine.html">async_consistent_engine</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1async__consistent__engine.html#a6d7ffa03bdea6d0bb29cf1f3a958969f">graph_type</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an asynchronous consistent distributed engine. The number of threads to create are read from <a class="el" href="classgraphlab_1_1graphlab__options.html#a8dae0062a8b67f8066a20f15c54e6d3e">opts.get_ncpus()</a>. The scheduler to construct is read from <a class="el" href="classgraphlab_1_1graphlab__options.html#a5e2149acc0d4e2da23e21d54197c5e54">opts.get_scheduler_type()</a>. The default scheduler is the queued_fifo scheduler. For details on the scheduler types </p><dl class="section see"><dt>See also</dt><dd>scheduler_types</dd></dl>
<p>See the <a href="#engineopts">main class documentation</a> for the available engine options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>Distributed controller to associate with </td></tr>
    <tr><td class="paramname">graph</td><td>The graph to schedule over. The graph must be fully constructed and finalized. </td></tr>
    <tr><td class="paramname">opts</td><td>A <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab::graphlab_options</a> object containing options and parameters for the scheduler and the engine. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00438">438</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adf21f70c04f6e9954e5db488cad6bff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename EdgeMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_edge_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name already exists. </p>
<p>Creates a edge aggregator associated to a particular key. The map_function is called over every edge in the graph, and the return value of the map is summed. The finalize_function is then called on the result of the reduction. The finalize_function is called on all machines. The map_function should only read the graph data, and should not make any modifications.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>An aggregator can be constructed to compute the absolute sum of all the edge data. To do this, we define two functions. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_edge_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define the aggregator in the engine by calling <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. We must assign it a unique name which will be used to reference this particular aggregate operation. We shall call it "absolute_edge_sum". </p><div class="fragment"><div class="line">engine.add_edge_aggregator&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>,</div>
<div class="line">                                    absolute_edge_data, </div>
<div class="line">                                    print_finalize);</div>
</div><!-- fragment --><p>When executed, the engine execute <code>absolute_edge_data()</code> on each edge in the graph. <code>absolute_edge_data()</code> reads the edge data, and returns its absolute value. All return values are then summing them together using the float's += operator. The final result is than passed to the <code>print_finalize</code> function. The template argument <code>&lt;float&gt;</code> is necessary to provide information about the return type of <code>absolute_edge_data</code>.</p>
<p>This aggregator can be run immediately by calling <a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742" title="Performs an immediate aggregation on a key. ">aggregate_now()</a> with the name of the aggregator. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>);</div>
</div><!-- fragment --><p>Or can be arranged to run periodically together with the engine execution (in this example, every 1.5 seconds). </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><p>Note that since finalize is called on <b>all machines</b>, multiple copies of the total will be printed. If only one copy is desired, see <a class="el" href="classgraphlab_1_1icontext.html#a7f827dd93aba5809b69cf659554f8869">context.cout()</a> or to get the actual process ID using <a class="el" href="classgraphlab_1_1icontext.html#ab57348d56fb08bd10f3edbccc4137cb1">context.procid()</a></p>
<h3>Details</h3>
<p>The <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> function is also templatized over both function types and there is no strong enforcement of the exact argument types of the map function and the reduce function. For instance, in the above example, the following print_finalize() variants may also be accepted.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">double</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In particlar, the last variation may be useful for performance reasons if the reduction type is large.</p>
<h3>Distributed Behavior</h3>
<p>To obtain consistent distributed behavior in the distributed setting, we designed the aggregator to minimize the amount of asymmetry among the machines. In particular, the finalize operation is guaranteed to be called on all machines. This therefore permits global variables to be modified on finalize since all machines are ensured to be eventually consistent.</p>
<p>For instance, in the above example, print_finalize could store the result in a global variable: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  GLOBAL_TOTAL = total;</div>
<div class="line">}</div>
</div><!-- fragment --><p> which will make it accessible to all other running update functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00692">692</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d1407b75158fdaef63eec9719da40da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename EdgeMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_edge_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload of add_edge_aggregator for C++11 which does not require the user to provide the reduction type. </p>
<p>This function is available only if the compiler has C++11 support. Specifically, it uses C++11's decltype operation to infer the reduction type, thus eliminating the need for the function call to be templatized over the reduction type. For instance, in the <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> example, it allows the following code to be written: </p><div class="fragment"><div class="line">engine.add_edge_aggregator(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>,</div>
<div class="line">                             absolute_edge_data, </div>
<div class="line">                             print_finalize);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00748">748</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39c802e7271358becf2cf2b2418b943a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename VertexMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_vertex_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name already exists. </p>
<p>Creates a vertex aggregator associated to a particular key. The map_function is called over every vertex in the graph, and the return value of the map is summed. The finalize_function is then called on the result of the reduction. The finalize_function is called on all machines. The map_function should only read the graph data, and should not make any modifications.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>An aggregator can be constructed to compute the absolute sum of all the vertex data. To do this, we define two functions. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_vertex_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                           <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, </div>
<div class="line">                    <span class="keywordtype">float</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define the aggregator in the engine by calling <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a>. We must assign it a unique name which will be used to reference this particular aggregate operation. We shall call it "absolute_vertex_sum". </p><div class="fragment"><div class="line">engine.add_vertex_aggregator&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>,</div>
<div class="line">                                    absolute_vertex_data, </div>
<div class="line">                                    print_finalize);</div>
</div><!-- fragment --><p>When executed, the engine execute <code>absolute_vertex_data()</code> on each vertex in the graph. <code>absolute_vertex_data()</code> reads the vertex data, and returns its absolute value. All return values are then summing them together using the float's += operator. The final result is than passed to the <code>print_finalize</code> function. The template argument <code>&lt;float&gt;</code> is necessary to provide information about the return type of <code>absolute_vertex_data</code>.</p>
<p>This aggregator can be run immediately by calling <a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742" title="Performs an immediate aggregation on a key. ">aggregate_now()</a> with the name of the aggregator. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>);</div>
</div><!-- fragment --><p>Or can be arranged to run periodically together with the engine execution (in this example, every 1.5 seconds). </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><p>Note that since finalize is called on <b>all machines</b>, multiple copies of the total will be printed. If only one copy is desired, see <a class="el" href="classgraphlab_1_1icontext.html#a7f827dd93aba5809b69cf659554f8869">context.cout()</a> or to get the actual process ID using <a class="el" href="classgraphlab_1_1icontext.html#ab57348d56fb08bd10f3edbccc4137cb1">context.procid()</a></p>
<p>In practice, the reduction type can be any arbitrary user-defined type as long as a += operator is defined. This permits great flexibility in the type of operations the aggregator can perform.</p>
<h3>Details</h3>
<p>The <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> function is also templatized over both function types and there is no strong enforcement of the exact argument types of the map function and the reduce function. For instance, in the above example, the following print_finalize() variants may also be accepted.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">double</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In particlar, the last variation may be useful for performance reasons if the reduction type is large.</p>
<h3>Distributed Behavior</h3>
<p>To obtain consistent distributed behavior in the distributed setting, we designed the aggregator to minimize the amount of asymmetry among the machines. In particular, the finalize operation is guaranteed to be called on all machines. This therefore permits global variables to be modified on finalize since all machines are ensured to be eventually consistent.</p>
<p>For instance, in the above example, print_finalize could store the result in a global variable: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  GLOBAL_TOTAL = total;</div>
<div class="line">}</div>
</div><!-- fragment --><p> which will make it accessible to all other running update functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00484">484</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafefe848a350d243f62fefe173d3d287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename VertexMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_vertex_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload of add_vertex_aggregator for C++11 which does not require the user to provide the reduction type. </p>
<p>This function is available only if the compiler has C++11 support. Specifically, it uses C++11's decltype operation to infer the reduction type, thus eliminating the need for the function call to be templatized over the reduction type. For instance, in the <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> example, it allows the following code to be written: </p><div class="fragment"><div class="line">engine.add_vertex_aggregator(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>,</div>
<div class="line">                             absolute_vertex_data, </div>
<div class="line">                             print_finalize);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00539">539</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f0ebbe2a3dae9ed3e7cbe6538e37742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::aggregate_now </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an immediate aggregation on a key. </p>
<p>Performs an immediate aggregation on a key. All machines must call this simultaneously. If the key is not found, false is returned. Otherwise returns true on success.</p>
<p>For instance, the following code will run the aggregator with the name "absolute_vertex_sum" immediately. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to aggregate now. Must be a key previously created by <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> or <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if key not found, True on success. </dd></dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00780">780</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6602b1e06b1b4db6537e6e48774499b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::aggregate_periodic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that a particular aggregation key be recomputed periodically when the engine is running. </p>
<p>Requests that the aggregator with a given key be aggregated every certain number of seconds when the engine is running. Note that the period is prescriptive: in practice the actual period will be larger than the requested period. Seconds must be &gt;= 0;</p>
<p>For instance, the following code will schedule the aggregator with the name "absolute_vertex_sum" to run every 1.5 seconds. </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to schedule. Must be a key previously created by <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> or <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>How frequently to schedule. Must be &gt;= 0. seconds == 0 will ensure that this key is continously recomputed.</td></tr>
  </table>
  </dd>
</dl>
<p>All machines must call simultaneously. </p><dl class="section return"><dt>Returns</dt><dd>Returns true if key is found and seconds &gt;= 0, and false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01169">1169</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa8bb090bb0404f9de780130411724fdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::elapsed_seconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the elapsed time in seconds since start was last called. </p>
<dl class="section return"><dt>Returns</dt><dd>elapsed time in seconds </dd></dl>

<p>Implements <a class="el" href="classgraphlab_1_1iengine.html#ab79866fc3e1a3e83cc0c022d1cababcb">graphlab::iengine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00581">581</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8da8e299fd9bfc87e308d5ad571f35eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename EdgeMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::map_reduce_edges </td>
          <td>(</td>
          <td class="paramtype">EdgeMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each edge in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> call the map function on all edges in the graph. The return values are then summed together and the final result returned. The map function should only read data and should not make any modifications. <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the edge data, we would write a function which reads in each a edge, and returns the absolute value of the data on the edge. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_edge_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = engine.map_reduce_edges&lt;<span class="keywordtype">float</span>&gt;(absolute_edge_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_edge_data()</code> function on each edge in the graph. <code>absolute_edge_data()</code> reads the value of the edge and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<h3>Signalling</h3>
<p>Another common use for the <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> function is in signalling. Since the map function is passed a context, it can be used to perform signalling of edges for execution during a later <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">engine.start()</a> call.</p>
<p>For instance, the following code will signal the source vertex of each edge. </p><div class="fragment"><div class="line">graphlab::empty signal_source(engine_type::icontext_type&amp; context,</div>
<div class="line">                              <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  context.signal(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a5d8d51b99bfbfb361d7894a6d8e67ce1">source</a>());</div>
<div class="line">  <span class="keywordflow">return</span> graphlab::empty()</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that in this case, we are not interested in a reduction operation, and thus we return a graphlab::empty object. Calling: </p><div class="fragment"><div class="line">engine.map_reduce_edges&lt;graphlab::empty&gt;(signal_source);</div>
</div><!-- fragment --><p> will run <code>signal_source()</code> on all edges, signalling all source vertices.</p>
<h3>Relations</h3>
<p>The map function has the same structure as that in <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> and may be reused in an aggregator. This function is also very similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">graphlab::distributed_graph::map_reduce_edges()</a> with the difference that this takes a context and thus can be used to perform signalling. Finally <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00974">974</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b3fde48e79d248db7b815a313cd92e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename VertexMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::map_reduce_vertices </td>
          <td>(</td>
          <td class="paramtype">VertexMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each vertex in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> call the map function on all vertices in the graph. The return values are then summed together and the final result returned. The map function should only read the vertex data and should not make any modifications. <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the vertex data, we would write a function which reads in each a vertex, and returns the absolute value of the data on the vertex. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_vertex_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                           <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = engine.map_reduce_vertices&lt;<span class="keywordtype">float</span>&gt;(absolute_vertex_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_vertex_data()</code> function on each vertex in the graph. <code>absolute_vertex_data()</code> reads the value of the vertex and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<h3>Signalling</h3>
<p>Another common use for the <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> function is in signalling. Since the map function is passed a context, it can be used to perform signalling of vertices for execution during a later <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">engine.start()</a> call.</p>
<p>For instance, the following code will signal all vertices with value &gt;= 1 </p><div class="fragment"><div class="line">graphlab::empty signal_vertices(engine_type::icontext_type&amp; context,</div>
<div class="line">                                <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">if</span> (vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() &gt;= 1) context.signal(vertex);</div>
<div class="line">  <span class="keywordflow">return</span> graphlab::empty()</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that in this case, we are not interested in a reduction operation, and thus we return a graphlab::empty object. Calling: </p><div class="fragment"><div class="line">engine.map_reduce_vertices&lt;graphlab::empty&gt;(signal_vertices);</div>
</div><!-- fragment --><p> will run <code>signal_vertices()</code> on all vertices, signalling all vertices with value &lt;= 1</p>
<h3>Relations</h3>
<p>The map function has the same structure as that in <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> and may be reused in an aggregator. This function is also very similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">graphlab::distributed_graph::map_reduce_vertices()</a> with the difference that this takes a context and thus can be used to perform signalling. Finally <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00876">876</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e6664119b88c6e6f71c37312c511b6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::num_updates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the total number of updates (calls to apply) executed since start was last invoked. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of updates </dd></dl>

<p>Implements <a class="el" href="classgraphlab_1_1iengine.html#a647a3fa264ee6a9495c07dc746861dc0">graphlab::iengine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l00572">572</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab945aad4bc982b507efc1ba55dba30d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals single a vertex with an optional message. </p>
<p>This function sends a message to particular vertex which will receive that message on start. The signal function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>Since signal is executed synchronously on all machines it should only be used to schedule a small set of vertices. The preferred method to signal a large set of vertices (e.g., all vertices that are a certain type) is to use either the vertex program init function or the aggregation framework. For example to signal all vertices that have a particular value one could write:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>bipartite_opt : </div>
<div class="line">  <span class="keyword">public</span> <a class="code" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt;graph_type, gather_type&gt; {</div>
<div class="line">  <span class="comment">// The user defined init function</span></div>
<div class="line">  <span class="keywordtype">void</span> init(<a class="code" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; context, <a class="code" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>&amp; vertex) {</div>
<div class="line">    <span class="comment">// Signal myself if I am a certain type</span></div>
<div class="line">    <span class="keywordflow">if</span>(vertex.data().on_left) context.signal(vertex);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// other vastly more interesting code</span></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>the vertex id to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to that vertex. The default message is sent if no message is provided. (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a47405eda2a7799df25d5a4d0ab4a9366">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0afe236029be943f870a77bd2a6b3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal all vertices with a particular message. </p>
<p>This function sends the same message to all vertices which will receive that message on start. The signal_all function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_all(); <span class="comment">// signal all vertices</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal_all(); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>The signal_all function is the most common way to send messages to the engine. For example in the pagerank application we want all vertices to be active on the first round. Therefore we would write:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;pagerank&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_all();</div>
<div class="line">engine.start();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a03414d20429d8b29e5091a6bcee137d2">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a86a7a9e2b10c0934d4c486c56c649c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal_vset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal a set of vertices with a particular message. </p>
<p>This function sends the same message to a set of vertices which will receive that message on start. The signal_vset function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_vset(vset); <span class="comment">// signal a subset of vertices</span></div>
</div><!-- fragment --><p><a class="el" href="classgraphlab_1_1iengine.html#a9c0afe236029be943f870a77bd2a6b3f" title="Signal all vertices with a particular message. ">signal_all()</a> is conceptually equivalent to:</p>
<div class="fragment"><div class="line">engine.signal_vset(graph.complete_set());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vset</td><td>The set of vertices to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a6b208b86489a26f00e225efbdf2278de">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8d23f6137fa3816023fc501060fc816d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a> <a class="el" href="classgraphlab_1_1async__consistent__engine.html">graphlab::async_consistent_engine</a>&lt; VertexProgram &gt;::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the engine execution. </p>
<p>This function starts the engine and does not return until the scheduler has no tasks remaining.</p>
<dl class="section return"><dt>Returns</dt><dd>the reason for termination </dd></dl>

<p>Implements <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">graphlab::iengine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="async__consistent__engine_8hpp_source.html#l01210">1210</a> of file <a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ab681ecccc66ad8696f5a4d0103fa23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename EdgeMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::transform_edges </td>
          <td>(</td>
          <td class="paramtype">EdgeMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each edge in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> calls mapfunction on every edge in graph. The map function may make modifications to the data on the edge. <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To set each edge value to be the number of out-going edges of the target vertex, we may write the following: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_edge_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>() = edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>().<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a>: </p><div class="fragment"><div class="line">engine.transform_edges(set_edge_value);</div>
</div><!-- fragment --><p> will run the <code>set_edge_value()</code> function on each edge in the graph, setting its new value.</p>
<h3>Signalling</h3>
<p>Since the mapfunction is provided with a context, the mapfunction can also be used to perform signalling. For instance, the <code>set_edge_value</code> function above may be modified to set the value of the edge, but to also signal the target vertex.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_edge_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>() = edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>().<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">  context.signal(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, if the purpose of the function is to only signal without making modifications, <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> will be more efficient as this function will additionally perform distributed synchronization of modified data.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">graphlab::distributed_graph::transform_edges()</a> provide the same graph modification capabilities, but without a context and thus cannot perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns void. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01132">1132</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d9e97843604c45c08f71502b3494a7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename VertexMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::transform_vertices </td>
          <td>(</td>
          <td class="paramtype">VertexMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each vertex in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> calls mapfunction on every vertex in graph. The map function may make modifications to the data on the vertex. <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> must be called by all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To set each vertex value to be the number of out-going edges, we may write the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_vertex_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() = vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a>: </p><div class="fragment"><div class="line">engine.transform_vertices(set_vertex_value);</div>
</div><!-- fragment --><p> will run the <code>set_vertex_value()</code> function on each vertex in the graph, setting its new value.</p>
<h3>Signalling</h3>
<p>Since the mapfunction is provided with a context, the mapfunction can also be used to perform signalling. For instance, the <code>set_vertex_value</code> function above may be modified to set the value of the vertex, but to also signal the vertex if it has more than 5 outgoing edges.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_vertex_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() = vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>() &gt; 5) context.signal(vertex);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, if the purpose of the function is to only signal without making modifications, <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> will be more efficient as this function will additionally perform distributed synchronization of modified data.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">graphlab::distributed_graph::transform_vertices()</a> provide the same graph modification capabilities, but without a context and thus cannot perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns void. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01055">1055</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/engine/<a class="el" href="async__consistent__engine_8hpp_source.html">async_consistent_engine.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1async__consistent__engine.html">async_consistent_engine</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:27 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
