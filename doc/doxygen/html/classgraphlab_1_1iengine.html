<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::iengine&lt; VertexProgram &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1iengine.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgraphlab_1_1iengine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::iengine&lt; VertexProgram &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The abstract interface of a GraphLab engine.  
 <a href="classgraphlab_1_1iengine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iengine_8hpp_source.html">graphlab/engine/iengine.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5cc6461ae92774e093feaceccf24848a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cc6461ae92774e093feaceccf24848a"></a>
typedef VertexProgram&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a5cc6461ae92774e093feaceccf24848a">vertex_program_type</a></td></tr>
<tr class="memdesc:a5cc6461ae92774e093feaceccf24848a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined vertex program type which should extend <a class="el" href="classgraphlab_1_1ivertex__program.html" title="The ivertex_program class defines the vertex program interface that all vertex programs should extend...">ivertex_program</a>. <br /></td></tr>
<tr class="separator:a5cc6461ae92774e093feaceccf24848a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc6e6f972d933599aed2ec415ed736c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbc6e6f972d933599aed2ec415ed736c"></a>
typedef vertex_program_type::message_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a></td></tr>
<tr class="memdesc:afbc6e6f972d933599aed2ec415ed736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user defined message type which is defined in <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a>. <br /></td></tr>
<tr class="separator:afbc6e6f972d933599aed2ec415ed736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6e0bf905c5fb5dc5a1c2de2d1eae6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e6e0bf905c5fb5dc5a1c2de2d1eae6d"></a>
typedef vertex_program_type::graph_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a></td></tr>
<tr class="memdesc:a2e6e0bf905c5fb5dc5a1c2de2d1eae6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph type which is defined in <a class="el" href="classgraphlab_1_1ivertex__program.html#acbde69d82102416f106230ec726e5d55" title="The graph type associative with this vertex program. ">ivertex_program::graph_type</a> and will typically be <a class="el" href="classgraphlab_1_1distributed__graph.html">distributed_graph</a>. <br /></td></tr>
<tr class="separator:a2e6e0bf905c5fb5dc5a1c2de2d1eae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01472800a89cef585293b074e4aa9925"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01472800a89cef585293b074e4aa9925"></a>
typedef graph_type::vertex_id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a></td></tr>
<tr class="memdesc:a01472800a89cef585293b074e4aa9925"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex identifier type defined in graphlab::vertex_id_type. <br /></td></tr>
<tr class="separator:a01472800a89cef585293b074e4aa9925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4f90ec999e065d477acba6e7dfd6ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae4f90ec999e065d477acba6e7dfd6ee"></a>
typedef graph_type::vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a></td></tr>
<tr class="memdesc:aae4f90ec999e065d477acba6e7dfd6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">the vertex object type which contains a reference to the vertex data and is defined in the <a class="el" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d" title="The graph type which is defined in ivertex_program::graph_type and will typically be distributed_grap...">iengine::graph_type</a> (see for example <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">distributed_graph::vertex_type</a>). <br /></td></tr>
<tr class="separator:aae4f90ec999e065d477acba6e7dfd6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2747429476d36e7d188e3d8a1e0fec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec2747429476d36e7d188e3d8a1e0fec"></a>
typedef <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a></td></tr>
<tr class="memdesc:aec2747429476d36e7d188e3d8a1e0fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">the edge object type which contains a reference to the edge data and is defined in the <a class="el" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d" title="The graph type which is defined in ivertex_program::graph_type and will typically be distributed_grap...">iengine::graph_type</a> (see for example <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">distributed_graph::edge_type</a>). <br /></td></tr>
<tr class="separator:aec2747429476d36e7d188e3d8a1e0fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847cab376e9e1794a578fe3120fc91d3"><td class="memItemLeft" align="right" valign="top">typedef vertex_program_type::icontext_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a></td></tr>
<tr class="memdesc:a847cab376e9e1794a578fe3120fc91d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context type which is passed into vertex programs as a callback to the engine.  <a href="#a847cab376e9e1794a578fe3120fc91d3">More...</a><br /></td></tr>
<tr class="separator:a847cab376e9e1794a578fe3120fc91d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7635b47e0f3ac5afc7c9d3a334ed94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f7635b47e0f3ac5afc7c9d3a334ed94"></a>
typedef distributed_aggregator&lt; <a class="el" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>, <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a7f7635b47e0f3ac5afc7c9d3a334ed94">aggregator_type</a></td></tr>
<tr class="memdesc:a7f7635b47e0f3ac5afc7c9d3a334ed94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the distributed aggregator used by each engine to implement distributed aggregation. <br /></td></tr>
<tr class="separator:a7f7635b47e0f3ac5afc7c9d3a334ed94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3c839f878408c1df7d2f2c164f7c36a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">start</a> ()=0</td></tr>
<tr class="memdesc:ae3c839f878408c1df7d2f2c164f7c36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the engine execution.  <a href="#ae3c839f878408c1df7d2f2c164f7c36a">More...</a><br /></td></tr>
<tr class="separator:ae3c839f878408c1df7d2f2c164f7c36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647a3fa264ee6a9495c07dc746861dc0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a647a3fa264ee6a9495c07dc746861dc0">num_updates</a> () const =0</td></tr>
<tr class="memdesc:a647a3fa264ee6a9495c07dc746861dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the total number of updates (calls to apply) executed since start was last invoked.  <a href="#a647a3fa264ee6a9495c07dc746861dc0">More...</a><br /></td></tr>
<tr class="separator:a647a3fa264ee6a9495c07dc746861dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79866fc3e1a3e83cc0c022d1cababcb"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#ab79866fc3e1a3e83cc0c022d1cababcb">elapsed_seconds</a> () const =0</td></tr>
<tr class="memdesc:ab79866fc3e1a3e83cc0c022d1cababcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the elapsed time in seconds since start was last called.  <a href="#ab79866fc3e1a3e83cc0c022d1cababcb">More...</a><br /></td></tr>
<tr class="separator:ab79866fc3e1a3e83cc0c022d1cababcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bad0c682ba561287f648544cd0a0068"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a2bad0c682ba561287f648544cd0a0068">iteration</a> () const </td></tr>
<tr class="memdesc:a2bad0c682ba561287f648544cd0a0068"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current iteration number. This is not defined for all engines in which case -1 is returned.  <a href="#a2bad0c682ba561287f648544cd0a0068">More...</a><br /></td></tr>
<tr class="separator:a2bad0c682ba561287f648544cd0a0068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab945aad4bc982b507efc1ba55dba30d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#ab945aad4bc982b507efc1ba55dba30d8">signal</a> (<a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a> vertex, const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>())=0</td></tr>
<tr class="memdesc:ab945aad4bc982b507efc1ba55dba30d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals single a vertex with an optional message.  <a href="#ab945aad4bc982b507efc1ba55dba30d8">More...</a><br /></td></tr>
<tr class="separator:ab945aad4bc982b507efc1ba55dba30d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0afe236029be943f870a77bd2a6b3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a9c0afe236029be943f870a77bd2a6b3f">signal_all</a> (const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)=0</td></tr>
<tr class="memdesc:a9c0afe236029be943f870a77bd2a6b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all vertices with a particular message.  <a href="#a9c0afe236029be943f870a77bd2a6b3f">More...</a><br /></td></tr>
<tr class="separator:a9c0afe236029be943f870a77bd2a6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a7a9e2b10c0934d4c486c56c649c13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a86a7a9e2b10c0934d4c486c56c649c13">signal_vset</a> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset, const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;message=<a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>(), const std::string &amp;order=&quot;shuffle&quot;)=0</td></tr>
<tr class="memdesc:a86a7a9e2b10c0934d4c486c56c649c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a set of vertices with a particular message.  <a href="#a86a7a9e2b10c0934d4c486c56c649c13">More...</a><br /></td></tr>
<tr class="separator:a86a7a9e2b10c0934d4c486c56c649c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c802e7271358becf2cf2b2418b943a"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename VertexMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:a39c802e7271358becf2cf2b2418b943a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a">add_vertex_aggregator</a> (const std::string &amp;key, VertexMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:a39c802e7271358becf2cf2b2418b943a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name already exists.  <a href="#a39c802e7271358becf2cf2b2418b943a">More...</a><br /></td></tr>
<tr class="separator:a39c802e7271358becf2cf2b2418b943a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafefe848a350d243f62fefe173d3d287"><td class="memTemplParams" colspan="2">template&lt;typename VertexMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:aafefe848a350d243f62fefe173d3d287"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#aafefe848a350d243f62fefe173d3d287">add_vertex_aggregator</a> (const std::string &amp;key, VertexMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:aafefe848a350d243f62fefe173d3d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of add_vertex_aggregator for C++11 which does not require the user to provide the reduction type.  <a href="#aafefe848a350d243f62fefe173d3d287">More...</a><br /></td></tr>
<tr class="separator:aafefe848a350d243f62fefe173d3d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21f70c04f6e9954e5db488cad6bff0"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename EdgeMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:adf21f70c04f6e9954e5db488cad6bff0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0">add_edge_aggregator</a> (const std::string &amp;key, EdgeMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:adf21f70c04f6e9954e5db488cad6bff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name already exists.  <a href="#adf21f70c04f6e9954e5db488cad6bff0">More...</a><br /></td></tr>
<tr class="separator:adf21f70c04f6e9954e5db488cad6bff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1407b75158fdaef63eec9719da40da"><td class="memTemplParams" colspan="2">template&lt;typename EdgeMapType , typename FinalizerType &gt; </td></tr>
<tr class="memitem:a6d1407b75158fdaef63eec9719da40da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a6d1407b75158fdaef63eec9719da40da">add_edge_aggregator</a> (const std::string &amp;key, EdgeMapType map_function, FinalizerType finalize_function)</td></tr>
<tr class="memdesc:a6d1407b75158fdaef63eec9719da40da"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of add_edge_aggregator for C++11 which does not require the user to provide the reduction type.  <a href="#a6d1407b75158fdaef63eec9719da40da">More...</a><br /></td></tr>
<tr class="separator:a6d1407b75158fdaef63eec9719da40da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742">aggregate_now</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an immediate aggregation on a key.  <a href="#a5f0ebbe2a3dae9ed3e7cbe6538e37742">More...</a><br /></td></tr>
<tr class="separator:a5f0ebbe2a3dae9ed3e7cbe6538e37742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3fde48e79d248db7b815a313cd92e2"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename VertexMapperType &gt; </td></tr>
<tr class="memitem:a1b3fde48e79d248db7b815a313cd92e2"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2">map_reduce_vertices</a> (VertexMapperType mapfunction)</td></tr>
<tr class="memdesc:a1b3fde48e79d248db7b815a313cd92e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each vertex in the graph returning the result.  <a href="#a1b3fde48e79d248db7b815a313cd92e2">More...</a><br /></td></tr>
<tr class="separator:a1b3fde48e79d248db7b815a313cd92e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename EdgeMapperType &gt; </td></tr>
<tr class="memitem:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb">map_reduce_edges</a> (EdgeMapperType mapfunction)</td></tr>
<tr class="memdesc:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each edge in the graph returning the result.  <a href="#a8da8e299fd9bfc87e308d5ad571f35eb">More...</a><br /></td></tr>
<tr class="separator:a8da8e299fd9bfc87e308d5ad571f35eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e97843604c45c08f71502b3494a7a"><td class="memTemplParams" colspan="2">template&lt;typename VertexMapperType &gt; </td></tr>
<tr class="memitem:a4d9e97843604c45c08f71502b3494a7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a">transform_vertices</a> (VertexMapperType mapfunction)</td></tr>
<tr class="memdesc:a4d9e97843604c45c08f71502b3494a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each vertex in the graph.  <a href="#a4d9e97843604c45c08f71502b3494a7a">More...</a><br /></td></tr>
<tr class="separator:a4d9e97843604c45c08f71502b3494a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memTemplParams" colspan="2">template&lt;typename EdgeMapperType &gt; </td></tr>
<tr class="memitem:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23">transform_edges</a> (EdgeMapperType mapfunction)</td></tr>
<tr class="memdesc:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each edge in the graph.  <a href="#a4ab681ecccc66ad8696f5a4d0103fa23">More...</a><br /></td></tr>
<tr class="separator:a4ab681ecccc66ad8696f5a4d0103fa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602b1e06b1b4db6537e6e48774499b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1iengine.html#a6602b1e06b1b4db6537e6e48774499b9">aggregate_periodic</a> (const std::string &amp;key, float seconds)</td></tr>
<tr class="memdesc:a6602b1e06b1b4db6537e6e48774499b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that a particular aggregation key be recomputed periodically when the engine is running.  <a href="#a6602b1e06b1b4db6537e6e48774499b9">More...</a><br /></td></tr>
<tr class="separator:a6602b1e06b1b4db6537e6e48774499b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VertexProgram&gt;<br />
class graphlab::iengine&lt; VertexProgram &gt;</h3>

<p>The abstract interface of a GraphLab engine. </p>
<p>A GraphLab engine is responsible for executing vertex programs in parallel on one or more machines. GraphLab has a collection of different engines with different guarantees on how vertex-programs are executed. However each engine must implement the iengine interface to allow them to be used "interchangeably."</p>
<p>In addition to executing vertex programs GraphLab engines also expose a synchronous aggregation framework. This allows users to attach "map-reduce" style jobs that are run periodically on all edges or vertices while GraphLab programs are actively running.</p>
<h1>Example Usage </h1>
<p>One can use the iengine interface to select between different engines at runtime:</p>
<div class="fragment"><div class="line">iengine&lt;pagerank&gt;* engine_ptr = NULL;</div>
<div class="line"><span class="keywordflow">if</span>(cmdline_arg == <span class="stringliteral">&quot;synchronous&quot;</span>) {</div>
<div class="line">  engine_ptr = <span class="keyword">new</span> synchronous_engine&lt;pagerank&gt;(dc, graph, cmdopts);  </div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  engine_ptr = <span class="keyword">new</span> async_consistent_engine&lt;pagerank&gt;(dc, graph, cmdopts);  </div>
<div class="line">}</div>
<div class="line"><span class="comment">// Attach an aggregator</span></div>
<div class="line">engine_ptr-&gt;add_edge_aggregator&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;edge_map&quot;</span>, </div>
<div class="line">                                       edge_map_fun, finalize_fun);</div>
<div class="line"><span class="comment">// Make it run every 3 seconds</span></div>
<div class="line">engine_ptr-&gt;aggregate_periodic(<span class="stringliteral">&quot;edge_map&quot;</span>);</div>
<div class="line"><span class="comment">// Signal all vertices</span></div>
<div class="line">engine_ptr-&gt;signal_all();</div>
<div class="line"><span class="comment">// Run the engine</span></div>
<div class="line">engine_ptr-&gt;start();</div>
<div class="line"><span class="comment">// do something interesting</span></div>
<div class="line"><span class="keyword">delete</span> engine_ptr; engine_ptr = NULL;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexProgram</td><td>The user defined vertex program which should extend the <a class="el" href="classgraphlab_1_1ivertex__program.html">ivertex_program</a> interface. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00105">105</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a847cab376e9e1794a578fe3120fc91d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef vertex_program_type::icontext_type <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::<a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The context type which is passed into vertex programs as a callback to the engine. </p>
<p>Most engines use the <a class="el" href="classgraphlab_1_1context.html">graphlab::context</a> implementation. </p>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00180">180</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adf21f70c04f6e9954e5db488cad6bff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename EdgeMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_edge_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name already exists. </p>
<p>Creates a edge aggregator associated to a particular key. The map_function is called over every edge in the graph, and the return value of the map is summed. The finalize_function is then called on the result of the reduction. The finalize_function is called on all machines. The map_function should only read the graph data, and should not make any modifications.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>An aggregator can be constructed to compute the absolute sum of all the edge data. To do this, we define two functions. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_edge_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define the aggregator in the engine by calling <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. We must assign it a unique name which will be used to reference this particular aggregate operation. We shall call it "absolute_edge_sum". </p><div class="fragment"><div class="line">engine.add_edge_aggregator&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>,</div>
<div class="line">                                    absolute_edge_data, </div>
<div class="line">                                    print_finalize);</div>
</div><!-- fragment --><p>When executed, the engine execute <code>absolute_edge_data()</code> on each edge in the graph. <code>absolute_edge_data()</code> reads the edge data, and returns its absolute value. All return values are then summing them together using the float's += operator. The final result is than passed to the <code>print_finalize</code> function. The template argument <code>&lt;float&gt;</code> is necessary to provide information about the return type of <code>absolute_edge_data</code>.</p>
<p>This aggregator can be run immediately by calling <a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742" title="Performs an immediate aggregation on a key. ">aggregate_now()</a> with the name of the aggregator. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>);</div>
</div><!-- fragment --><p>Or can be arranged to run periodically together with the engine execution (in this example, every 1.5 seconds). </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><p>Note that since finalize is called on <b>all machines</b>, multiple copies of the total will be printed. If only one copy is desired, see <a class="el" href="classgraphlab_1_1icontext.html#a7f827dd93aba5809b69cf659554f8869">context.cout()</a> or to get the actual process ID using <a class="el" href="classgraphlab_1_1icontext.html#ab57348d56fb08bd10f3edbccc4137cb1">context.procid()</a></p>
<h3>Details</h3>
<p>The <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> function is also templatized over both function types and there is no strong enforcement of the exact argument types of the map function and the reduce function. For instance, in the above example, the following print_finalize() variants may also be accepted.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">double</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In particlar, the last variation may be useful for performance reasons if the reduction type is large.</p>
<h3>Distributed Behavior</h3>
<p>To obtain consistent distributed behavior in the distributed setting, we designed the aggregator to minimize the amount of asymmetry among the machines. In particular, the finalize operation is guaranteed to be called on all machines. This therefore permits global variables to be modified on finalize since all machines are ensured to be eventually consistent.</p>
<p>For instance, in the above example, print_finalize could store the result in a global variable: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  GLOBAL_TOTAL = total;</div>
<div class="line">}</div>
</div><!-- fragment --><p> which will make it accessible to all other running update functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00692">692</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d1407b75158fdaef63eec9719da40da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename EdgeMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_edge_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload of add_edge_aggregator for C++11 which does not require the user to provide the reduction type. </p>
<p>This function is available only if the compiler has C++11 support. Specifically, it uses C++11's decltype operation to infer the reduction type, thus eliminating the need for the function call to be templatized over the reduction type. For instance, in the <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> example, it allows the following code to be written: </p><div class="fragment"><div class="line">engine.add_edge_aggregator(<span class="stringliteral">&quot;absolute_edge_sum&quot;</span>,</div>
<div class="line">                             absolute_edge_data, </div>
<div class="line">                             print_finalize);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00748">748</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39c802e7271358becf2cf2b2418b943a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename VertexMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_vertex_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name already exists. </p>
<p>Creates a vertex aggregator associated to a particular key. The map_function is called over every vertex in the graph, and the return value of the map is summed. The finalize_function is then called on the result of the reduction. The finalize_function is called on all machines. The map_function should only read the graph data, and should not make any modifications.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>An aggregator can be constructed to compute the absolute sum of all the vertex data. To do this, we define two functions. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_vertex_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                           <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, </div>
<div class="line">                    <span class="keywordtype">float</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define the aggregator in the engine by calling <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a>. We must assign it a unique name which will be used to reference this particular aggregate operation. We shall call it "absolute_vertex_sum". </p><div class="fragment"><div class="line">engine.add_vertex_aggregator&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>,</div>
<div class="line">                                    absolute_vertex_data, </div>
<div class="line">                                    print_finalize);</div>
</div><!-- fragment --><p>When executed, the engine execute <code>absolute_vertex_data()</code> on each vertex in the graph. <code>absolute_vertex_data()</code> reads the vertex data, and returns its absolute value. All return values are then summing them together using the float's += operator. The final result is than passed to the <code>print_finalize</code> function. The template argument <code>&lt;float&gt;</code> is necessary to provide information about the return type of <code>absolute_vertex_data</code>.</p>
<p>This aggregator can be run immediately by calling <a class="el" href="classgraphlab_1_1iengine.html#a5f0ebbe2a3dae9ed3e7cbe6538e37742" title="Performs an immediate aggregation on a key. ">aggregate_now()</a> with the name of the aggregator. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>);</div>
</div><!-- fragment --><p>Or can be arranged to run periodically together with the engine execution (in this example, every 1.5 seconds). </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><p>Note that since finalize is called on <b>all machines</b>, multiple copies of the total will be printed. If only one copy is desired, see <a class="el" href="classgraphlab_1_1icontext.html#a7f827dd93aba5809b69cf659554f8869">context.cout()</a> or to get the actual process ID using <a class="el" href="classgraphlab_1_1icontext.html#ab57348d56fb08bd10f3edbccc4137cb1">context.procid()</a></p>
<p>In practice, the reduction type can be any arbitrary user-defined type as long as a += operator is defined. This permits great flexibility in the type of operations the aggregator can perform.</p>
<h3>Details</h3>
<p>The <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> function is also templatized over both function types and there is no strong enforcement of the exact argument types of the map function and the reduce function. For instance, in the above example, the following print_finalize() variants may also be accepted.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">double</span> total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  std::cout &lt;&lt; total &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In particlar, the last variation may be useful for performance reasons if the reduction type is large.</p>
<h3>Distributed Behavior</h3>
<p>To obtain consistent distributed behavior in the distributed setting, we designed the aggregator to minimize the amount of asymmetry among the machines. In particular, the finalize operation is guaranteed to be called on all machines. This therefore permits global variables to be modified on finalize since all machines are ensured to be eventually consistent.</p>
<p>For instance, in the above example, print_finalize could store the result in a global variable: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> print_finalize(engine_type::icontext_type&amp; context, <span class="keywordtype">float</span> total) {</div>
<div class="line">  GLOBAL_TOTAL = total;</div>
<div class="line">}</div>
</div><!-- fragment --><p> which will make it accessible to all other running update functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00484">484</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafefe848a350d243f62fefe173d3d287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename VertexMapType , typename FinalizerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::add_vertex_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexMapType&#160;</td>
          <td class="paramname"><em>map_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinalizerType&#160;</td>
          <td class="paramname"><em>finalize_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload of add_vertex_aggregator for C++11 which does not require the user to provide the reduction type. </p>
<p>This function is available only if the compiler has C++11 support. Specifically, it uses C++11's decltype operation to infer the reduction type, thus eliminating the need for the function call to be templatized over the reduction type. For instance, in the <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> example, it allows the following code to be written: </p><div class="fragment"><div class="line">engine.add_vertex_aggregator(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>,</div>
<div class="line">                             absolute_vertex_data, </div>
<div class="line">                             print_finalize);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
    <tr><td class="paramname">FinalizerType</td><td>The type of the finalize function. Not generally needed. Can be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of this aggregator. Must be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_function</td><td>The Map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">finalize_function</td><td>The Finalize function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument and a ReductionType, or a reference to a ReductionType as its second argument. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00539">539</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f0ebbe2a3dae9ed3e7cbe6538e37742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::aggregate_now </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an immediate aggregation on a key. </p>
<p>Performs an immediate aggregation on a key. All machines must call this simultaneously. If the key is not found, false is returned. Otherwise returns true on success.</p>
<p>For instance, the following code will run the aggregator with the name "absolute_vertex_sum" immediately. </p><div class="fragment"><div class="line">engine.aggregate_now(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to aggregate now. Must be a key previously created by <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> or <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if key not found, True on success. </dd></dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00780">780</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6602b1e06b1b4db6537e6e48774499b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::aggregate_periodic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that a particular aggregation key be recomputed periodically when the engine is running. </p>
<p>Requests that the aggregator with a given key be aggregated every certain number of seconds when the engine is running. Note that the period is prescriptive: in practice the actual period will be larger than the requested period. Seconds must be &gt;= 0;</p>
<p>For instance, the following code will schedule the aggregator with the name "absolute_vertex_sum" to run every 1.5 seconds. </p><div class="fragment"><div class="line">engine.aggregate_periodic(<span class="stringliteral">&quot;absolute_vertex_sum&quot;</span>, 1.5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to schedule. Must be a key previously created by <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> or <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>How frequently to schedule. Must be &gt;= 0. seconds == 0 will ensure that this key is continously recomputed.</td></tr>
  </table>
  </dd>
</dl>
<p>All machines must call simultaneously. </p><dl class="section return"><dt>Returns</dt><dd>Returns true if key is found and seconds &gt;= 0, and false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01169">1169</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab79866fc3e1a3e83cc0c022d1cababcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::elapsed_seconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the elapsed time in seconds since start was last called. </p>
<dl class="section return"><dt>Returns</dt><dd>elapsed time in seconds </dd></dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1synchronous__engine.html#a2445bcd6a03578f62a4b3ca471777da3">graphlab::synchronous_engine&lt; VertexProgram &gt;</a>, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#aa8bb090bb0404f9de780130411724fdc">graphlab::async_consistent_engine&lt; VertexProgram &gt;</a>, and <a class="el" href="classgraphlab_1_1omni__engine.html#ae44a207f3e532ae0a9e256d595433504">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2bad0c682ba561287f648544cd0a0068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::iteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the current iteration number. This is not defined for all engines in which case -1 is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the current iteration or -1 if not supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classgraphlab_1_1synchronous__engine.html#abc4dc04bce51af81f928f00653fdb4fe">graphlab::synchronous_engine&lt; VertexProgram &gt;</a>, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a0b31760f49c29c0e0fff0c043e8a5028">graphlab::async_consistent_engine&lt; VertexProgram &gt;</a>, and <a class="el" href="classgraphlab_1_1omni__engine.html#ae7af7484fdbbf1ed3edf2f2f6b713875">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00227">227</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8da8e299fd9bfc87e308d5ad571f35eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename EdgeMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::map_reduce_edges </td>
          <td>(</td>
          <td class="paramtype">EdgeMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each edge in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> call the map function on all edges in the graph. The return values are then summed together and the final result returned. The map function should only read data and should not make any modifications. <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the edge data, we would write a function which reads in each a edge, and returns the absolute value of the data on the edge. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_edge_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = engine.map_reduce_edges&lt;<span class="keywordtype">float</span>&gt;(absolute_edge_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_edge_data()</code> function on each edge in the graph. <code>absolute_edge_data()</code> reads the value of the edge and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<h3>Signalling</h3>
<p>Another common use for the <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> function is in signalling. Since the map function is passed a context, it can be used to perform signalling of edges for execution during a later <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">engine.start()</a> call.</p>
<p>For instance, the following code will signal the source vertex of each edge. </p><div class="fragment"><div class="line">graphlab::empty signal_source(engine_type::icontext_type&amp; context,</div>
<div class="line">                              <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  context.signal(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a5d8d51b99bfbfb361d7894a6d8e67ce1">source</a>());</div>
<div class="line">  <span class="keywordflow">return</span> graphlab::empty()</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that in this case, we are not interested in a reduction operation, and thus we return a graphlab::empty object. Calling: </p><div class="fragment"><div class="line">engine.map_reduce_edges&lt;graphlab::empty&gt;(signal_source);</div>
</div><!-- fragment --><p> will run <code>signal_source()</code> on all edges, signalling all source vertices.</p>
<h3>Relations</h3>
<p>The map function has the same structure as that in <a class="el" href="classgraphlab_1_1iengine.html#adf21f70c04f6e9954e5db488cad6bff0" title="Creates an edge aggregator. Returns true on success. Returns false if an aggregator of the same name ...">add_edge_aggregator()</a> and may be reused in an aggregator. This function is also very similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">graphlab::distributed_graph::map_reduce_edges()</a> with the difference that this takes a context and thus can be used to perform signalling. Finally <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00974">974</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b3fde48e79d248db7b815a313cd92e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename VertexMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::map_reduce_vertices </td>
          <td>(</td>
          <td class="paramtype">VertexMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each vertex in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> call the map function on all vertices in the graph. The return values are then summed together and the final result returned. The map function should only read the vertex data and should not make any modifications. <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the vertex data, we would write a function which reads in each a vertex, and returns the absolute value of the data on the vertex. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_vertex_data(engine_type::icontext_type&amp; context,</div>
<div class="line">                           <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = engine.map_reduce_vertices&lt;<span class="keywordtype">float</span>&gt;(absolute_vertex_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_vertex_data()</code> function on each vertex in the graph. <code>absolute_vertex_data()</code> reads the value of the vertex and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<h3>Signalling</h3>
<p>Another common use for the <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> function is in signalling. Since the map function is passed a context, it can be used to perform signalling of vertices for execution during a later <a class="el" href="classgraphlab_1_1iengine.html#ae3c839f878408c1df7d2f2c164f7c36a">engine.start()</a> call.</p>
<p>For instance, the following code will signal all vertices with value &gt;= 1 </p><div class="fragment"><div class="line">graphlab::empty signal_vertices(engine_type::icontext_type&amp; context,</div>
<div class="line">                                <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  <span class="keywordflow">if</span> (vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() &gt;= 1) context.signal(vertex);</div>
<div class="line">  <span class="keywordflow">return</span> graphlab::empty()</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that in this case, we are not interested in a reduction operation, and thus we return a graphlab::empty object. Calling: </p><div class="fragment"><div class="line">engine.map_reduce_vertices&lt;graphlab::empty&gt;(signal_vertices);</div>
</div><!-- fragment --><p> will run <code>signal_vertices()</code> on all vertices, signalling all vertices with value &lt;= 1</p>
<h3>Relations</h3>
<p>The map function has the same structure as that in <a class="el" href="classgraphlab_1_1iengine.html#a39c802e7271358becf2cf2b2418b943a" title="Creates a vertex aggregator. Returns true on success. Returns false if an aggregator of the same name...">add_vertex_aggregator()</a> and may be reused in an aggregator. This function is also very similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">graphlab::distributed_graph::map_reduce_vertices()</a> with the difference that this takes a context and thus can be used to perform signalling. Finally <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l00876">876</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a647a3fa264ee6a9495c07dc746861dc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::num_updates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the total number of updates (calls to apply) executed since start was last invoked. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of updates </dd></dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1synchronous__engine.html#ad8debef60159f9cd584ed57f6d5bfef4">graphlab::synchronous_engine&lt; VertexProgram &gt;</a>, <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a4e6664119b88c6e6f71c37312c511b6f">graphlab::async_consistent_engine&lt; VertexProgram &gt;</a>, and <a class="el" href="classgraphlab_1_1omni__engine.html#ab88d4afac84ec7b61c3401253c57c351">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab945aad4bc982b507efc1ba55dba30d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1iengine.html#a01472800a89cef585293b074e4aa9925">vertex_id_type</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals single a vertex with an optional message. </p>
<p>This function sends a message to particular vertex which will receive that message on start. The signal function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal(0); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>Since signal is executed synchronously on all machines it should only be used to schedule a small set of vertices. The preferred method to signal a large set of vertices (e.g., all vertices that are a certain type) is to use either the vertex program init function or the aggregation framework. For example to signal all vertices that have a particular value one could write:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>bipartite_opt : </div>
<div class="line">  <span class="keyword">public</span> <a class="code" href="classgraphlab_1_1ivertex__program.html">graphlab::ivertex_program</a>&lt;graph_type, gather_type&gt; {</div>
<div class="line">  <span class="comment">// The user defined init function</span></div>
<div class="line">  <span class="keywordtype">void</span> init(<a class="code" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; context, <a class="code" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>&amp; vertex) {</div>
<div class="line">    <span class="comment">// Signal myself if I am a certain type</span></div>
<div class="line">    <span class="keywordflow">if</span>(vertex.data().on_left) context.signal(vertex);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// other vastly more interesting code</span></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>the vertex id to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to that vertex. The default message is sent if no message is provided. (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a47405eda2a7799df25d5a4d0ab4a9366">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0afe236029be943f870a77bd2a6b3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal all vertices with a particular message. </p>
<p>This function sends the same message to all vertices which will receive that message on start. The signal_all function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_all(); <span class="comment">// signal all vertices</span></div>
</div><!-- fragment --><p>and <em>not</em>:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line"><span class="keywordflow">if</span>(dc.<a class="code" href="classgraphlab_1_1distributed__control.html#a3adaa364edf63ff764aa2aabbe777f65">procid</a>() == 0) engine.signal_all(); <span class="comment">// signal vertex zero</span></div>
</div><!-- fragment --><p>The signal_all function is the most common way to send messages to the engine. For example in the pagerank application we want all vertices to be active on the first round. Therefore we would write:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;pagerank&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_all();</div>
<div class="line">engine.start();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a03414d20429d8b29e5091a6bcee137d2">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a86a7a9e2b10c0934d4c486c56c649c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::signal_vset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code><a class="el" href="classgraphlab_1_1iengine.html#afbc6e6f972d933599aed2ec415ed736c">message_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;shuffle&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal a set of vertices with a particular message. </p>
<p>This function sends the same message to a set of vertices which will receive that message on start. The signal_vset function must be invoked on all machines simultaneously. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1synchronous__engine.html">graphlab::synchronous_engine&lt;vprog&gt;</a> engine(dc, graph, opts);</div>
<div class="line">engine.signal_vset(vset); <span class="comment">// signal a subset of vertices</span></div>
</div><!-- fragment --><p><a class="el" href="classgraphlab_1_1iengine.html#a9c0afe236029be943f870a77bd2a6b3f" title="Signal all vertices with a particular message. ">signal_all()</a> is conceptually equivalent to:</p>
<div class="fragment"><div class="line">engine.signal_vset(graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vset</td><td>The set of vertices to signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>the message to send to all vertices. The default message is sent if no message is provided (See <a class="el" href="classgraphlab_1_1ivertex__program.html#a9ca29f15f893bf77e89e5ffd6f572e48">ivertex_program::message_type</a> for details about the message_type). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1omni__engine.html#a6b208b86489a26f00e225efbdf2278de">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae3c839f878408c1df7d2f2c164f7c36a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgraphlab_1_1execution__status.html#a6f1348d032193e43bc5ed04cd4ae013a">execution_status::status_enum</a> <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the engine execution. </p>
<p>Behavior details depend on the engine implementation. See the implementation documentation for specifics.</p>
<dl class="section return"><dt>Returns</dt><dd>the reason for termination </dd></dl>

<p>Implemented in <a class="el" href="classgraphlab_1_1async__consistent__engine.html#a8d23f6137fa3816023fc501060fc816d">graphlab::async_consistent_engine&lt; VertexProgram &gt;</a>, <a class="el" href="classgraphlab_1_1synchronous__engine.html#a53dc0f312b34a2f9ecf3a6790a95aeab">graphlab::synchronous_engine&lt; VertexProgram &gt;</a>, and <a class="el" href="classgraphlab_1_1omni__engine.html#a0834555546487a15af6b8b1d4f4ecf43">graphlab::omni_engine&lt; VertexProgram &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4ab681ecccc66ad8696f5a4d0103fa23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename EdgeMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::transform_edges </td>
          <td>(</td>
          <td class="paramtype">EdgeMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each edge in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> calls mapfunction on every edge in graph. The map function may make modifications to the data on the edge. <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To set each edge value to be the number of out-going edges of the target vertex, we may write the following: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_edge_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>() = edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>().<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a>: </p><div class="fragment"><div class="line">engine.transform_edges(set_edge_value);</div>
</div><!-- fragment --><p> will run the <code>set_edge_value()</code> function on each edge in the graph, setting its new value.</p>
<h3>Signalling</h3>
<p>Since the mapfunction is provided with a context, the mapfunction can also be used to perform signalling. For instance, the <code>set_edge_value</code> function above may be modified to set the value of the edge, but to also signal the target vertex.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_edge_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> edge) {</div>
<div class="line">  edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>() = edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>().<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">  context.signal(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, if the purpose of the function is to only signal without making modifications, <a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> will be more efficient as this function will additionally perform distributed synchronization of modified data.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1iengine.html#a8da8e299fd9bfc87e308d5ad571f35eb" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">graphlab::distributed_graph::transform_edges()</a> provide the same graph modification capabilities, but without a context and thus cannot perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aec2747429476d36e7d188e3d8a1e0fec">edge_type</a> as its second argument. Returns void. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01132">1132</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d9e97843604c45c08f71502b3494a7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexProgram&gt; </div>
<div class="memtemplate">
template&lt;typename VertexMapperType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1iengine.html">graphlab::iengine</a>&lt; VertexProgram &gt;::transform_vertices </td>
          <td>(</td>
          <td class="paramtype">VertexMapperType&#160;</td>
          <td class="paramname"><em>mapfunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each vertex in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> calls mapfunction on every vertex in graph. The map function may make modifications to the data on the vertex. <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> must be called by all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> <a class="code" href="classgraphlab_1_1iengine.html#a2e6e0bf905c5fb5dc5a1c2de2d1eae6d">graph_type</a>;</div>
</div><!-- fragment --><p>To set each vertex value to be the number of out-going edges, we may write the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_vertex_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() = vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a>: </p><div class="fragment"><div class="line">engine.transform_vertices(set_vertex_value);</div>
</div><!-- fragment --><p> will run the <code>set_vertex_value()</code> function on each vertex in the graph, setting its new value.</p>
<h3>Signalling</h3>
<p>Since the mapfunction is provided with a context, the mapfunction can also be used to perform signalling. For instance, the <code>set_vertex_value</code> function above may be modified to set the value of the vertex, but to also signal the vertex if it has more than 5 outgoing edges.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_vertex_value(engine_type::icontext_type&amp; context,</div>
<div class="line">                         <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> vertex) {</div>
<div class="line">  vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() = vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>() &gt; 5) context.signal(vertex);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, if the purpose of the function is to only signal without making modifications, <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> will be more efficient as this function will additionally perform distributed synchronization of modified data.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">graphlab::distributed_graph::transform_vertices()</a> provide the same graph modification capabilities, but without a context and thus cannot perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an <a class="el" href="classgraphlab_1_1iengine.html#a847cab376e9e1794a578fe3120fc91d3">icontext_type</a>&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1iengine.html#aae4f90ec999e065d477acba6e7dfd6ee">vertex_type</a> as its second argument. Returns void. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iengine_8hpp_source.html#l01055">1055</a> of file <a class="el" href="iengine_8hpp_source.html">iengine.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/engine/<a class="el" href="iengine_8hpp_source.html">iengine.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1iengine.html">iengine</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:28 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
