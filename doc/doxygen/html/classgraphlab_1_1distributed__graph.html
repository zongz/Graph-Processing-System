<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>GraphLab: Distributed Graph-Parallel API: graphlab::distributed_graph&lt; VertexData, EdgeData &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLab: Distributed Graph-Parallel API
   &#160;<span id="projectnumber">2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgraphlab_1_1distributed__graph.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgraphlab_1_1distributed__graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graphlab::distributed_graph&lt; VertexData, EdgeData &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A directed graph datastructure which is distributed across multiple machines.  
 <a href="classgraphlab_1_1distributed__graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="distributed__graph_8hpp_source.html">graphlab/graph/distributed_graph.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge represents an edge in the graph and provide access to the data associated with that edge as well as the source and target distributed::vertex_type objects.  <a href="classgraphlab_1_1distributed__graph_1_1edge__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex object which provides access to the vertex data and information about the vertex.  <a href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0c51c740320127a4a45c6e9fcb133ccd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c51c740320127a4a45c6e9fcb133ccd"></a>
typedef VertexData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">vertex_data_type</a></td></tr>
<tr class="memdesc:a0c51c740320127a4a45c6e9fcb133ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vertex data stored in the graph. <br /></td></tr>
<tr class="separator:a0c51c740320127a4a45c6e9fcb133ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b3177109bd0f7f217de016b1ce0f29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2b3177109bd0f7f217de016b1ce0f29"></a>
typedef EdgeData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#aa2b3177109bd0f7f217de016b1ce0f29">edge_data_type</a></td></tr>
<tr class="memdesc:aa2b3177109bd0f7f217de016b1ce0f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the edge data stored in the graph. <br /></td></tr>
<tr class="separator:aa2b3177109bd0f7f217de016b1ce0f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbdbcf72c23ac4c95414477360858e6"><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; bool(<a class="el" href="classgraphlab_1_1distributed__graph.html">distributed_graph</a> &amp;, const std::string &amp;, const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#afcbdbcf72c23ac4c95414477360858e6">line_parser_type</a></td></tr>
<tr class="separator:afcbdbcf72c23ac4c95414477360858e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f72ecb5f274a79053dbf7c545060e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62f72ecb5f274a79053dbf7c545060e0"></a>
typedef <a class="el" href="classgraphlab_1_1fixed__dense__bitset.html">fixed_dense_bitset</a>&lt; <a class="el" href="group__rpc.html#ga20910f3c24057e6b58de178e078d52fc">RPC_MAX_N_PROCS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mirror_type</b></td></tr>
<tr class="separator:a62f72ecb5f274a79053dbf7c545060e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adfcfb54186081e50d0291861ecb2af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8adfcfb54186081e50d0291861ecb2af"></a>
typedef graphlab::dynamic_local_graph&lt; VertexData, EdgeData &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a8adfcfb54186081e50d0291861ecb2af">local_graph_type</a></td></tr>
<tr class="memdesc:a8adfcfb54186081e50d0291861ecb2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the local graph used to store the graph data. <br /></td></tr>
<tr class="separator:a8adfcfb54186081e50d0291861ecb2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b90f90f745fa83b5efaedf593c3b70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70b90f90f745fa83b5efaedf593c3b70"></a>
typedef graphlab::local_graph&lt; VertexData, EdgeData &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>local_graph_type</b></td></tr>
<tr class="separator:a70b90f90f745fa83b5efaedf593c3b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d435668d5149523cdf7a9f4148a4dec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d435668d5149523cdf7a9f4148a4dec"></a>
typedef <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>graph_type</b></td></tr>
<tr class="separator:a5d435668d5149523cdf7a9f4148a4dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58515e2c2c461005f7397dbec0baa131"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58515e2c2c461005f7397dbec0baa131"></a>
typedef std::vector&lt; <a class="el" href="classgraphlab_1_1simple__spinlock.html">simple_spinlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lock_manager_type</b></td></tr>
<tr class="separator:a58515e2c2c461005f7397dbec0baa131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d9b4b03409643d971309df39edc12e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1d9b4b03409643d971309df39edc12e"></a>
typedef graphlab::vertex_id_type&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_id_type</b></td></tr>
<tr class="separator:ae1d9b4b03409643d971309df39edc12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec39c62187ccabcdf11dec64ed5eda73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec39c62187ccabcdf11dec64ed5eda73"></a>
typedef <a class="el" href="namespacegraphlab.html#a68c3406fbb1c330d7e61f8efff6e3349">graphlab::lvid_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lvid_type</b></td></tr>
<tr class="separator:aec39c62187ccabcdf11dec64ed5eda73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619235006455b8af885f850ac17d3d9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a619235006455b8af885f850ac17d3d9a"></a>
typedef <a class="el" href="namespacegraphlab.html#abf46e72517c3bba4cd6583b8404090b5">graphlab::edge_id_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>edge_id_type</b></td></tr>
<tr class="separator:a619235006455b8af885f850ac17d3d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf18245b5146f94b408eda08d3cc8868"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf18245b5146f94b408eda08d3cc8868"></a>
typedef bool&#160;</td><td class="memItemRight" valign="bottom"><b>edge_list_type</b></td></tr>
<tr class="separator:abf18245b5146f94b408eda08d3cc8868"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5898d7795fcf14ecac08ecd1818b424c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a5898d7795fcf14ecac08ecd1818b424c">distributed_graph</a> (<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;dc, const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;opts=<a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>())</td></tr>
<tr class="separator:a5898d7795fcf14ecac08ecd1818b424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6d777496067108a4cfaaa09c66d5d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb6d777496067108a4cfaaa09c66d5d3"></a>
lock_manager_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_lock_manager</b> ()</td></tr>
<tr class="separator:abb6d777496067108a4cfaaa09c66d5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c389e9454f2e4e4651bfb95ec4448b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2c389e9454f2e4e4651bfb95ec4448b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_dynamic</b> () const </td></tr>
<tr class="separator:aa2c389e9454f2e4e4651bfb95ec4448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02d3ec3d347f9428f3bdde3a1cb4095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#ae02d3ec3d347f9428f3bdde3a1cb4095">finalize</a> ()</td></tr>
<tr class="memdesc:ae02d3ec3d347f9428f3bdde3a1cb4095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits the graph structure. Once a graph is finalized it may no longer be modified. Must be called on all machines simultaneously.  <a href="#ae02d3ec3d347f9428f3bdde3a1cb4095">More...</a><br /></td></tr>
<tr class="separator:ae02d3ec3d347f9428f3bdde3a1cb4095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfe397fdc9b12b03558d267c2e69827"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dfe397fdc9b12b03558d267c2e69827"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a3dfe397fdc9b12b03558d267c2e69827">is_finalized</a> ()</td></tr>
<tr class="memdesc:a3dfe397fdc9b12b03558d267c2e69827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph is finalized. <br /></td></tr>
<tr class="separator:a3dfe397fdc9b12b03558d267c2e69827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cc3c87e65798a8c934159ea6c1cc9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5cc3c87e65798a8c934159ea6c1cc9c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#aa5cc3c87e65798a8c934159ea6c1cc9c">num_vertices</a> () const </td></tr>
<tr class="memdesc:aa5cc3c87e65798a8c934159ea6c1cc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices. <br /></td></tr>
<tr class="separator:aa5cc3c87e65798a8c934159ea6c1cc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85bc145e123f333af62cfb0d99688fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad85bc145e123f333af62cfb0d99688fa"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#ad85bc145e123f333af62cfb0d99688fa">num_edges</a> () const </td></tr>
<tr class="memdesc:ad85bc145e123f333af62cfb0d99688fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges. <br /></td></tr>
<tr class="separator:ad85bc145e123f333af62cfb0d99688fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354c3c532f70db9773c4d26b51f30d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a354c3c532f70db9773c4d26b51f30d5d">vertex</a> (vertex_id_type vid)</td></tr>
<tr class="memdesc:a354c3c532f70db9773c4d26b51f30d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a vertex ID to a vertex object. This function should not be used without a deep understanding of the distributed graph representation.  <a href="#a354c3c532f70db9773c4d26b51f30d5d">More...</a><br /></td></tr>
<tr class="separator:a354c3c532f70db9773c4d26b51f30d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1d26e1fadd4b2a86b374178e8df2e8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a5d1d26e1fadd4b2a86b374178e8df2e8">num_in_edges</a> (const vertex_id_type vid) const </td></tr>
<tr class="memdesc:a5d1d26e1fadd4b2a86b374178e8df2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">*/  <a href="#a5d1d26e1fadd4b2a86b374178e8df2e8">More...</a><br /></td></tr>
<tr class="separator:a5d1d26e1fadd4b2a86b374178e8df2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60daa8cf75b73c0da9b689641defea5e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a60daa8cf75b73c0da9b689641defea5e">num_out_edges</a> (const vertex_id_type vid) const </td></tr>
<tr class="memdesc:a60daa8cf75b73c0da9b689641defea5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of out edges of a given global vertex ID. This function should not be used without a deep understanding of the distributed graph representation.  <a href="#a60daa8cf75b73c0da9b689641defea5e">More...</a><br /></td></tr>
<tr class="separator:a60daa8cf75b73c0da9b689641defea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474e167cb558b7b95c6b752b629316d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a474e167cb558b7b95c6b752b629316d3">set_duplicate_vertex_strategy</a> (boost::function&lt; void(<a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">vertex_data_type</a> &amp;, const <a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">vertex_data_type</a> &amp;)&gt; combine_strategy)</td></tr>
<tr class="separator:a474e167cb558b7b95c6b752b629316d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7e380569fab60648a75d7975674020"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a3d7e380569fab60648a75d7975674020">add_vertex</a> (const vertex_id_type &amp;vid, const VertexData &amp;vdata=VertexData())</td></tr>
<tr class="memdesc:a3d7e380569fab60648a75d7975674020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vertex containing the vertex data.  <a href="#a3d7e380569fab60648a75d7975674020">More...</a><br /></td></tr>
<tr class="separator:a3d7e380569fab60648a75d7975674020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b52fb7c39c5b9ac0fe8710f48642982"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a5b52fb7c39c5b9ac0fe8710f48642982">add_edge</a> (vertex_id_type source, vertex_id_type target, const EdgeData &amp;edata=EdgeData())</td></tr>
<tr class="memdesc:a5b52fb7c39c5b9ac0fe8710f48642982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an edge connecting vertex source, and vertex target().  <a href="#a5b52fb7c39c5b9ac0fe8710f48642982">More...</a><br /></td></tr>
<tr class="separator:a5b52fb7c39c5b9ac0fe8710f48642982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc876d97650f6afa6f1e1d77ac339a8"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename MapFunctionType &gt; </td></tr>
<tr class="memitem:a1bc876d97650f6afa6f1e1d77ac339a8"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8">map_reduce_vertices</a> (MapFunctionType mapfunction, const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>())</td></tr>
<tr class="memdesc:a1bc876d97650f6afa6f1e1d77ac339a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each vertex in the graph returning the result.  <a href="#a1bc876d97650f6afa6f1e1d77ac339a8">More...</a><br /></td></tr>
<tr class="separator:a1bc876d97650f6afa6f1e1d77ac339a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965c3ffe5d94ecf60093bcd29096114a"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename MapFunctionType &gt; </td></tr>
<tr class="memitem:a965c3ffe5d94ecf60093bcd29096114a"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a">map_reduce_edges</a> (MapFunctionType mapfunction, const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>(), <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a> edir=<a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6">IN_EDGES</a>)</td></tr>
<tr class="memdesc:a965c3ffe5d94ecf60093bcd29096114a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a map-reduce operation on each edge in the graph returning the result.  <a href="#a965c3ffe5d94ecf60093bcd29096114a">More...</a><br /></td></tr>
<tr class="separator:a965c3ffe5d94ecf60093bcd29096114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2b9acc7e66592044598cf415982443"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename VertexFoldType &gt; </td></tr>
<tr class="memitem:a1b2b9acc7e66592044598cf415982443"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a1b2b9acc7e66592044598cf415982443">fold_vertices</a> (VertexFoldType foldfunction, const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>())</td></tr>
<tr class="memdesc:a1b2b9acc7e66592044598cf415982443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fold operation on each vertex in the graph returning the result.  <a href="#a1b2b9acc7e66592044598cf415982443">More...</a><br /></td></tr>
<tr class="separator:a1b2b9acc7e66592044598cf415982443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb56fb6d6df6f35056be4f4445091252"><td class="memTemplParams" colspan="2">template&lt;typename ReductionType , typename FoldFunctionType &gt; </td></tr>
<tr class="memitem:afb56fb6d6df6f35056be4f4445091252"><td class="memTemplItemLeft" align="right" valign="top">ReductionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#afb56fb6d6df6f35056be4f4445091252">fold_edges</a> (FoldFunctionType foldfunction, const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>(), <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a> edir=<a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6">IN_EDGES</a>)</td></tr>
<tr class="memdesc:afb56fb6d6df6f35056be4f4445091252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fold operation on each edge in the graph returning the result.  <a href="#afb56fb6d6df6f35056be4f4445091252">More...</a><br /></td></tr>
<tr class="separator:afb56fb6d6df6f35056be4f4445091252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847479b9df685c1aca72af4230b583c"><td class="memTemplParams" colspan="2">template&lt;typename TransformType &gt; </td></tr>
<tr class="memitem:a5847479b9df685c1aca72af4230b583c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c">transform_vertices</a> (TransformType transform_functor, const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>())</td></tr>
<tr class="memdesc:a5847479b9df685c1aca72af4230b583c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each vertex in the graph.  <a href="#a5847479b9df685c1aca72af4230b583c">More...</a><br /></td></tr>
<tr class="separator:a5847479b9df685c1aca72af4230b583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94314e73f350f673d53f1791b13f8bb3"><td class="memTemplParams" colspan="2">template&lt;typename TransformType &gt; </td></tr>
<tr class="memitem:a94314e73f350f673d53f1791b13f8bb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3">transform_edges</a> (TransformType transform_functor, const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>(), <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a> edir=<a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6">IN_EDGES</a>)</td></tr>
<tr class="memdesc:a94314e73f350f673d53f1791b13f8bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a transformation operation on each edge in the graph.  <a href="#a94314e73f350f673d53f1791b13f8bb3">More...</a><br /></td></tr>
<tr class="separator:a94314e73f350f673d53f1791b13f8bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6accee8ed600dae6548bccc63b6b3ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#ae6accee8ed600dae6548bccc63b6b3ea">clear</a> ()</td></tr>
<tr class="memdesc:ae6accee8ed600dae6548bccc63b6b3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">*/  <a href="#ae6accee8ed600dae6548bccc63b6b3ea">More...</a><br /></td></tr>
<tr class="separator:ae6accee8ed600dae6548bccc63b6b3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb88c6af14ef19ff79ab27a4bdfa34fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#adb88c6af14ef19ff79ab27a4bdfa34fb">load_binary</a> (const std::string &amp;prefix)</td></tr>
<tr class="memdesc:adb88c6af14ef19ff79ab27a4bdfa34fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a distributed graph from a native binary format previously saved with <a class="el" href="classgraphlab_1_1distributed__graph.html#a33c9507874be2ba0ebdd09df4bc9170c" title="Saves a distributed graph to a native binary format which can be loaded with load_binary(). This function must be called simultaneously on all machines. ">save_binary()</a>. This function must be called simultaneously on all machines.  <a href="#adb88c6af14ef19ff79ab27a4bdfa34fb">More...</a><br /></td></tr>
<tr class="separator:adb88c6af14ef19ff79ab27a4bdfa34fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c9507874be2ba0ebdd09df4bc9170c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a33c9507874be2ba0ebdd09df4bc9170c">save_binary</a> (const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a33c9507874be2ba0ebdd09df4bc9170c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a distributed graph to a native binary format which can be loaded with <a class="el" href="classgraphlab_1_1distributed__graph.html#adb88c6af14ef19ff79ab27a4bdfa34fb" title="Load a distributed graph from a native binary format previously saved with save_binary(). This function must be called simultaneously on all machines. ">load_binary()</a>. This function must be called simultaneously on all machines.  <a href="#a33c9507874be2ba0ebdd09df4bc9170c">More...</a><br /></td></tr>
<tr class="separator:a33c9507874be2ba0ebdd09df4bc9170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cf4aabfc130ac0fe068e661ae6c0be"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70cf4aabfc130ac0fe068e661ae6c0be"></a>
template&lt;typename Writer &gt; </td></tr>
<tr class="memitem:a70cf4aabfc130ac0fe068e661ae6c0be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a70cf4aabfc130ac0fe068e661ae6c0be">save_to_posixfs</a> (const std::string &amp;prefix, Writer writer, bool gzip=true, bool save_vertex=true, bool save_edge=true, size_t files_per_machine=4)</td></tr>
<tr class="memdesc:a70cf4aabfc130ac0fe068e661ae6c0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the graph to the filesystem using a provided Writer object. Like save() but only saves to local filesystem. <br /></td></tr>
<tr class="separator:a70cf4aabfc130ac0fe068e661ae6c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38998b09a3714e791d5a5ca958338b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="af38998b09a3714e791d5a5ca958338b1"></a>
template&lt;typename Writer &gt; </td></tr>
<tr class="memitem:af38998b09a3714e791d5a5ca958338b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#af38998b09a3714e791d5a5ca958338b1">save_to_hdfs</a> (const std::string &amp;prefix, Writer writer, bool gzip=true, bool save_vertex=true, bool save_edge=true, size_t files_per_machine=4)</td></tr>
<tr class="memdesc:af38998b09a3714e791d5a5ca958338b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the graph to HDFS using a provided Writer object. Like save() but only saves to HDFS. <br /></td></tr>
<tr class="separator:af38998b09a3714e791d5a5ca958338b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77989c47d8772cbf83a6e974721c948e"><td class="memTemplParams" colspan="2">template&lt;typename Writer &gt; </td></tr>
<tr class="memitem:a77989c47d8772cbf83a6e974721c948e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a77989c47d8772cbf83a6e974721c948e">save</a> (const std::string &amp;prefix, Writer writer, bool gzip=true, bool save_vertex=true, bool save_edge=true, size_t files_per_machine=4)</td></tr>
<tr class="memdesc:a77989c47d8772cbf83a6e974721c948e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the graph to the filesystem or to HDFS using a user provided Writer object. This function should be called on all machines simultaneously.  <a href="#a77989c47d8772cbf83a6e974721c948e">More...</a><br /></td></tr>
<tr class="separator:a77989c47d8772cbf83a6e974721c948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae048b720038f05014e0a7e55310369cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#ae048b720038f05014e0a7e55310369cd">save_format</a> (const std::string &amp;prefix, const std::string &amp;format, bool gzip=true, size_t files_per_machine=4)</td></tr>
<tr class="memdesc:ae048b720038f05014e0a7e55310369cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the graph in the specified format. This function should be called on all machines simultaneously.  <a href="#ae048b720038f05014e0a7e55310369cd">More...</a><br /></td></tr>
<tr class="separator:ae048b720038f05014e0a7e55310369cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7380ab00e8211c7886fc3d5f5727ff85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7380ab00e8211c7886fc3d5f5727ff85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a7380ab00e8211c7886fc3d5f5727ff85">load_from_posixfs</a> (std::string prefix, <a class="el" href="classgraphlab_1_1distributed__graph.html#afcbdbcf72c23ac4c95414477360858e6">line_parser_type</a> line_parser)</td></tr>
<tr class="memdesc:a7380ab00e8211c7886fc3d5f5727ff85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a graph from a collection of files in stored on the filesystem using the user defined line parser. Like load(const std::string&amp; path, line_parser_type line_parser) but only loads from the filesystem. <br /></td></tr>
<tr class="separator:a7380ab00e8211c7886fc3d5f5727ff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165317208468efa2be93a289a9b08260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a165317208468efa2be93a289a9b08260"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a165317208468efa2be93a289a9b08260">load_from_hdfs</a> (std::string prefix, <a class="el" href="classgraphlab_1_1distributed__graph.html#afcbdbcf72c23ac4c95414477360858e6">line_parser_type</a> line_parser)</td></tr>
<tr class="memdesc:a165317208468efa2be93a289a9b08260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a graph from a collection of files in stored on the HDFS using the user defined line parser. Like load(const std::string&amp; path, line_parser_type line_parser) but only loads from HDFS. <br /></td></tr>
<tr class="separator:a165317208468efa2be93a289a9b08260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35ff3509a89a9983c3ae11cae3d6a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#af35ff3509a89a9983c3ae11cae3d6a50">load</a> (std::string prefix, <a class="el" href="classgraphlab_1_1distributed__graph.html#afcbdbcf72c23ac4c95414477360858e6">line_parser_type</a> line_parser)</td></tr>
<tr class="memdesc:af35ff3509a89a9983c3ae11cae3d6a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a the graph from a given path using a user defined line parser. This function should be called on all machines simultaneously.  <a href="#af35ff3509a89a9983c3ae11cae3d6a50">More...</a><br /></td></tr>
<tr class="separator:af35ff3509a89a9983c3ae11cae3d6a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1a30804148c1a8d85efb5a08cee6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a27b1a30804148c1a8d85efb5a08cee6c">load_synthetic_powerlaw</a> (size_t nverts, bool in_degree=false, double alpha=2.1, size_t truncate=(size_t)(-1))</td></tr>
<tr class="memdesc:a27b1a30804148c1a8d85efb5a08cee6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a synthetic power law graph. Must be called on all machines simultaneously.  <a href="#a27b1a30804148c1a8d85efb5a08cee6c">More...</a><br /></td></tr>
<tr class="separator:a27b1a30804148c1a8d85efb5a08cee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca36a119fb2e1067a546bb8c61d12cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#adca36a119fb2e1067a546bb8c61d12cc">load_format</a> (const std::string &amp;path, const std::string &amp;format)</td></tr>
<tr class="memdesc:adca36a119fb2e1067a546bb8c61d12cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a graph with a standard format. Must be called on all machines simultaneously.  <a href="#adca36a119fb2e1067a546bb8c61d12cc">More...</a><br /></td></tr>
<tr class="separator:adca36a119fb2e1067a546bb8c61d12cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b86f1273043a808e0ef79c5f7214bb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b86f1273043a808e0ef79c5f7214bb3"></a>
<a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a>&#160;</td><td class="memItemRight" valign="bottom"><b>neighbors</b> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;cur, <a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a> edir)</td></tr>
<tr class="separator:a4b86f1273043a808e0ef79c5f7214bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02551e413c86c55b2b9a0881aa317575"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType &gt; </td></tr>
<tr class="memitem:a02551e413c86c55b2b9a0881aa317575"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a02551e413c86c55b2b9a0881aa317575">select</a> (FunctionType select_functor, const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>())</td></tr>
<tr class="memdesc:a02551e413c86c55b2b9a0881aa317575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vertex set from a predicate operation which is executed on each vertex.  <a href="#a02551e413c86c55b2b9a0881aa317575">More...</a><br /></td></tr>
<tr class="separator:a02551e413c86c55b2b9a0881aa317575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b30fa0cea6643f3ffb0f93260b6fcee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b30fa0cea6643f3ffb0f93260b6fcee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sync_vertex_set_master_to_mirrors</b> (<a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset)</td></tr>
<tr class="separator:a9b30fa0cea6643f3ffb0f93260b6fcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbf070070b2704fb7a322d9bf7ad42e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a5dbf070070b2704fb7a322d9bf7ad42e">vertex_set_size</a> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset)</td></tr>
<tr class="memdesc:a5dbf070070b2704fb7a322d9bf7ad42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in a vertex set.  <a href="#a5dbf070070b2704fb7a322d9bf7ad42e">More...</a><br /></td></tr>
<tr class="separator:a5dbf070070b2704fb7a322d9bf7ad42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7cd569c14fcd66b5ab12100508df16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a1c7cd569c14fcd66b5ab12100508df16">vertex_set_empty</a> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset)</td></tr>
<tr class="memdesc:a1c7cd569c14fcd66b5ab12100508df16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vertex set is empty.  <a href="#a1c7cd569c14fcd66b5ab12100508df16">More...</a><br /></td></tr>
<tr class="separator:a1c7cd569c14fcd66b5ab12100508df16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773c5a32b3c981a57846fc26938b19fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a773c5a32b3c981a57846fc26938b19fc"></a>
local_vertex_type&#160;</td><td class="memItemRight" valign="bottom"><b>l_vertex</b> (lvid_type vid)</td></tr>
<tr class="separator:a773c5a32b3c981a57846fc26938b19fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa654724bc357da27b2ad5477d461b6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa654724bc357da27b2ad5477d461b6a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_replicas</b> () const </td></tr>
<tr class="separator:aaa654724bc357da27b2ad5477d461b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca843105aee8e261e2996b27ab869f29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca843105aee8e261e2996b27ab869f29"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_local_vertices</b> () const </td></tr>
<tr class="separator:aca843105aee8e261e2996b27ab869f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3968a2f8716607c456273d14385d192"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3968a2f8716607c456273d14385d192"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_local_edges</b> () const </td></tr>
<tr class="separator:ac3968a2f8716607c456273d14385d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54332e977e504397c7a2383e099768b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54332e977e504397c7a2383e099768b3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_local_own_vertices</b> () const </td></tr>
<tr class="separator:a54332e977e504397c7a2383e099768b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcd590125ec2d7acee06e07b015267a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbcd590125ec2d7acee06e07b015267a"></a>
lvid_type&#160;</td><td class="memItemRight" valign="bottom"><b>local_vid</b> (const vertex_id_type vid) const </td></tr>
<tr class="separator:acbcd590125ec2d7acee06e07b015267a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7b6c17a1d6ca9cb3c456809fc3fee4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd7b6c17a1d6ca9cb3c456809fc3fee4"></a>
vertex_id_type&#160;</td><td class="memItemRight" valign="bottom"><b>global_vid</b> (const lvid_type lvid) const </td></tr>
<tr class="separator:abd7b6c17a1d6ca9cb3c456809fc3fee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97ecc661cd0e5addb46b3005c366a84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa97ecc661cd0e5addb46b3005c366a84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains_vertex</b> (const vertex_id_type vid) const </td></tr>
<tr class="separator:aa97ecc661cd0e5addb46b3005c366a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a066703c8b0272487a3f2b3d727da04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a066703c8b0272487a3f2b3d727da04"></a>
local_edge_list_type&#160;</td><td class="memItemRight" valign="bottom"><b>l_in_edges</b> (const lvid_type lvid)</td></tr>
<tr class="separator:a8a066703c8b0272487a3f2b3d727da04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033959a3619d073068d96aa331277abd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a033959a3619d073068d96aa331277abd"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>l_num_in_edges</b> (const lvid_type lvid) const </td></tr>
<tr class="separator:a033959a3619d073068d96aa331277abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76dddfeeec78813d890c0a40de79a4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac76dddfeeec78813d890c0a40de79a4a"></a>
local_edge_list_type&#160;</td><td class="memItemRight" valign="bottom"><b>l_out_edges</b> (const lvid_type lvid)</td></tr>
<tr class="separator:ac76dddfeeec78813d890c0a40de79a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857a8a143a0fc95413c6821fa0cf0cae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a857a8a143a0fc95413c6821fa0cf0cae"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>l_num_out_edges</b> (const lvid_type lvid) const </td></tr>
<tr class="separator:a857a8a143a0fc95413c6821fa0cf0cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099df05743b3860cd2243e4f4d8d1e03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a099df05743b3860cd2243e4f4d8d1e03"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>procid</b> () const </td></tr>
<tr class="separator:a099df05743b3860cd2243e4f4d8d1e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27dcace1d419be174bbfde2a8ea4f50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab27dcace1d419be174bbfde2a8ea4f50"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numprocs</b> () const </td></tr>
<tr class="separator:ab27dcace1d419be174bbfde2a8ea4f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b8777d82878d0047d6438bb2b3f34e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09b8777d82878d0047d6438bb2b3f34e"></a>
<a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>dc</b> ()</td></tr>
<tr class="separator:a09b8777d82878d0047d6438bb2b3f34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe080eabaa39a0a8a913c0d9bd8bcfc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe080eabaa39a0a8a913c0d9bd8bcfc0"></a>
const vertex_record &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_vertex_record</b> (vertex_id_type vid) const </td></tr>
<tr class="separator:afe080eabaa39a0a8a913c0d9bd8bcfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc48d1a6fb76457f783bbc6ad2ea6d3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc48d1a6fb76457f783bbc6ad2ea6d3d"></a>
vertex_record &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>l_get_vertex_record</b> (lvid_type lvid)</td></tr>
<tr class="separator:adc48d1a6fb76457f783bbc6ad2ea6d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa91372c80c85e62bf8bf90d3d7b5ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aa91372c80c85e62bf8bf90d3d7b5ac"></a>
const vertex_record &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>l_get_vertex_record</b> (lvid_type lvid) const </td></tr>
<tr class="separator:a6aa91372c80c85e62bf8bf90d3d7b5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd8eddf17f66ef971153314eb386c98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fd8eddf17f66ef971153314eb386c98"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_master</b> (vertex_id_type vid) const </td></tr>
<tr class="separator:a6fd8eddf17f66ef971153314eb386c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3424819bf32037dd04ce1056def2330"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3424819bf32037dd04ce1056def2330"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>master</b> (vertex_id_type vid) const </td></tr>
<tr class="separator:ab3424819bf32037dd04ce1056def2330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2135b659a018038d61bed6387179d4c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2135b659a018038d61bed6387179d4c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>l_is_master</b> (lvid_type lvid) const </td></tr>
<tr class="separator:a2135b659a018038d61bed6387179d4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3941183b1a0207c64bfa744a2933b4ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3941183b1a0207c64bfa744a2933b4ab"></a>
<a class="el" href="group__rpc.html#ga648487a0f9acffb0df08cf24804b1dcd">procid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>l_master</b> (lvid_type lvid) const </td></tr>
<tr class="separator:a3941183b1a0207c64bfa744a2933b4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978151f525bc6a5a780672b06e22b2b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a978151f525bc6a5a780672b06e22b2b8"></a>
<a class="el" href="classgraphlab_1_1distributed__graph.html#a8adfcfb54186081e50d0291861ecb2af">local_graph_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_local_graph</b> ()</td></tr>
<tr class="separator:a978151f525bc6a5a780672b06e22b2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60e34a22463528b6709091f82593564"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad60e34a22463528b6709091f82593564"></a>
const <a class="el" href="classgraphlab_1_1distributed__graph.html#a8adfcfb54186081e50d0291861ecb2af">local_graph_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_local_graph</b> () const </td></tr>
<tr class="separator:ad60e34a22463528b6709091f82593564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0fe6420a62fda92267a1e847c69e63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa0fe6420a62fda92267a1e847c69e63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronize</b> (const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;vset=<a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>())</td></tr>
<tr class="separator:aaa0fe6420a62fda92267a1e847c69e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a62ea8561fc0ef3a63e369ae195be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a6a62ea8561fc0ef3a63e369ae195be"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_rpc_obj_id</b> ()</td></tr>
<tr class="separator:a2a6a62ea8561fc0ef3a63e369ae195be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a922fd1b144760affd11a79ab5a1c43a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a922fd1b144760affd11a79ab5a1c43a8"></a>
static <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a922fd1b144760affd11a79ab5a1c43a8">empty_set</a> ()</td></tr>
<tr class="memdesc:a922fd1b144760affd11a79ab5a1c43a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns an empty set of vertices. <br /></td></tr>
<tr class="separator:a922fd1b144760affd11a79ab5a1c43a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0d354405eef16c6e3c9348d0341d7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b0d354405eef16c6e3c9348d0341d7d"></a>
static <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a> ()</td></tr>
<tr class="memdesc:a3b0d354405eef16c6e3c9348d0341d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns a full set of vertices. <br /></td></tr>
<tr class="separator:a3b0d354405eef16c6e3c9348d0341d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VertexData, typename EdgeData&gt;<br />
class graphlab::distributed_graph&lt; VertexData, EdgeData &gt;</h3>

<p>A directed graph datastructure which is distributed across multiple machines. </p>
<p>Implementation of the basic ingress functionality.</p>
<p>This class implements a distributed directed graph datastructure where vertices and edges may contain arbitrary user-defined datatypes as templatized by the VertexData and EdgeData template parameters.</p>
<h3>Initialization</h3>
<p>To declare a distributed graph you write: </p><div class="fragment"><div class="line"> <span class="keyword">typedef</span></div>
<div class="line"><a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;vdata, edata&gt;</a> graph_type;</div>
<div class="line">graph_type graph(dc, clopts);</div>
</div><!-- fragment --><p> where <code>vdata</code> is the type of data to be stored on vertices, and <code>edata</code> is the type of data to be stored on edges. The constructor must be called simultaneously on all machines. <code>dc</code> is a <a class="el" href="classgraphlab_1_1distributed__control.html" title="The distributed control object is primary means of communication between the distributed GraphLab pro...">graphlab::distributed_control</a> object that must be constructed at the start of the program, and clopts is a <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab::graphlab_options</a> object that is used to pass graph construction runtime options to the graph. See the code examples for further details.</p>
<p>Each vertex is uniquely identified by an unsigned numeric ID of the type graphlab::vertex_id_type. Vertex IDs need not be sequential. However, the ID corresponding to <code>(vertex_id_type)(-1)</code> is reserved. (This is the largest possible ID, corresponding to 0xFFFFFFFF when using 32-bit IDs).</p>
<p>Edges are not numbered, but are uniquely identified by its source-&gt;target pair. In other words, there can only be two edges between any pair of vertices, the edge going in the forward direction, and the edge going in the backward direction.</p>
<h3>Construction</h3>
<p>The distributed graph can be constructed in two different ways. The first, and the preferred method, is to construct the graph from files located on a shared filesystem (NFS mounts for instance) , or from files on HDFS (HDFS support must be compiled).</p>
<p>To construct from files, the <a class="el" href="classgraphlab_1_1distributed__graph.html#adca36a119fb2e1067a546bb8c61d12cc" title="load a graph with a standard format. Must be called on all machines simultaneously. ">load_format()</a> function provides built-in parsers to construct the graph structure from various graph file formats on disk or HDFS. Alternatively, the load() function provides generalized parsing capabilities allowing you to construct from your own defined file format. Alternatively, <a class="el" href="classgraphlab_1_1distributed__graph.html#adb88c6af14ef19ff79ab27a4bdfa34fb" title="Load a distributed graph from a native binary format previously saved with save_binary(). This function must be called simultaneously on all machines. ">load_binary()</a> may be used to perform an extremely rapid load of a graph previously saved with <a class="el" href="classgraphlab_1_1distributed__graph.html#a33c9507874be2ba0ebdd09df4bc9170c" title="Saves a distributed graph to a native binary format which can be loaded with load_binary(). This function must be called simultaneously on all machines. ">save_binary()</a>. The caveat being that the number of machines used to save the graph must match the number of machines used to load the graph.</p>
<p>The second construction strategy is to call the <a class="el" href="classgraphlab_1_1distributed__graph.html#a3d7e380569fab60648a75d7975674020" title="Creates a vertex containing the vertex data. ">add_vertex()</a> and <a class="el" href="classgraphlab_1_1distributed__graph.html#a5b52fb7c39c5b9ac0fe8710f48642982" title="Creates an edge connecting vertex source, and vertex target(). ">add_edge()</a> functions directly. These functions are parallel reentrant, and are also distributed. Each vertex and each edge should be added no more than once across all machines.</p>
<p><a class="el" href="classgraphlab_1_1distributed__graph.html#a3d7e380569fab60648a75d7975674020" title="Creates a vertex containing the vertex data. ">add_vertex()</a> calls are not strictly required since add_edge(i, j) will implicitly construct vertices i and j. The data on these vertices will be default constructed.</p>
<h3>Finalization</h3>
<p>After all vertices and edges are inserted into the graph via either load from file functions or direct calls to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3d7e380569fab60648a75d7975674020" title="Creates a vertex containing the vertex data. ">add_vertex()</a> and <a class="el" href="classgraphlab_1_1distributed__graph.html#a5b52fb7c39c5b9ac0fe8710f48642982" title="Creates an edge connecting vertex source, and vertex target(). ">add_edge()</a>, for the graph to the useable, it must be finalized.</p>
<p>This is performed by calling</p><div class="fragment"><div class="line">graph.finalize(); </div>
</div><!-- fragment --><p> on all machines simultaneously. None of the load* functions perform finalization so multiple load operations could be performed (reading from different file groups) before finalization.</p>
<p>The <a class="el" href="classgraphlab_1_1distributed__graph.html#ae02d3ec3d347f9428f3bdde3a1cb4095" title="Commits the graph structure. Once a graph is finalized it may no longer be modified. Must be called on all machines simultaneously. ">finalize()</a> operation partitions the graph and synchronizes all internal graph datastructures. After this point, all graph computation operations such as engine, map_reduce and transform operations will function.</p>
<h3>Partitioning Strategies</h3>
<p>The graph is partitioned across the machines using a "vertex separator" strategy where edges are assigned to machines, while vertices may span multiple machines. There are three partitioning strategies implemented. These can be selected by setting &ndash;graph_opts="ingress=[partition_method]" on the command line. </p><ul>
<li><code>"random"</code> The most naive and the fastest partitioner. Random places edges on machines. </li>
<li><code>"oblivious"</code> Runs at roughly half the speed of random. Machines indepedently partitions the segment of the graph it read. Improves partitioning quality and will reduce runtime memory consumption.</li>
</ul>
<ul>
<li><code>"grid"</code> Runs at rouphly the same speed of random. Randomly places edges on machines with a grid constraint. This obtains quality partition, close to oblivious, but currently only works with perfect square number of machines.</li>
</ul>
<ul>
<li><code>"pds"</code> Runs at roughly the speed of random. Randomly places edges on machines with a sparser constraint generated by perfect difference set. This obtains the highest quality partition, reducing runtime memory consumption significantly, without load-time penalty. Currently only works with p^2+p+1 number of machines (p prime).</li>
</ul>
<h3>Referencing Vertices / Edges Many GraphLab operations will pass around</h3>
<p><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html" title="Vertex object which provides access to the vertex data and information about the vertex. ">vertex_type</a> and <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html" title="The edge represents an edge in the graph and provide access to the data associated with that edge as ...">edge_type</a> objects. These objects are light-weight copyable opaque references to vertices and edges in the distributed graph. The <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html" title="Vertex object which provides access to the vertex data and information about the vertex. ">vertex_type</a> object provides capabilities such as: </p><ul>
<li><code><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#ab0938e101ef28d335ef34b0f052d0b16" title="Returns the vertex ID of the vertex. ">vertex_type::id()</a></code> Returns the ID of the vertex </li>
<li><code><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a485616c8965fcd995cb705722b6b4757" title="Returns the number of in edges of the vertex. ">vertex_type::num_in_edges()</a></code> Returns the number of in edges </li>
<li><code><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1" title="Returns the number of out edges of the vertex. ">vertex_type::num_out_edges()</a></code> Returns the number of out edges </li>
<li><code><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a0487a577a3be4f6268e5c19c48f69dbf" title="Returns a mutable reference to the data on the vertex. ">vertex_type::data()</a></code> Returns a <b>reference</b> to the data on the vertex</li>
</ul>
<p>No traversal operations are currently provided and there there is no single method to return a list of adjacent edges to the vertex.</p>
<p>The <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html" title="The edge represents an edge in the graph and provide access to the data associated with that edge as ...">edge_type</a> object has similar capabilities: </p><ul>
<li><code><a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a2723c1ed05b5c73e64908916406906c6" title="Returns a mutable reference to the data on the edge. ">edge_type::data()</a></code> Returns a <b>reference</b> to the data on the edge </li>
<li><code><a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a5d8d51b99bfbfb361d7894a6d8e67ce1" title="Returns the source vertex of the edge. This function returns a vertex_object by value and as a conseq...">edge_type::source()</a></code> Returns a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> of the source vertex </li>
<li><code><a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786" title="Returns the target vertex of the edge. ">edge_type::target()</a></code> Returns a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> of the target vertex</li>
</ul>
<p>This permits the use of <code>edge.source().data()</code> for instance, to obtain the vertex data on the source vertex.</p>
<p>See the documentation for <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> and <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a> for further details.</p>
<p>Due to the distributed nature of the graph, There is at the moment, no way to obtain a reference to arbitrary vertices or edges. The only way to obtain a reference to vertices or edges, is if one is passed to you via a callback (for instance in <a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> / <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> or in an update function). To manipulate the graph at a more fine-grained level will require a more intimate understanding of the underlying distributed graph representation.</p>
<h3>Saving the graph</h3>
<p>After computation is complete, the graph structure can be saved via <a class="el" href="classgraphlab_1_1distributed__graph.html#ae048b720038f05014e0a7e55310369cd" title="Saves the graph in the specified format. This function should be called on all machines simultaneousl...">save_format()</a> which provides built-in writers to write various graph formats to disk or HDFS. Alternatively, save() provides generalized writing capabilities allowing you to write your own graph output to disk or HDFS.</p>
<h3>Distributed Representation</h3>
<p>The graph is partitioned over machines using vertex separators. In other words, each edge is assigned to a unique machine while vertices are allowed to span multiple machines.</p>
<p>The image below demonstrates the procedure. The example graph on the left is to be separated among 4 machines where the cuts are denoted by the dotted red lines. After partitioning, (the image on the right), each vertex along the cut is now separated among multiple machines. For instance, the central vertex spans 4 different machines.</p>
<div class="image">
<img src="partition_fig.gif" alt="partition_fig.gif"/>
</div>
<p>Each vertex which span multiple machines, has a <b>master</b> machine (a black vertex), and all other instances of the vertex are called <b>mirrors</b>. For instance, we observe that the central vertex spans 4 machines, where machine 3 holds the <b>master</b> copy, while all remaining machines hold <b>mirrored</b> copies.</p>
<p>This concept of vertex separators allow us to easily manage large power-law graphs where vertices may have extremely high degrees, since the adjacency information for even the high degree vertices can be separated across multiple machines.</p>
<h3>Internal Representation</h3>
<dl class="section warning"><dt>Warning</dt><dd>This is only useful if you plan to make use of the graph in ways which exceed the provided abstractions.</dd></dl>
<p>Each machine maintains its local section of the graph in a graphlab::local_graph object. The local_graph object assigns each vertex a sequential vertex ID called the local vertex ID. A hash table is used to provide a mapping between the local vertex IDs and their corresponding global vertex IDs. Additionally, each local vertex is associated with a vertex_record which provides information about global ID of the vertex, the machine which holds the master instance of the vertex, as well as a list of all machines holding a mirror of the vertex.</p>
<p>To support traversal of the local graph, two additional types, the local_vertex_type and the local_edge_type is provided which provide references to vertices and edges on the local graph. These behave similarly to the <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> and <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a> types and have similar functionality. However, since these reference the local graph, there is substantially more flexility. In particular, the function l_vertex() may be used to obtain a reference to a local vertex from a local vertex ID. Also unlike the <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> , the local_vertex_type support traversal operations such as returning a list of all in_edges (local_vertex_type::in_edges()). However, the list only contains the edges which are local to the current machine. See local_vertex_type and local_edge_type for more details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexData</td><td>Type of data stored on vertices. Must be Copyable, Default Constructable, Copy Constructable and <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeData</td><td>Type of data stored on edges. Must be Copyable, Default Constructable, Copy Constructable and <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00304">304</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="afcbdbcf72c23ac4c95414477360858e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;bool(<a class="el" href="classgraphlab_1_1distributed__graph.html">distributed_graph</a>&amp;, const std::string&amp;, const std::string&amp;)&gt; <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::<a class="el" href="classgraphlab_1_1distributed__graph.html#afcbdbcf72c23ac4c95414477360858e6">line_parser_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The line parse is any function (or functor) that has the form:</p>
<p><code> bool line_parser(<a class="el" href="classgraphlab_1_1distributed__graph.html" title="A directed graph datastructure which is distributed across multiple machines. ">distributed_graph</a>&amp; graph, const std::string&amp; filename, const std::string&amp; textline); </code></p>
<p>the line parser returns true if the line is parsed successfully and calls graph.add_vertex(...) or graph.add_edge(...)</p>
<p>See <a class="el" href="classgraphlab_1_1distributed__graph.html#af35ff3509a89a9983c3ae11cae3d6a50">load()</a> for details. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00376">376</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5898d7795fcf14ecac08ecd1818b424c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::<a class="el" href="classgraphlab_1_1distributed__graph.html">distributed_graph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1distributed__control.html">distributed_control</a> &amp;&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a distributed graph. All machines must call this constructor simultaneously.</p>
<p>Value graph options are: </p><ul>
<li><code>ingress</code> The graph partitioning method to use. May be "random" "grid" or "pds". The methods have roughly the same runtime complexity, but the increasing partition qaulity. "grid" requires number of machine P be able to layout as a n*m = P grid with ( |m-n| &lt;= 2). "pds" uses requires P = p^2+p+1 where p is a prime number.</li>
</ul>
<ul>
<li><code>userecent</code> An optimization that can decrease memory utilization of oblivious and batch quite significantly (especially when there are a large number of machines) at a small partitioning penalty. Defaults to 0. Set to 1 to enable. </li>
<li><code>bufsize</code> The batch size used by the batch ingress method. Defaults to 50,000. Increasing this number will decrease partitioning time with a penalty to partitioning quality.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dc</td><td>Distributed controller to associate with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>A <a class="el" href="classgraphlab_1_1graphlab__options.html">graphlab::graphlab_options</a> object specifying engine parameters. This is typically constructed using <a class="el" href="classgraphlab_1_1command__line__options.html">graphlab::command_line_options</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00612">612</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5b52fb7c39c5b9ac0fe8710f48642982"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::add_edge </td>
          <td>(</td>
          <td class="paramtype">vertex_id_type&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vertex_id_type&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EdgeData &amp;&#160;</td>
          <td class="paramname"><em>edata</em> = <code>EdgeData()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an edge connecting vertex source, and vertex target(). </p>
<p>Creates a edge connecting two vertex IDs.</p>
<p>This function is parallel and distributed. i.e. It does not matter which machine, or which thread on which machines calls <a class="el" href="classgraphlab_1_1distributed__graph.html#a5b52fb7c39c5b9ac0fe8710f48642982" title="Creates an edge connecting vertex source, and vertex target(). ">add_edge()</a> for a particular ID.</p>
<p>However, each edge direction may only be added exactly once. i.e. if edge 5-&gt;6 is added already, no other calls to add edge 5-&gt;6 should be made.</p>
<p>Returns true on success. Returns false if it is a self-edge, or if we are trying to create a vertex with ID (vertex_id_type)(-1). </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00851">851</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d7e380569fab60648a75d7975674020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::add_vertex </td>
          <td>(</td>
          <td class="paramtype">const vertex_id_type &amp;&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexData &amp;&#160;</td>
          <td class="paramname"><em>vdata</em> = <code>VertexData()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vertex containing the vertex data. </p>
<p>Creates a vertex with a particular vertex ID and containing a particular vertex data. Vertex IDs need not be sequential, and may arbitrarily span the unsigned integer range of vertex_id_type with the exception of (vertex_id_type)(-1), or corresponding to 0xFFFFFFFF on 32-bit vertex IDs.</p>
<p>This function is parallel and distributed. i.e. It does not matter which machine, or which thread on which machines calls <a class="el" href="classgraphlab_1_1distributed__graph.html#a3d7e380569fab60648a75d7975674020" title="Creates a vertex containing the vertex data. ">add_vertex()</a> for a particular ID.</p>
<p>However, each vertex may only be added exactly once.</p>
<p>Returns true if successful, returns false if a vertex with id (-1) was added. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00810">810</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6accee8ed600dae6548bccc63b6b3ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>*/ </p>
<p>Clears and resets the graph, releasing all memory used. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01679">1679</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae02d3ec3d347f9428f3bdde3a1cb4095"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commits the graph structure. Once a graph is finalized it may no longer be modified. Must be called on all machines simultaneously. </p>
<p>Finalize is used to complete graph ingress by resolving vertex ownship and completing local data structures. Once a graph is finalized its structure may not be modified. Repeated calls to <a class="el" href="classgraphlab_1_1distributed__graph.html#ae02d3ec3d347f9428f3bdde3a1cb4095" title="Commits the graph structure. Once a graph is finalized it may no longer be modified. Must be called on all machines simultaneously. ">finalize()</a> do nothing. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00697">697</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb56fb6d6df6f35056be4f4445091252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename FoldFunctionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::fold_edges </td>
          <td>(</td>
          <td class="paramtype">FoldFunctionType&#160;</td>
          <td class="paramname"><em>foldfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em> = <code><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a>&#160;</td>
          <td class="paramname"><em>edir</em> = <code><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6">IN_EDGES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a fold operation on each edge in the graph returning the result. </p>
<p>Given a fold function, <a class="el" href="classgraphlab_1_1distributed__graph.html#afb56fb6d6df6f35056be4f4445091252" title="Performs a fold operation on each edge in the graph returning the result. ">fold_edges()</a> call the fold function on all edges in the graph passing an aggregator. The return values are then summed together across machines and final result returned. The fold function should only read data and should not make any modifications. <a class="el" href="classgraphlab_1_1distributed__graph.html#afb56fb6d6df6f35056be4f4445091252" title="Performs a fold operation on each edge in the graph returning the result. ">fold_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> graph_type;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the edge data, we would write a function which reads in each a edge, and returns the absolute value of the data on the edge. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> absolute_edge_data(<span class="keyword">const</span> <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&amp; edge, <span class="keywordtype">float</span>&amp; acc) {</div>
<div class="line">  acc += std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = graph.fold_edges&lt;<span class="keywordtype">float</span>&gt;(absolute_edge_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_edge_data()</code> function on each edge in the graph. <code>absolute_edge_data()</code> reads the value of the edge and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the foldfunction.</p>
<p>The two optional arguments vset and edir can be used to restrict the set of edges which are map-reduced over.</p>
<h3>Relations</h3>
<p>This function similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">graphlab::distributed_graph::map_reduce_edges()</a> with the difference that this uses a fold and is hence more efficient for large aggregation objects. Finally <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeFoldType</td><td>The type of the Fold function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold</td><td>function The map function to use. Must take a <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a> as its first argument, and a reference to a ReductionType in its second argument. </td></tr>
    <tr><td class="paramname">vset</td><td>A set of vertices. Combines with edir to identify the set of edges. For instance, if edir == IN_EDGES, map_reduce_edges will map over all in edges of the vertices in vset. Optional. Defaults to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d" title="Retuns a full set of vertices. ">complete_set()</a>. </td></tr>
    <tr><td class="paramname">edir</td><td>An edge direction. Combines with vset to identify the set of edges to map over. For instance, if edir == IN_EDGES, map_reduce_edges will map over all in edges of the vertices in vset. Optional. Defaults to IN_EDGES. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01352">1352</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b2b9acc7e66592044598cf415982443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename VertexFoldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::fold_vertices </td>
          <td>(</td>
          <td class="paramtype">VertexFoldType&#160;</td>
          <td class="paramname"><em>foldfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em> = <code><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a fold operation on each vertex in the graph returning the result. </p>
<p>Given a fold function, <a class="el" href="classgraphlab_1_1distributed__graph.html#a1b2b9acc7e66592044598cf415982443" title="Performs a fold operation on each vertex in the graph returning the result. ">fold_vertices()</a> call the fold function on all vertices in the graph, passing around a aggregator variable. The return values are then summed together across machines using the combiner function and the final result returned. The fold function should only read the vertex data and should not make any modifications. <a class="el" href="classgraphlab_1_1distributed__graph.html#a1b2b9acc7e66592044598cf415982443" title="Performs a fold operation on each vertex in the graph returning the result. ">fold_vertices()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> graph_type;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the vertex data, we would write a function which reads in each a vertex, and returns the absolute value of the data on the vertex. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> absolute_vertex_data(<span class="keyword">const</span> <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&amp; vertex, <span class="keywordtype">float</span>&amp; total) {</div>
<div class="line">  total += std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = graph.fold_vertices&lt;<span class="keywordtype">float</span>&gt;(absolute_vertex_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_vertex_data()</code> function on each vertex in the graph. <code>absolute_vertex_data()</code> reads the value of the vertex and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the fold function.</p>
<p>The optional argument vset can be used to restrict he set of vertices map-reduced over.</p>
<p>Unlike map_reduce_vertices, this function exposes to a certain extent, the internals of the parallelism structure since the fold is used within a thread, but across threads/machines operator+= is used. The behavior of the foldfunction, or the behavior of the return type should not make assumptions on the undocumented behavior of this function (such as when the fold is used, and when += is used).</p>
<h3>Relations</h3>
<p>This function is similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> with the difference that this uses a fold and is hence more efficient for large aggregation objects. <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexFoldType</td><td>The type of the fold function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foldfunction</td><td>The fold function to use. Must take a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a>, or a reference to a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> as its first argument, and a reference to a ReductionType in its second argument. </td></tr>
    <tr><td class="paramname">vset</td><td>The set of vertices to fold reduce over. Optional. Defaults to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d" title="Retuns a full set of vertices. ">complete_set()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01234">1234</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af35ff3509a89a9983c3ae11cae3d6a50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgraphlab_1_1distributed__graph.html#afcbdbcf72c23ac4c95414477360858e6">line_parser_type</a>&#160;</td>
          <td class="paramname"><em>line_parser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a the graph from a given path using a user defined line parser. This function should be called on all machines simultaneously. </p>
<p>This functions loads all files in the filesystem or on HDFS matching the pattern "[prefix]*".</p>
<p>Examples:</p>
<p><b> prefix = "webgraph.txt" </b></p>
<p>will load the file webgraph.txt if such a file exists. It will also load all files in the current directory which begins with "webgraph.txt". For instance, webgraph.txt.0, webgraph.txt.1, etc.</p>
<p><b>prefix = "graph/data"</b></p>
<p>will load all files in the "graph" directory which begin with "data"</p>
<p><b> prefix = "hdfs:///hdfs_server/graph/data" </b></p>
<p>will load all files from the HDFS server in the "/graph/" directory which begin with "data".</p>
<p>If files have the ".gz" suffix, it is automatically decompressed.</p>
<p>The line_parser is a user defined function matching the following prototype:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> parser(graph_type&amp; graph,</div>
<div class="line">            <span class="keyword">const</span> std::string&amp; filename,</div>
<div class="line">            <span class="keyword">const</span> std::string&amp; line);</div>
</div><!-- fragment --><p>The <a class="el" href="classgraphlab_1_1distributed__graph.html#af35ff3509a89a9983c3ae11cae3d6a50" title="Load a the graph from a given path using a user defined line parser. This function should be called o...">load()</a> function will call the parser one line at a time, and the paser function should process the line and call add_vertex / add_edge functions in the graph. It should return true on success, and false on failure. Since the parsing may be parallelized, the parser should treat each line independently and not depend on a sequential pass through a file.</p>
<p>For instance, if the graph is in a simple edge list format, a parser could be: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> edge_list_parser(graph_type&amp; graph,</div>
<div class="line">                      <span class="keyword">const</span> std::string&amp; filename,</div>
<div class="line">                      <span class="keyword">const</span> std::string&amp; line) {</div>
<div class="line">  <span class="keywordflow">if</span> (line.empty()) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  vertex_id_type source, target;</div>
<div class="line">  <span class="keywordflow">if</span> (sscanf(line.c_str(), <span class="stringliteral">&quot;%u %u&quot;</span>, source, target) &lt; 2) {</div>
<div class="line">    <span class="comment">// parsed less than 2 objects, failure.</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a5b52fb7c39c5b9ac0fe8710f48642982">add_edge</a>(source, target);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Note that this is not an example a reliable parser since sscanf may break if the size of vertex_id_type changes</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>The file prefix to read from. All files matching the pattern "[prefix]*" are loaded. If prefix begins with "hdfs://" the files are read from hdfs. </td></tr>
    <tr><td class="paramname">line_parser</td><td>A user defined parsing function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02333">2333</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb88c6af14ef19ff79ab27a4bdfa34fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::load_binary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a distributed graph from a native binary format previously saved with <a class="el" href="classgraphlab_1_1distributed__graph.html#a33c9507874be2ba0ebdd09df4bc9170c" title="Saves a distributed graph to a native binary format which can be loaded with load_binary(). This function must be called simultaneously on all machines. ">save_binary()</a>. This function must be called simultaneously on all machines. </p>
<p>This function loads a sequence of files numbered </p><ul>
<li>[prefix].0.gz </li>
<li>[prefix].1.gz </li>
<li>[prefix].2.gz </li>
<li>etc.</li>
</ul>
<p>These files must be previously saved using <a class="el" href="classgraphlab_1_1distributed__graph.html#a33c9507874be2ba0ebdd09df4bc9170c" title="Saves a distributed graph to a native binary format which can be loaded with load_binary(). This function must be called simultaneously on all machines. ">save_binary()</a>, and must be saved <b>using the same number of machines</b>. This function uses the graphlab serialization system, so the user must ensure that the vertex data and edge data serialization formats have not changed since the graph was saved.</p>
<p>A graph loaded using <a class="el" href="classgraphlab_1_1distributed__graph.html#adb88c6af14ef19ff79ab27a4bdfa34fb" title="Load a distributed graph from a native binary format previously saved with save_binary(). This function must be called simultaneously on all machines. ">load_binary()</a> is already finalized and structure modifications are not permitted after loading.</p>
<p>Return true on success and false on failure if the file cannot be loaded. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01711">1711</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adca36a119fb2e1067a546bb8c61d12cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::load_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>load a graph with a standard format. Must be called on all machines simultaneously. </p>
<p>The supported graph formats are described in <a class="el" href="graph_formats.html">Graph File Formats</a>. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02412">2412</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27b1a30804148c1a8d85efb5a08cee6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::load_synthetic_powerlaw </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_degree</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>2.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>truncate</em> = <code>(size_t)(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a synthetic power law graph. Must be called on all machines simultaneously. </p>
<p>This function constructs a synthetic out-degree power law of "nverts" vertices with a particular alpha parameter. In other words, the probability that a vertex has out-degree <img class="formulaInl" alt="$d$" src="form_0.png"/>, is given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(d) \propto d^{-\alpha} \]" src="form_1.png"/>
</p>
<p>By default, the out-degree distribution of each vertex will have power-law distribution, but the in-degrees will be nearly uniform. This can be reversed by setting the second argument "in_degree" to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nverts</td><td>Number of vertices to generate </td></tr>
    <tr><td class="paramname">in_degree</td><td>If set to true, the graph will have power-law in-degree. Defaults to false. </td></tr>
    <tr><td class="paramname">alpha</td><td>The alpha parameter in the power law distribution. Defaults to 2.1 </td></tr>
    <tr><td class="paramname">truncate</td><td>Limits the maximum degree of any vertex. (thus generating a truncated power-law distribution). Necessary for large number of vertices (hundreds of millions) since this function allocates a PDF vector of "nverts" to sample from. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02371">2371</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a965c3ffe5d94ecf60093bcd29096114a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename MapFunctionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::map_reduce_edges </td>
          <td>(</td>
          <td class="paramtype">MapFunctionType&#160;</td>
          <td class="paramname"><em>mapfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em> = <code><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a>&#160;</td>
          <td class="paramname"><em>edir</em> = <code><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6">IN_EDGES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each edge in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> call the map function on all edges in the graph. The return values are then summed together and the final result returned. The map function should only read data and should not make any modifications. <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> graph_type;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the edge data, we would write a function which reads in each a edge, and returns the absolute value of the data on the edge. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_edge_datac(<span class="keyword">const</span> <a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&amp; edge) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a">map_reduce_edges</a>&lt;<span class="keywordtype">float</span>&gt;(absolute_edge_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_edge_data()</code> function on each edge in the graph. <code>absolute_edge_data()</code> reads the value of the edge and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<p>The two optional arguments vset and edir can be used to restrict the set of edges which are map-reduced over.</p>
<h3>Relations</h3>
<p>This function similar to <a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">graphlab::distributed_graph::map_reduce_edges()</a> with the difference that this does not take a context and thus cannot influence engine signalling. Finally <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take a <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a> as its only argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramname">vset</td><td>A set of vertices. Combines with edir to identify the set of edges. For instance, if edir == IN_EDGES, map_reduce_edges will map over all in edges of the vertices in vset. Optional. Defaults to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d" title="Retuns a full set of vertices. ">complete_set()</a>. </td></tr>
    <tr><td class="paramname">edir</td><td>An edge direction. Combines with vset to identify the set of edges to map over. For instance, if edir == IN_EDGES, map_reduce_edges will map over all in edges of the vertices in vset. Optional. Defaults to IN_EDGES. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01085">1085</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1bc876d97650f6afa6f1e1d77ac339a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename ReductionType , typename MapFunctionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReductionType <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::map_reduce_vertices </td>
          <td>(</td>
          <td class="paramtype">MapFunctionType&#160;</td>
          <td class="paramname"><em>mapfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em> = <code><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a map-reduce operation on each vertex in the graph returning the result. </p>
<p>Given a map function, <a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> call the map function on all vertices in the graph. The return values are then summed together and the final result returned. The map function should only read the vertex data and should not make any modifications. <a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has float vertex data, and float edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;float, float&gt;</a> graph_type;</div>
</div><!-- fragment --><p>To compute an absolute sum over all the vertex data, we would write a function which reads in each a vertex, and returns the absolute value of the data on the vertex. </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> absolute_vertex_data(<span class="keyword">const</span> <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&amp; vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> std::fabs(vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p> After which calling: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8">map_reduce_vertices</a>&lt;<span class="keywordtype">float</span>&gt;(absolute_vertex_data);</div>
</div><!-- fragment --><p> will call the <code>absolute_vertex_data()</code> function on each vertex in the graph. <code>absolute_vertex_data()</code> reads the value of the vertex and returns the absolute result. This return values are then summed together and returned. All machines see the same result.</p>
<p>The template argument <code>&lt;float&gt;</code> is needed to inform the compiler regarding the return type of the mapfunction.</p>
<p>The optional argument vset can be used to restrict he set of vertices map-reduced over.</p>
<h3>Relations</h3>
<p>This function is similar to <a class="el" href="classgraphlab_1_1iengine.html#a1b3fde48e79d248db7b815a313cd92e2" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">graphlab::iengine::map_reduce_vertices()</a> with the difference that this does not take a context and thus cannot influence engine signalling. <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> can be used to perform a similar but may also make modifications to graph data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReductionType</td><td>The output of the map function. Must have operator+= defined, and must be <a class="el" href="serialization.html#sec_serializable">Serializable</a>. </td></tr>
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a>, or a reference to a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> as its only argument. Returns a ReductionType which must be summable and <a class="el" href="serialization.html#sec_serializable">Serializable</a> . </td></tr>
    <tr><td class="paramname">vset</td><td>The set of vertices to map reduce over. Optional. Defaults to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d" title="Retuns a full set of vertices. ">complete_set()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00958">958</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d1d26e1fadd4b2a86b374178e8df2e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::num_in_edges </td>
          <td>(</td>
          <td class="paramtype">const vertex_id_type&#160;</td>
          <td class="paramname"><em>vid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>*/ </p>
<p>Returns the number of in edges of a given global vertex ID. This function should not be used without a deep understanding of the distributed graph representation.</p>
<p>Returns the number of in edges of a given vertex ID. Equivalent to vertex(vid).<a class="el" href="classgraphlab_1_1distributed__graph.html#a5d1d26e1fadd4b2a86b374178e8df2e8" title="*/ ">num_in_edges()</a>. The global vertex ID must exist on this machine or assertion failures will be produced. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00762">762</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60daa8cf75b73c0da9b689641defea5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::num_out_edges </td>
          <td>(</td>
          <td class="paramtype">const vertex_id_type&#160;</td>
          <td class="paramname"><em>vid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of out edges of a given global vertex ID. This function should not be used without a deep understanding of the distributed graph representation. </p>
<p>Returns the number of out edges of a given vertex ID. Equivalent to vertex(vid).<a class="el" href="classgraphlab_1_1distributed__graph.html#a60daa8cf75b73c0da9b689641defea5e" title="Returns the number of out edges of a given global vertex ID. This function should not be used without...">num_out_edges()</a>. The global vertex ID must exist on this machine or assertion failures will be produced. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00776">776</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77989c47d8772cbf83a6e974721c948e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename Writer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Writer&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gzip</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_vertex</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_edge</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>files_per_machine</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the graph to the filesystem or to HDFS using a user provided Writer object. This function should be called on all machines simultaneously. </p>
<p>This function saves the current graph to disk using a user provided Writer object. The writer object must implement two functions: </p><div class="fragment"><div class="line">std::string Writer::save_vertex(<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a> v);</div>
<div class="line">std::string Writer::save_edge(<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a> e);</div>
</div><!-- fragment --><p>The <code>save_vertex()</code> function will be called on each vertex on the graph, and the output of the function is written to file. Similarly, the <code>save_edge()</code> function is called on each edge in the graph and the output written to file.</p>
<p>For instance, a simple Writer object which saves a file containing a list of edges will be: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>edge_list_writer {</div>
<div class="line">  std::string save_vertex(vertex_type) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>; }</div>
<div class="line">  std::string save_edge(edge_type e) {</div>
<div class="line">    <span class="keywordtype">char</span> c[128];</div>
<div class="line">    sprintf(c, <span class="stringliteral">&quot;%u\t%u\n&quot;</span>, e.source().id(), e.target().id());</div>
<div class="line">    <span class="keywordflow">return</span> c;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The save_edge() function is called on each edge in the graph. It then constructs a string containing "[source] \\t [target] \\n" and returns the string.</p>
<p>This can also be used to data in human readable format. For instance, if the vertex data type is a floating point number (say a PageRank value), to save a list of vertices and their corresponding PageRanks, the following writer could be implemented: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>pagerank_writer {</div>
<div class="line">  std::string save_vertex(vertex_type v) {</div>
<div class="line">    <span class="keywordtype">char</span> c[128];</div>
<div class="line">    sprintf(c, <span class="stringliteral">&quot;%u\t%f\n&quot;</span>, v.id(), v.data());</div>
<div class="line">    <span class="keywordflow">return</span> c;</div>
<div class="line">  }</div>
<div class="line">  std::string save_edge(edge_type) {}</div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Note that these is not an example a reliable parser since sprintf may break if the size of vertex_id_type changes</dd></dl>
<p>The output files will be written in </p><ul>
<li>[prefix]_1_of_16.gz </li>
<li>[prefix]_2_of_16.gz </li>
<li>[prefix].3_of_16.gz </li>
<li>etc.</li>
</ul>
<p>To accelerate the saving process, multiple files are be written per machine in parallel. If the gzip option is not set, the ".gz" suffix is not added.</p>
<p>For instance, if there are 4 machines, running: </p><div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1distributed__graph.html#a77989c47d8772cbf83a6e974721c948e">save</a>(<span class="stringliteral">&quot;test_graph&quot;</span>, pagerank_writer);</div>
</div><!-- fragment --><p> Will create the files </p><ul>
<li>test_graph_1_of_16.gz </li>
<li>test_graph_2_of_16.gz </li>
<li>... </li>
<li>test_graph_16_of_16.gz</li>
</ul>
<p>If HDFS support is compiled in, this function can save to HDFS by adding "hdfs://" to the prefix.</p>
<p>For instance, if there are 4 machines, running: </p><div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1distributed__graph.html#a77989c47d8772cbf83a6e974721c948e">save</a>(<span class="stringliteral">&quot;hdfs:///hdfs_server/data/test_graph&quot;</span>, pagerank_writer);</div>
</div><!-- fragment --><p> Will create on the HDFS server, the files </p><ul>
<li>/data/test_graph_1_of_16.gz </li>
<li>/data/test_graph_2_of_16.gz </li>
<li>... </li>
<li>/data/test_graph_16_of_16.gz</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Writer</td><td>The writer object type. This is generally inferred by the compiler and need not be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>The file prefix to save the output graph files. The output files will be numbered [prefix].0 , [prefix].1 , etc. If prefix begins with "hdfs://", the output is written to HDFS </td></tr>
    <tr><td class="paramname">writer</td><td>The writer object to use. </td></tr>
    <tr><td class="paramname">gzip</td><td>If gzip compression should be used. If set, all files will be appended with the .gz suffix. Defaults to true. </td></tr>
    <tr><td class="paramname">save_vertex</td><td>If vertices should be saved. Defaults to true. </td></tr>
    <tr><td class="paramname">save_edges</td><td>If edges should be saved. Defaults to true. </td></tr>
    <tr><td class="paramname">files_per_machine</td><td>Number of files to write simultaneously in parallel per machine. Defaults to 4. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02082">2082</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33c9507874be2ba0ebdd09df4bc9170c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::save_binary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves a distributed graph to a native binary format which can be loaded with <a class="el" href="classgraphlab_1_1distributed__graph.html#adb88c6af14ef19ff79ab27a4bdfa34fb" title="Load a distributed graph from a native binary format previously saved with save_binary(). This function must be called simultaneously on all machines. ">load_binary()</a>. This function must be called simultaneously on all machines. </p>
<p>This function saves a sequence of files numbered </p><ul>
<li>[prefix].0.gz </li>
<li>[prefix].1.gz </li>
<li>[prefix].2.gz </li>
<li>etc.</li>
</ul>
<p>This files can be loaded with <a class="el" href="classgraphlab_1_1distributed__graph.html#adb88c6af14ef19ff79ab27a4bdfa34fb" title="Load a distributed graph from a native binary format previously saved with save_binary(). This function must be called simultaneously on all machines. ">load_binary()</a> using the <b> same number of machines</b>. This function uses the graphlab serialization system, so the vertex data and edge data serialization formats must not change between the use of <a class="el" href="classgraphlab_1_1distributed__graph.html#a33c9507874be2ba0ebdd09df4bc9170c" title="Saves a distributed graph to a native binary format which can be loaded with load_binary(). This function must be called simultaneously on all machines. ">save_binary()</a> and <a class="el" href="classgraphlab_1_1distributed__graph.html#adb88c6af14ef19ff79ab27a4bdfa34fb" title="Load a distributed graph from a native binary format previously saved with save_binary(). This function must be called simultaneously on all machines. ">load_binary()</a>.</p>
<p>If the graph is not alreasy finalized before <a class="el" href="classgraphlab_1_1distributed__graph.html#a33c9507874be2ba0ebdd09df4bc9170c" title="Saves a distributed graph to a native binary format which can be loaded with load_binary(). This function must be called simultaneously on all machines. ">save_binary()</a> is called, this function will finalize the graph.</p>
<p>Returns true on success, and false if the graph cannot be loaded from the specified file. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01776">1776</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae048b720038f05014e0a7e55310369cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::save_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gzip</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>files_per_machine</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the graph in the specified format. This function should be called on all machines simultaneously. </p>
<p>The output files will be written in </p><ul>
<li>[prefix].0.gz </li>
<li>[prefix].1.gz </li>
<li>[prefix].2.gz </li>
<li>etc.</li>
</ul>
<p>To accelerate the saving process, multiple files are be written per machine in parallel. If the gzip option is not set, the ".gz" suffix is not added.</p>
<p>For instance, if there are 4 machines, running: </p><div class="fragment"><div class="line"><a class="code" href="classgraphlab_1_1distributed__graph.html#ae048b720038f05014e0a7e55310369cd">save_format</a>(<span class="stringliteral">&quot;test_graph&quot;</span>, <span class="stringliteral">&quot;tsv&quot;</span>);</div>
</div><!-- fragment --><p> Will create the files </p><ul>
<li>test_graph_0.gz </li>
<li>test_graph_1.gz </li>
<li>... </li>
<li>test_graph_15.gz</li>
</ul>
<p>The supported formats are described in <a class="el" href="graph_formats.html">Graph File Formats</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>The file prefix to save the output graph files. The output files will be numbered [prefix].0 , [prefix].1 , etc. If prefix begins with "hdfs://", the output is written to HDFS. </td></tr>
    <tr><td class="paramname">format</td><td>The file format to save in. Either "tsv", "snap", "graphjrl" or "bin". </td></tr>
    <tr><td class="paramname">gzip</td><td>If gzip compression should be used. If set, all files will be appended with the .gz suffix. Defaults to true. Ignored if format == "bin". </td></tr>
    <tr><td class="paramname">files_per_machine</td><td>Number of files to write simultaneously in parallel per machine. Defaults to 4. Ignored if format == "bin". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02133">2133</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02551e413c86c55b2b9a0881aa317575"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename FunctionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::select </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>select_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em> = <code><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a vertex set from a predicate operation which is executed on each vertex. </p>
<p>This function selects a subset of vertices on which the predicate evaluates to true. For instance if vertices contain an integer, the following code will construct a set of vertices containing only vertices with data which are a multiple of 2.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_multiple_of_2(<span class="keyword">const</span> <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&amp; vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() % 2 == 0;</div>
<div class="line">}</div>
<div class="line">vertex_set even_vertices = graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a02551e413c86c55b2b9a0881aa317575">select</a>(is_multiple_of_2);</div>
</div><!-- fragment --><p><a class="el" href="classgraphlab_1_1distributed__graph.html#a02551e413c86c55b2b9a0881aa317575" title="Constructs a vertex set from a predicate operation which is executed on each vertex. ">select()</a> also takes a second argument which restricts the set of vertices queried. For instance, </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_multiple_of_3(<span class="keyword">const</span> <a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&amp; vertex) {</div>
<div class="line">  <span class="keywordflow">return</span> vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() % 3 == 0;</div>
<div class="line">}</div>
<div class="line">vertex_set div_6_vertices = graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a02551e413c86c55b2b9a0881aa317575">select</a>(is_multiple_of_3, even_vertices);</div>
</div><!-- fragment --><p> will select from the set of even vertices, all vertices which are also divisible by 3. The resultant set is therefore the set of all vertices which are divisible by 6.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_functor</td><td>A function/functor which takes a const <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html" title="Vertex object which provides access to the vertex data and information about the vertex. ">vertex_type</a>&amp; argument and returns a boolean denoting of the vertex is to be included in the returned set </td></tr>
    <tr><td class="paramname">vset</td><td>Optional. The set of vertices to evaluate the selection on. Defaults to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d" title="Retuns a full set of vertices. ">complete_set()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02524">2524</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a474e167cb558b7b95c6b752b629316d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::set_duplicate_vertex_strategy </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(<a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">vertex_data_type</a> &amp;, const <a class="el" href="classgraphlab_1_1distributed__graph.html#a0c51c740320127a4a45c6e9fcb133ccd">vertex_data_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>combine_strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the strategy to use when duplicate vertices are inserted. The default behavior is that an arbitrary vertex data is picked. This allows you to define a combining strategy. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00786">786</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94314e73f350f673d53f1791b13f8bb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename TransformType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::transform_edges </td>
          <td>(</td>
          <td class="paramtype">TransformType&#160;</td>
          <td class="paramname"><em>transform_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em> = <code><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89">edge_dir_type</a>&#160;</td>
          <td class="paramname"><em>edir</em> = <code><a class="el" href="namespacegraphlab.html#a7a1c434a751d2eee47f43906ee43fc89a3f916362fe7def918c229e6b430e61d6">IN_EDGES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each edge in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> calls mapfunction on every edge in graph. The map function may make modifications to the data on the edge. <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a> must be called on all machines simultaneously.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> graph_type;</div>
</div><!-- fragment --><p>To set each edge value to be the number of out-going edges of the target vertex, we may write the following: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_edge_value(<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">graph_type::edge_type</a>&amp; edge) {</div>
<div class="line">  edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a4eac8fe3111597c06f5732a63948ec31">data</a>() = edge.<a class="code" href="classgraphlab_1_1distributed__graph_1_1edge__type.html#a72d82dc1768a525697d6f4ca3d68a786">target</a>().<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3" title="Performs a transformation operation on each edge in the graph. ">transform_edges()</a>: </p><div class="fragment"><div class="line">graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a94314e73f350f673d53f1791b13f8bb3">transform_edges</a>(set_edge_value);</div>
</div><!-- fragment --><p> will run the <code>set_edge_value()</code> function on each edge in the graph, setting its new value.</p>
<p>The two optional arguments vset and edir may be used to restrict the set of edges operated upon.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1distributed__graph.html#a965c3ffe5d94ecf60093bcd29096114a" title="Performs a map-reduce operation on each edge in the graph returning the result. ">map_reduce_edges()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1iengine.html#a4ab681ecccc66ad8696f5a4d0103fa23" title="Performs a transformation operation on each edge in the graph. ">graphlab::iengine::transform_edges()</a> provide the same graph modification capabilities, but with a context and thus can perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EdgeMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an icontext_type&amp; as its first argument, and a <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a>, or a reference to a <a class="el" href="classgraphlab_1_1distributed__graph_1_1edge__type.html">edge_type</a> as its second argument. Returns void. </td></tr>
    <tr><td class="paramname">vset</td><td>A set of vertices. Combines with edir to identify the set of edges. For instance, if edir == IN_EDGES, map_reduce_edges will map over all in edges of the vertices in vset. Optional. Defaults to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d" title="Retuns a full set of vertices. ">complete_set()</a>. </td></tr>
    <tr><td class="paramname">edir</td><td>An edge direction. Combines with vset to identify the set of edges to map over. For instance, if edir == IN_EDGES, map_reduce_edges will map over all in edges of the vertices in vset. Optional. Defaults to IN_EDGES. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01547">1547</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5847479b9df685c1aca72af4230b583c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename TransformType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::transform_vertices </td>
          <td>(</td>
          <td class="paramtype">TransformType&#160;</td>
          <td class="paramname"><em>transform_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a>&#160;</td>
          <td class="paramname"><em>vset</em> = <code><a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a transformation operation on each vertex in the graph. </p>
<p>Given a mapfunction, <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> calls mapfunction on every vertex in graph. The map function may make modifications to the data on the vertex. <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a> must be called by all machines simultaneously.</p>
<p>The optional vset argument may be used to restrict the set of vertices operated upon.</p>
<h3>Basic Usage</h3>
<p>For instance, if the graph has integer vertex data, and integer edge data: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph&lt;size_t, size_t&gt;</a> graph_type;</div>
</div><!-- fragment --><p>To set each vertex value to be the number of out-going edges, we may write the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> set_vertex_value(<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">graph_type::vertex_type</a>&amp; vertex)i {</div>
<div class="line">  vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a1f80515cf596c6a9ec1e47c2fc5698f0">data</a>() = vertex.<a class="code" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html#a82ad0c51437cf822c92a8c4a904b74d1">num_out_edges</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Calling <a class="el" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c" title="Performs a transformation operation on each vertex in the graph. ">transform_vertices()</a>: </p><div class="fragment"><div class="line">graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a5847479b9df685c1aca72af4230b583c">transform_vertices</a>(set_vertex_value);</div>
</div><!-- fragment --><p> will run the <code>set_vertex_value()</code> function on each vertex in the graph, setting its new value.</p>
<h3>Relations</h3>
<p><a class="el" href="classgraphlab_1_1distributed__graph.html#a1bc876d97650f6afa6f1e1d77ac339a8" title="Performs a map-reduce operation on each vertex in the graph returning the result. ...">map_reduce_vertices()</a> provide similar signalling functionality, but should not make modifications to graph data. <a class="el" href="classgraphlab_1_1iengine.html#a4d9e97843604c45c08f71502b3494a7a" title="Performs a transformation operation on each vertex in the graph. ">graphlab::iengine::transform_vertices()</a> provide the same graph modification capabilities, but with a context and thus can perform signalling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexMapperType</td><td>The type of the map function. Not generally needed. Can be inferred by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapfunction</td><td>The map function to use. Must take an icontext_type&amp; as its first argument, and a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a>, or a reference to a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> as its second argument. Returns void. </td></tr>
    <tr><td class="paramname">vset</td><td>The set of vertices to transform. Optional. Defaults to <a class="el" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d" title="Retuns a full set of vertices. ">complete_set()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l01465">1465</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a354c3c532f70db9773c4d26b51f30d5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html">vertex_type</a> <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">vertex_id_type&#160;</td>
          <td class="paramname"><em>vid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts a vertex ID to a vertex object. This function should not be used without a deep understanding of the distributed graph representation. </p>
<p>This functions converts a global vertex ID to a <a class="el" href="structgraphlab_1_1distributed__graph_1_1vertex__type.html" title="Vertex object which provides access to the vertex data and information about the vertex. ">vertex_type</a> object. The global vertex ID must exist on this machine or assertion failures will be produced. </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l00729">729</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c7cd569c14fcd66b5ab12100508df16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::vertex_set_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the vertex set is empty. </p>
<p>This function must be called on all machines and returns true if the vertex set is empty </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02576">2576</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dbf070070b2704fb7a322d9bf7ad42e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classgraphlab_1_1distributed__graph.html">graphlab::distributed_graph</a>&lt; VertexData, EdgeData &gt;::vertex_set_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraphlab_1_1vertex__set.html">vertex_set</a> &amp;&#160;</td>
          <td class="paramname"><em>vset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices in a vertex set. </p>
<p>This function must be called on all machines and returns the number of vertices contained in the vertex set.</p>
<p>For instance: </p><div class="fragment"><div class="line">graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a5dbf070070b2704fb7a322d9bf7ad42e">vertex_set_size</a>(graph.<a class="code" href="classgraphlab_1_1distributed__graph.html#a3b0d354405eef16c6e3c9348d0341d7d">complete_set</a>());</div>
</div><!-- fragment --><p> will always evaluate to graph.num_vertices(); </p>

<p>Definition at line <a class="el" href="distributed__graph_8hpp_source.html#l02559">2559</a> of file <a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphlab/graph/<a class="el" href="distributed__graph_8hpp_source.html">distributed_graph.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegraphlab.html">graphlab</a></li><li class="navelem"><a class="el" href="classgraphlab_1_1distributed__graph.html">distributed_graph</a></li>
    <li class="footer">Generated on Mon Dec 29 2014 17:16:27 for GraphLab: Distributed Graph-Parallel API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
